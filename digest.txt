Directory structure:
└── workloadorchestration/
    ├── ci.yml
    ├── pom.xml
    └── azure-resourcemanager-workloadorchestration/
        ├── README.md
        ├── CHANGELOG.md
        ├── pom.xml
        ├── SAMPLE.md
        ├── tsp-location.yaml
        └── src/
            ├── main/
            │   ├── java/
            │   │   ├── module-info.java
            │   │   └── com/
            │   │       └── azure/
            │   │           └── resourcemanager/
            │   │               └── workloadorchestration/
            │   │                   ├── package-info.java
            │   │                   ├── WorkloadOrchestrationManager.java
            │   │                   ├── fluent/
            │   │                   │   ├── ConfigTemplatesClient.java
            │   │                   │   ├── ConfigTemplateVersionsClient.java
            │   │                   │   ├── ContextsClient.java
            │   │                   │   ├── DiagnosticsClient.java
            │   │                   │   ├── DynamicSchemasClient.java
            │   │                   │   ├── DynamicSchemaVersionsClient.java
            │   │                   │   ├── ExecutionsClient.java
            │   │                   │   ├── InstanceHistoriesClient.java
            │   │                   │   ├── InstancesClient.java
            │   │                   │   ├── JobsClient.java
            │   │                   │   ├── package-info.java
            │   │                   │   ├── SchemaReferencesClient.java
            │   │                   │   ├── SchemasClient.java
            │   │                   │   ├── SchemaVersionsClient.java
            │   │                   │   ├── SiteReferencesClient.java
            │   │                   │   ├── SolutionsClient.java
            │   │                   │   ├── SolutionTemplatesClient.java
            │   │                   │   ├── SolutionTemplateVersionsClient.java
            │   │                   │   ├── SolutionVersionsClient.java
            │   │                   │   ├── TargetsClient.java
            │   │                   │   ├── WorkflowsClient.java
            │   │                   │   ├── WorkflowVersionsClient.java
            │   │                   │   ├── WorkloadOrchestrationManagementClient.java
            │   │                   │   └── models/
            │   │                   │       ├── ConfigTemplateInner.java
            │   │                   │       ├── ConfigTemplateVersionInner.java
            │   │                   │       ├── ConfigTemplateVersionWithUpdateTypeInner.java
            │   │                   │       ├── ContextInner.java
            │   │                   │       ├── DiagnosticInner.java
            │   │                   │       ├── DynamicSchemaInner.java
            │   │                   │       ├── DynamicSchemaVersionInner.java
            │   │                   │       ├── ExecutionInner.java
            │   │                   │       ├── InstanceHistoryInner.java
            │   │                   │       ├── InstanceInner.java
            │   │                   │       ├── JobInner.java
            │   │                   │       ├── package-info.java
            │   │                   │       ├── RemoveVersionResponseInner.java
            │   │                   │       ├── ResolvedConfigurationInner.java
            │   │                   │       ├── SchemaInner.java
            │   │                   │       ├── SchemaReferenceInner.java
            │   │                   │       ├── SchemaVersionInner.java
            │   │                   │       ├── SchemaVersionWithUpdateTypeInner.java
            │   │                   │       ├── SiteReferenceInner.java
            │   │                   │       ├── SolutionInner.java
            │   │                   │       ├── SolutionTemplateInner.java
            │   │                   │       ├── SolutionTemplateVersionInner.java
            │   │                   │       ├── SolutionTemplateVersionWithUpdateTypeInner.java
            │   │                   │       ├── SolutionVersionInner.java
            │   │                   │       ├── TargetInner.java
            │   │                   │       ├── WorkflowInner.java
            │   │                   │       └── WorkflowVersionInner.java
            │   │                   ├── implementation/
            │   │                   │   ├── ConfigTemplateImpl.java
            │   │                   │   ├── ConfigTemplatesClientImpl.java
            │   │                   │   ├── ConfigTemplatesImpl.java
            │   │                   │   ├── ConfigTemplateVersionImpl.java
            │   │                   │   ├── ConfigTemplateVersionsClientImpl.java
            │   │                   │   ├── ConfigTemplateVersionsImpl.java
            │   │                   │   ├── ConfigTemplateVersionWithUpdateTypeImpl.java
            │   │                   │   ├── ContextModelImpl.java
            │   │                   │   ├── ContextsClientImpl.java
            │   │                   │   ├── ContextsImpl.java
            │   │                   │   ├── DiagnosticImpl.java
            │   │                   │   ├── DiagnosticsClientImpl.java
            │   │                   │   ├── DiagnosticsImpl.java
            │   │                   │   ├── DynamicSchemaImpl.java
            │   │                   │   ├── DynamicSchemasClientImpl.java
            │   │                   │   ├── DynamicSchemasImpl.java
            │   │                   │   ├── DynamicSchemaVersionImpl.java
            │   │                   │   ├── DynamicSchemaVersionsClientImpl.java
            │   │                   │   ├── DynamicSchemaVersionsImpl.java
            │   │                   │   ├── ExecutionImpl.java
            │   │                   │   ├── ExecutionsClientImpl.java
            │   │                   │   ├── ExecutionsImpl.java
            │   │                   │   ├── InstanceHistoriesClientImpl.java
            │   │                   │   ├── InstanceHistoriesImpl.java
            │   │                   │   ├── InstanceHistoryImpl.java
            │   │                   │   ├── InstanceImpl.java
            │   │                   │   ├── InstancesClientImpl.java
            │   │                   │   ├── InstancesImpl.java
            │   │                   │   ├── JobImpl.java
            │   │                   │   ├── JobsClientImpl.java
            │   │                   │   ├── JobsImpl.java
            │   │                   │   ├── package-info.java
            │   │                   │   ├── RemoveVersionResponseImpl.java
            │   │                   │   ├── ResolvedConfigurationImpl.java
            │   │                   │   ├── ResourceManagerUtils.java
            │   │                   │   ├── SchemaImpl.java
            │   │                   │   ├── SchemaReferenceImpl.java
            │   │                   │   ├── SchemaReferencesClientImpl.java
            │   │                   │   ├── SchemaReferencesImpl.java
            │   │                   │   ├── SchemasClientImpl.java
            │   │                   │   ├── SchemasImpl.java
            │   │                   │   ├── SchemaVersionImpl.java
            │   │                   │   ├── SchemaVersionsClientImpl.java
            │   │                   │   ├── SchemaVersionsImpl.java
            │   │                   │   ├── SchemaVersionWithUpdateTypeImpl.java
            │   │                   │   ├── SiteReferenceImpl.java
            │   │                   │   ├── SiteReferencesClientImpl.java
            │   │                   │   ├── SiteReferencesImpl.java
            │   │                   │   ├── SolutionImpl.java
            │   │                   │   ├── SolutionsClientImpl.java
            │   │                   │   ├── SolutionsImpl.java
            │   │                   │   ├── SolutionTemplateImpl.java
            │   │                   │   ├── SolutionTemplatesClientImpl.java
            │   │                   │   ├── SolutionTemplatesImpl.java
            │   │                   │   ├── SolutionTemplateVersionImpl.java
            │   │                   │   ├── SolutionTemplateVersionsClientImpl.java
            │   │                   │   ├── SolutionTemplateVersionsImpl.java
            │   │                   │   ├── SolutionTemplateVersionWithUpdateTypeImpl.java
            │   │                   │   ├── SolutionVersionImpl.java
            │   │                   │   ├── SolutionVersionsClientImpl.java
            │   │                   │   ├── SolutionVersionsImpl.java
            │   │                   │   ├── TargetImpl.java
            │   │                   │   ├── TargetsClientImpl.java
            │   │                   │   ├── TargetsImpl.java
            │   │                   │   ├── WorkflowImpl.java
            │   │                   │   ├── WorkflowsClientImpl.java
            │   │                   │   ├── WorkflowsImpl.java
            │   │                   │   ├── WorkflowVersionImpl.java
            │   │                   │   ├── WorkflowVersionsClientImpl.java
            │   │                   │   ├── WorkflowVersionsImpl.java
            │   │                   │   ├── WorkloadOrchestrationManagementClientImpl.java
            │   │                   │   └── models/
            │   │                   │       ├── ConfigTemplateListResult.java
            │   │                   │       ├── ConfigTemplateVersionListResult.java
            │   │                   │       ├── ContextListResult.java
            │   │                   │       ├── DiagnosticListResult.java
            │   │                   │       ├── DynamicSchemaListResult.java
            │   │                   │       ├── DynamicSchemaVersionListResult.java
            │   │                   │       ├── ExecutionListResult.java
            │   │                   │       ├── InstanceHistoryListResult.java
            │   │                   │       ├── InstanceListResult.java
            │   │                   │       ├── JobListResult.java
            │   │                   │       ├── SchemaListResult.java
            │   │                   │       ├── SchemaReferenceListResult.java
            │   │                   │       ├── SchemaVersionListResult.java
            │   │                   │       ├── SiteReferenceListResult.java
            │   │                   │       ├── SolutionListResult.java
            │   │                   │       ├── SolutionTemplateListResult.java
            │   │                   │       ├── SolutionTemplateVersionListResult.java
            │   │                   │       ├── SolutionVersionListResult.java
            │   │                   │       ├── TargetListResult.java
            │   │                   │       ├── WorkflowListResult.java
            │   │                   │       └── WorkflowVersionListResult.java
            │   │                   └── models/
            │   │                       ├── ActiveState.java
            │   │                       ├── AvailableSolutionTemplateVersion.java
            │   │                       ├── BulkDeploySolutionParameter.java
            │   │                       ├── BulkDeployTargetDetails.java
            │   │                       ├── BulkPublishSolutionParameter.java
            │   │                       ├── BulkPublishTargetDetails.java
            │   │                       ├── Capability.java
            │   │                       ├── ComponentStatus.java
            │   │                       ├── ConfigTemplate.java
            │   │                       ├── ConfigTemplateProperties.java
            │   │                       ├── ConfigTemplates.java
            │   │                       ├── ConfigTemplateVersion.java
            │   │                       ├── ConfigTemplateVersionProperties.java
            │   │                       ├── ConfigTemplateVersions.java
            │   │                       ├── ConfigTemplateVersionWithUpdateType.java
            │   │                       ├── ConfigurationModel.java
            │   │                       ├── ConfigurationType.java
            │   │                       ├── ContextModel.java
            │   │                       ├── ContextProperties.java
            │   │                       ├── Contexts.java
            │   │                       ├── DeployJobParameter.java
            │   │                       ├── DeployJobStepStatistics.java
            │   │                       ├── DeploymentStatus.java
            │   │                       ├── Diagnostic.java
            │   │                       ├── DiagnosticProperties.java
            │   │                       ├── Diagnostics.java
            │   │                       ├── DynamicSchema.java
            │   │                       ├── DynamicSchemaProperties.java
            │   │                       ├── DynamicSchemas.java
            │   │                       ├── DynamicSchemaVersion.java
            │   │                       ├── DynamicSchemaVersions.java
            │   │                       ├── ErrorAction.java
            │   │                       ├── ErrorActionMode.java
            │   │                       ├── Execution.java
            │   │                       ├── ExecutionProperties.java
            │   │                       ├── Executions.java
            │   │                       ├── ExecutionStatus.java
            │   │                       ├── ExtendedLocation.java
            │   │                       ├── ExtendedLocationType.java
            │   │                       ├── Hierarchy.java
            │   │                       ├── InstallSolutionParameter.java
            │   │                       ├── Instance.java
            │   │                       ├── InstanceHistories.java
            │   │                       ├── InstanceHistory.java
            │   │                       ├── InstanceHistoryProperties.java
            │   │                       ├── InstanceProperties.java
            │   │                       ├── Instances.java
            │   │                       ├── Job.java
            │   │                       ├── JobParameterBase.java
            │   │                       ├── JobProperties.java
            │   │                       ├── Jobs.java
            │   │                       ├── JobStatus.java
            │   │                       ├── JobStep.java
            │   │                       ├── JobStepStatisticsBase.java
            │   │                       ├── JobType.java
            │   │                       ├── OrchestratorType.java
            │   │                       ├── package-info.java
            │   │                       ├── ProvisioningState.java
            │   │                       ├── ReconciliationPolicyProperties.java
            │   │                       ├── ReconciliationState.java
            │   │                       ├── RemoveRevisionParameter.java
            │   │                       ├── RemoveVersionResponse.java
            │   │                       ├── ResolvedConfiguration.java
            │   │                       ├── ResourceState.java
            │   │                       ├── Schema.java
            │   │                       ├── SchemaProperties.java
            │   │                       ├── SchemaReference.java
            │   │                       ├── SchemaReferenceProperties.java
            │   │                       ├── SchemaReferences.java
            │   │                       ├── Schemas.java
            │   │                       ├── SchemaVersion.java
            │   │                       ├── SchemaVersionProperties.java
            │   │                       ├── SchemaVersions.java
            │   │                       ├── SchemaVersionWithUpdateType.java
            │   │                       ├── SiteReference.java
            │   │                       ├── SiteReferenceProperties.java
            │   │                       ├── SiteReferences.java
            │   │                       ├── Solution.java
            │   │                       ├── SolutionDependency.java
            │   │                       ├── SolutionDependencyParameter.java
            │   │                       ├── SolutionProperties.java
            │   │                       ├── Solutions.java
            │   │                       ├── SolutionTemplate.java
            │   │                       ├── SolutionTemplateParameter.java
            │   │                       ├── SolutionTemplateProperties.java
            │   │                       ├── SolutionTemplates.java
            │   │                       ├── SolutionTemplateVersion.java
            │   │                       ├── SolutionTemplateVersionProperties.java
            │   │                       ├── SolutionTemplateVersions.java
            │   │                       ├── SolutionTemplateVersionWithUpdateType.java
            │   │                       ├── SolutionVersion.java
            │   │                       ├── SolutionVersionParameter.java
            │   │                       ├── SolutionVersionProperties.java
            │   │                       ├── SolutionVersions.java
            │   │                       ├── SolutionVersionSnapshot.java
            │   │                       ├── StageSpec.java
            │   │                       ├── StageStatus.java
            │   │                       ├── State.java
            │   │                       ├── Target.java
            │   │                       ├── TargetProperties.java
            │   │                       ├── Targets.java
            │   │                       ├── TargetSnapshot.java
            │   │                       ├── TargetStatus.java
            │   │                       ├── TaskOption.java
            │   │                       ├── TaskSpec.java
            │   │                       ├── UninstallSolutionParameter.java
            │   │                       ├── UpdateExternalValidationStatusParameter.java
            │   │                       ├── UpdateType.java
            │   │                       ├── ValidationStatus.java
            │   │                       ├── VersionParameter.java
            │   │                       ├── Workflow.java
            │   │                       ├── WorkflowProperties.java
            │   │                       ├── Workflows.java
            │   │                       ├── WorkflowVersion.java
            │   │                       ├── WorkflowVersionProperties.java
            │   │                       └── WorkflowVersions.java
            │   └── resources/
            │       ├── azure-resourcemanager-workloadorchestration.properties
            │       └── META-INF/
            │           ├── azure-resourcemanager-workloadorchestration_apiview_properties.json
            │           └── azure-resourcemanager-workloadorchestration_metadata.json
            ├── samples/
            │   └── java/
            │       └── com/
            │           └── azure/
            │               └── resourcemanager/
            │                   └── workloadorchestration/
            │                       └── generated/
            │                           ├── ConfigTemplatesCreateOrUpdateSamples.java
            │                           ├── ConfigTemplatesCreateVersionSamples.java
            │                           ├── ConfigTemplatesDeleteSamples.java
            │                           ├── ConfigTemplatesGetByResourceGroupSamples.java
            │                           ├── ConfigTemplatesListByResourceGroupSamples.java
            │                           ├── ConfigTemplatesListSamples.java
            │                           ├── ConfigTemplatesRemoveVersionSamples.java
            │                           ├── ConfigTemplatesUpdateSamples.java
            │                           ├── ConfigTemplateVersionsGetSamples.java
            │                           ├── ContextsCreateOrUpdateSamples.java
            │                           ├── ContextsDeleteSamples.java
            │                           ├── ContextsGetByResourceGroupSamples.java
            │                           ├── ContextsListByResourceGroupSamples.java
            │                           ├── ContextsListSamples.java
            │                           ├── ContextsUpdateSamples.java
            │                           ├── DiagnosticsCreateOrUpdateSamples.java
            │                           ├── DiagnosticsDeleteSamples.java
            │                           ├── DiagnosticsGetByResourceGroupSamples.java
            │                           ├── DiagnosticsListByResourceGroupSamples.java
            │                           ├── DiagnosticsListSamples.java
            │                           ├── DiagnosticsUpdateSamples.java
            │                           ├── DynamicSchemasCreateOrUpdateSamples.java
            │                           ├── DynamicSchemasDeleteSamples.java
            │                           ├── DynamicSchemasGetSamples.java
            │                           ├── DynamicSchemasListBySchemaSamples.java
            │                           ├── DynamicSchemasUpdateSamples.java
            │                           ├── DynamicSchemaVersionsCreateOrUpdateSamples.java
            │                           ├── DynamicSchemaVersionsDeleteSamples.java
            │                           ├── DynamicSchemaVersionsGetSamples.java
            │                           ├── DynamicSchemaVersionsUpdateSamples.java
            │                           ├── ExecutionsCreateOrUpdateSamples.java
            │                           ├── ExecutionsDeleteSamples.java
            │                           ├── ExecutionsGetSamples.java
            │                           ├── ExecutionsListByWorkflowVersionSamples.java
            │                           ├── ExecutionsUpdateSamples.java
            │                           ├── InstanceHistoriesGetSamples.java
            │                           ├── InstanceHistoriesListByInstanceSamples.java
            │                           ├── InstancesCreateOrUpdateSamples.java
            │                           ├── InstancesDeleteSamples.java
            │                           ├── InstancesGetSamples.java
            │                           ├── InstancesListBySolutionSamples.java
            │                           ├── InstancesUpdateSamples.java
            │                           ├── JobsGetSamples.java
            │                           ├── JobsListByTargetSamples.java
            │                           ├── SchemaReferencesGetSamples.java
            │                           ├── SchemaReferencesListByResourceGroupSamples.java
            │                           ├── SchemasCreateOrUpdateSamples.java
            │                           ├── SchemasCreateVersionSamples.java
            │                           ├── SchemasDeleteSamples.java
            │                           ├── SchemasGetByResourceGroupSamples.java
            │                           ├── SchemasListByResourceGroupSamples.java
            │                           ├── SchemasListSamples.java
            │                           ├── SchemasRemoveVersionSamples.java
            │                           ├── SchemasUpdateSamples.java
            │                           ├── SchemaVersionsCreateOrUpdateSamples.java
            │                           ├── SchemaVersionsDeleteSamples.java
            │                           ├── SchemaVersionsGetSamples.java
            │                           ├── SchemaVersionsListBySchemaSamples.java
            │                           ├── SchemaVersionsUpdateSamples.java
            │                           ├── SiteReferencesCreateOrUpdateSamples.java
            │                           ├── SiteReferencesDeleteSamples.java
            │                           ├── SiteReferencesGetSamples.java
            │                           ├── SiteReferencesListByContextSamples.java
            │                           ├── SiteReferencesUpdateSamples.java
            │                           ├── SolutionsCreateOrUpdateSamples.java
            │                           ├── SolutionsDeleteSamples.java
            │                           ├── SolutionsGetSamples.java
            │                           ├── SolutionsListByTargetSamples.java
            │                           ├── SolutionsUpdateSamples.java
            │                           ├── SolutionTemplatesCreateOrUpdateSamples.java
            │                           ├── SolutionTemplatesCreateVersionSamples.java
            │                           ├── SolutionTemplatesDeleteSamples.java
            │                           ├── SolutionTemplatesGetByResourceGroupSamples.java
            │                           ├── SolutionTemplatesListByResourceGroupSamples.java
            │                           ├── SolutionTemplatesListSamples.java
            │                           ├── SolutionTemplatesRemoveVersionSamples.java
            │                           ├── SolutionTemplatesUpdateSamples.java
            │                           ├── SolutionTemplateVersionsGetSamples.java
            │                           ├── SolutionVersionsCreateOrUpdateSamples.java
            │                           ├── SolutionVersionsDeleteSamples.java
            │                           ├── SolutionVersionsGetSamples.java
            │                           ├── SolutionVersionsListBySolutionSamples.java
            │                           ├── SolutionVersionsUpdateSamples.java
            │                           ├── TargetsCreateOrUpdateSamples.java
            │                           ├── TargetsDeleteSamples.java
            │                           ├── TargetsGetByResourceGroupSamples.java
            │                           ├── TargetsInstallSolutionSamples.java
            │                           ├── TargetsListByResourceGroupSamples.java
            │                           ├── TargetsListSamples.java
            │                           ├── TargetsPublishSolutionVersionSamples.java
            │                           ├── TargetsRemoveRevisionSamples.java
            │                           ├── TargetsResolveConfigurationSamples.java
            │                           ├── TargetsReviewSolutionVersionSamples.java
            │                           ├── TargetsUninstallSolutionSamples.java
            │                           ├── TargetsUpdateExternalValidationStatusSamples.java
            │                           ├── TargetsUpdateSamples.java
            │                           ├── WorkflowsCreateOrUpdateSamples.java
            │                           ├── WorkflowsDeleteSamples.java
            │                           ├── WorkflowsGetSamples.java
            │                           ├── WorkflowsListByContextSamples.java
            │                           ├── WorkflowsUpdateSamples.java
            │                           ├── WorkflowVersionsCreateOrUpdateSamples.java
            │                           ├── WorkflowVersionsDeleteSamples.java
            │                           ├── WorkflowVersionsGetSamples.java
            │                           ├── WorkflowVersionsListByWorkflowSamples.java
            │                           └── WorkflowVersionsUpdateSamples.java
            └── test/
                └── java/
                    └── com/
                        └── azure/
                            └── resourcemanager/
                                └── workloadorchestration/
                                    └── generated/
                                        ├── AvailableSolutionTemplateVersionTests.java
                                        ├── BulkDeploySolutionParameterTests.java
                                        ├── BulkDeployTargetDetailsTests.java
                                        ├── BulkPublishSolutionParameterTests.java
                                        ├── BulkPublishTargetDetailsTests.java
                                        ├── CapabilityTests.java
                                        ├── ComponentStatusTests.java
                                        ├── ConfigTemplateInnerTests.java
                                        ├── ConfigTemplateListResultTests.java
                                        ├── ConfigTemplatePropertiesTests.java
                                        ├── ConfigTemplatesCreateOrUpdateMockTests.java
                                        ├── ConfigTemplatesCreateVersionMockTests.java
                                        ├── ConfigTemplatesListByResourceGroupMockTests.java
                                        ├── ConfigTemplatesListMockTests.java
                                        ├── ConfigTemplateVersionInnerTests.java
                                        ├── ConfigTemplateVersionListResultTests.java
                                        ├── ConfigTemplateVersionPropertiesTests.java
                                        ├── ConfigTemplateVersionsGetWithResponseMockTests.java
                                        ├── ConfigTemplateVersionWithUpdateTypeInnerTests.java
                                        ├── ContextInnerTests.java
                                        ├── ContextListResultTests.java
                                        ├── ContextPropertiesTests.java
                                        ├── ContextsCreateOrUpdateMockTests.java
                                        ├── ContextsGetByResourceGroupWithResponseMockTests.java
                                        ├── ContextsListByResourceGroupMockTests.java
                                        ├── ContextsListMockTests.java
                                        ├── DeployJobParameterTests.java
                                        ├── DeployJobStepStatisticsTests.java
                                        ├── DeploymentStatusTests.java
                                        ├── DiagnosticInnerTests.java
                                        ├── DiagnosticListResultTests.java
                                        ├── DiagnosticPropertiesTests.java
                                        ├── DiagnosticsCreateOrUpdateMockTests.java
                                        ├── DiagnosticsListByResourceGroupMockTests.java
                                        ├── DiagnosticsListMockTests.java
                                        ├── DynamicSchemaInnerTests.java
                                        ├── DynamicSchemaListResultTests.java
                                        ├── DynamicSchemaPropertiesTests.java
                                        ├── DynamicSchemasCreateOrUpdateMockTests.java
                                        ├── DynamicSchemasGetWithResponseMockTests.java
                                        ├── DynamicSchemasListBySchemaMockTests.java
                                        ├── DynamicSchemaVersionInnerTests.java
                                        ├── DynamicSchemaVersionListResultTests.java
                                        ├── DynamicSchemaVersionsCreateOrUpdateMockTests.java
                                        ├── DynamicSchemaVersionsGetWithResponseMockTests.java
                                        ├── ErrorActionTests.java
                                        ├── ExecutionInnerTests.java
                                        ├── ExecutionListResultTests.java
                                        ├── ExecutionPropertiesTests.java
                                        ├── ExecutionsCreateOrUpdateMockTests.java
                                        ├── ExecutionsGetWithResponseMockTests.java
                                        ├── ExecutionsListByWorkflowVersionMockTests.java
                                        ├── ExecutionStatusTests.java
                                        ├── ExtendedLocationTests.java
                                        ├── HierarchyTests.java
                                        ├── InstallSolutionParameterTests.java
                                        ├── InstanceHistoriesGetWithResponseMockTests.java
                                        ├── InstanceHistoriesListByInstanceMockTests.java
                                        ├── InstanceHistoryInnerTests.java
                                        ├── InstanceHistoryListResultTests.java
                                        ├── InstanceHistoryPropertiesTests.java
                                        ├── InstanceInnerTests.java
                                        ├── InstanceListResultTests.java
                                        ├── InstancePropertiesTests.java
                                        ├── InstancesCreateOrUpdateMockTests.java
                                        ├── InstancesGetWithResponseMockTests.java
                                        ├── InstancesListBySolutionMockTests.java
                                        ├── JobParameterBaseTests.java
                                        ├── JobStepStatisticsBaseTests.java
                                        ├── ReconciliationPolicyPropertiesTests.java
                                        ├── RemoveRevisionParameterTests.java
                                        ├── RemoveVersionResponseInnerTests.java
                                        ├── ResolvedConfigurationInnerTests.java
                                        ├── SchemaInnerTests.java
                                        ├── SchemaListResultTests.java
                                        ├── SchemaPropertiesTests.java
                                        ├── SchemaReferenceInnerTests.java
                                        ├── SchemaReferenceListResultTests.java
                                        ├── SchemaReferencePropertiesTests.java
                                        ├── SchemaReferencesGetWithResponseMockTests.java
                                        ├── SchemaReferencesListByResourceGroupMockTests.java
                                        ├── SchemasCreateOrUpdateMockTests.java
                                        ├── SchemasCreateVersionMockTests.java
                                        ├── SchemasGetByResourceGroupWithResponseMockTests.java
                                        ├── SchemasListByResourceGroupMockTests.java
                                        ├── SchemasListMockTests.java
                                        ├── SchemasRemoveVersionWithResponseMockTests.java
                                        ├── SchemaVersionInnerTests.java
                                        ├── SchemaVersionListResultTests.java
                                        ├── SchemaVersionPropertiesTests.java
                                        ├── SchemaVersionsCreateOrUpdateMockTests.java
                                        ├── SchemaVersionsGetWithResponseMockTests.java
                                        ├── SchemaVersionsListBySchemaMockTests.java
                                        ├── SchemaVersionWithUpdateTypeInnerTests.java
                                        ├── SiteReferenceInnerTests.java
                                        ├── SiteReferenceListResultTests.java
                                        ├── SiteReferencePropertiesTests.java
                                        ├── SiteReferencesCreateOrUpdateMockTests.java
                                        ├── SiteReferencesGetWithResponseMockTests.java
                                        ├── SiteReferencesListByContextMockTests.java
                                        ├── SolutionDependencyParameterTests.java
                                        ├── SolutionDependencyTests.java
                                        ├── SolutionInnerTests.java
                                        ├── SolutionListResultTests.java
                                        ├── SolutionPropertiesTests.java
                                        ├── SolutionsCreateOrUpdateMockTests.java
                                        ├── SolutionsGetWithResponseMockTests.java
                                        ├── SolutionsListByTargetMockTests.java
                                        ├── SolutionTemplateInnerTests.java
                                        ├── SolutionTemplateListResultTests.java
                                        ├── SolutionTemplateParameterTests.java
                                        ├── SolutionTemplatePropertiesTests.java
                                        ├── SolutionTemplatesCreateOrUpdateMockTests.java
                                        ├── SolutionTemplatesCreateVersionMockTests.java
                                        ├── SolutionTemplatesListByResourceGroupMockTests.java
                                        ├── SolutionTemplatesListMockTests.java
                                        ├── SolutionTemplateVersionInnerTests.java
                                        ├── SolutionTemplateVersionListResultTests.java
                                        ├── SolutionTemplateVersionPropertiesTests.java
                                        ├── SolutionTemplateVersionsGetWithResponseMockTests.java
                                        ├── SolutionTemplateVersionWithUpdateTypeInnerTests.java
                                        ├── SolutionVersionParameterTests.java
                                        ├── SolutionVersionSnapshotTests.java
                                        ├── StageSpecTests.java
                                        ├── StageStatusTests.java
                                        ├── TargetInnerTests.java
                                        ├── TargetListResultTests.java
                                        ├── TargetPropertiesTests.java
                                        ├── TargetsCreateOrUpdateMockTests.java
                                        ├── TargetsGetByResourceGroupWithResponseMockTests.java
                                        ├── TargetsListByResourceGroupMockTests.java
                                        ├── TargetsListMockTests.java
                                        ├── TargetSnapshotTests.java
                                        ├── TargetsResolveConfigurationMockTests.java
                                        ├── TargetStatusTests.java
                                        ├── TaskOptionTests.java
                                        ├── TaskSpecTests.java
                                        ├── UninstallSolutionParameterTests.java
                                        ├── VersionParameterTests.java
                                        ├── WorkflowInnerTests.java
                                        ├── WorkflowListResultTests.java
                                        ├── WorkflowPropertiesTests.java
                                        ├── WorkflowsCreateOrUpdateMockTests.java
                                        ├── WorkflowsGetWithResponseMockTests.java
                                        ├── WorkflowsListByContextMockTests.java
                                        ├── WorkflowVersionInnerTests.java
                                        ├── WorkflowVersionListResultTests.java
                                        ├── WorkflowVersionPropertiesTests.java
                                        ├── WorkflowVersionsCreateOrUpdateMockTests.java
                                        ├── WorkflowVersionsGetWithResponseMockTests.java
                                        └── WorkflowVersionsListByWorkflowMockTests.java

================================================
FILE: ci.yml
================================================
# NOTE: Please refer to https://aka.ms/azsdk/engsys/ci-yaml before editing this file.

trigger:
  branches:
    include:
      - main
      - hotfix/*
      - release/*
  paths:
    include:
      - sdk/workloadorchestration/ci.yml
      - sdk/workloadorchestration/azure-resourcemanager-workloadorchestration/
    exclude:
      - sdk/workloadorchestration/pom.xml
      - sdk/workloadorchestration/azure-resourcemanager-workloadorchestration/pom.xml

pr:
  branches:
    include:
      - main
      - feature/*
      - hotfix/*
      - release/*
  paths:
    include:
      - sdk/workloadorchestration/ci.yml
      - sdk/workloadorchestration/azure-resourcemanager-workloadorchestration/
    exclude:
      - sdk/workloadorchestration/pom.xml
      - sdk/workloadorchestration/azure-resourcemanager-workloadorchestration/pom.xml

parameters:
  - name: release_azureresourcemanagerworkloadorchestration
    displayName: azure-resourcemanager-workloadorchestration
    type: boolean
    default: false

extends:
  template: ../../eng/pipelines/templates/stages/archetype-sdk-client.yml
  parameters:
    ServiceDirectory: workloadorchestration
    Artifacts:
      - name: azure-resourcemanager-workloadorchestration
        groupId: com.azure.resourcemanager
        safeName: azureresourcemanagerworkloadorchestration
        releaseInBatch: ${{ parameters.release_azureresourcemanagerworkloadorchestration }}



================================================
FILE: pom.xml
================================================
<!-- Copyright (c) Microsoft Corporation. All rights reserved.
     Licensed under the MIT License. -->
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.azure</groupId>
  <artifactId>azure-workloadorchestration-service</artifactId>
  <packaging>pom</packaging>
  <version>1.0.0</version><!-- Need not change for every release-->

  <modules>
    <module>azure-resourcemanager-workloadorchestration</module>
  </modules>
</project>



================================================
FILE: azure-resourcemanager-workloadorchestration/README.md
================================================
# Azure Resource Manager Workload Orchestration client library for Java

Azure Resource Manager Workload Orchestration client library for Java.

This package contains Microsoft Azure SDK for Workload Orchestration Management SDK. Microsoft.Edge Resource Provider management API. Package api-version 2025-06-01. For documentation on how to use this package, please see [Azure Management Libraries for Java](https://aka.ms/azsdk/java/mgmt).

## We'd love to hear your feedback

We're always working on improving our products and the way we communicate with our users. So we'd love to learn what's working and how we can do better.

If you haven't already, please take a few minutes to [complete this short survey][survey] we have put together.

Thank you in advance for your collaboration. We really appreciate your time!

## Documentation

Various documentation is available to help you get started

- [API reference documentation][docs]

## Getting started

### Prerequisites

- [Java Development Kit (JDK)][jdk] with version 8 or above
- [Azure Subscription][azure_subscription]

### Adding the package to your product

[//]: # ({x-version-update-start;com.azure.resourcemanager:azure-resourcemanager-workloadorchestration;current})
```xml
<dependency>
    <groupId>com.azure.resourcemanager</groupId>
    <artifactId>azure-resourcemanager-workloadorchestration</artifactId>
    <version>1.0.0-beta.1</version>
</dependency>
```
[//]: # ({x-version-update-end})

### Include the recommended packages

Azure Management Libraries require a `TokenCredential` implementation for authentication and an `HttpClient` implementation for HTTP client.

[Azure Identity][azure_identity] and [Azure Core Netty HTTP][azure_core_http_netty] packages provide the default implementation.

### Authentication

Microsoft Entra ID token authentication relies on the [credential class][azure_identity_credentials] from [Azure Identity][azure_identity] package.

Azure subscription ID can be configured via `AZURE_SUBSCRIPTION_ID` environment variable.

Assuming the use of the `DefaultAzureCredential` credential class, the client can be authenticated using the following code:

```java
AzureProfile profile = new AzureProfile(AzureCloud.AZURE_PUBLIC_CLOUD);
TokenCredential credential = new DefaultAzureCredentialBuilder()
    .authorityHost(profile.getEnvironment().getActiveDirectoryEndpoint())
    .build();
WorkloadOrchestrationManager manager = WorkloadOrchestrationManager
    .authenticate(credential, profile);
```

The sample code assumes global Azure. Please change the `AzureCloud.AZURE_PUBLIC_CLOUD` variable if otherwise.

See [Authentication][authenticate] for more options.

## Key concepts

See [API design][design] for general introduction on design and key concepts on Azure Management Libraries.

## Examples

[Code snippets and samples](https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/workloadorchestration/azure-resourcemanager-workloadorchestration/SAMPLE.md)


## Troubleshooting

## Next steps

## Contributing

For details on contributing to this repository, see the [contributing guide][cg].

This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit <https://cla.microsoft.com>.

When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repositories using our CLA.

This project has adopted the [Microsoft Open Source Code of Conduct][coc]. For more information see the [Code of Conduct FAQ][coc_faq] or contact <opencode@microsoft.com> with any additional questions or comments.

<!-- LINKS -->
[survey]: https://microsoft.qualtrics.com/jfe/form/SV_ehN0lIk2FKEBkwd?Q_CHL=DOCS
[docs]: https://azure.github.io/azure-sdk-for-java/
[jdk]: https://learn.microsoft.com/azure/developer/java/fundamentals/
[azure_subscription]: https://azure.microsoft.com/free/
[azure_identity]: https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/identity/azure-identity
[azure_identity_credentials]: https://github.com/Azure/azure-sdk-for-java/tree/main/sdk/identity/azure-identity#credentials
[azure_core_http_netty]: https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/core/azure-core-http-netty
[authenticate]: https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/resourcemanager/docs/AUTH.md
[design]: https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/resourcemanager/docs/DESIGN.md
[cg]: https://github.com/Azure/azure-sdk-for-java/blob/main/CONTRIBUTING.md
[coc]: https://opensource.microsoft.com/codeofconduct/
[coc_faq]: https://opensource.microsoft.com/codeofconduct/faq/



================================================
FILE: azure-resourcemanager-workloadorchestration/CHANGELOG.md
================================================
# Release History

## 1.0.0-beta.2 (Unreleased)

### Features Added

### Breaking Changes

### Bugs Fixed

### Other Changes

## 1.0.0-beta.1 (2025-08-22)

- Azure Resource Manager Workload Orchestration client library for Java. This package contains Microsoft Azure SDK for Workload Orchestration Management SDK. Microsoft.Edge Resource Provider management API. Package api-version 2025-06-01. For documentation on how to use this package, please see [Azure Management Libraries for Java](https://aka.ms/azsdk/java/mgmt).
### Features Added

- Initial release for the azure-resourcemanager-workloadorchestration Java SDK.



================================================
FILE: azure-resourcemanager-workloadorchestration/pom.xml
================================================
<!--
 ~ Copyright (c) Microsoft Corporation. All rights reserved.
 ~ Licensed under the MIT License.
 ~ Code generated by Microsoft (R) TypeSpec Code Generator.
 -->
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.azure</groupId>
    <artifactId>azure-client-sdk-parent</artifactId>
    <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->
    <relativePath>../../parents/azure-client-sdk-parent</relativePath>
  </parent>

  <groupId>com.azure.resourcemanager</groupId>
  <artifactId>azure-resourcemanager-workloadorchestration</artifactId>
  <version>1.0.0-beta.2</version> <!-- {x-version-update;com.azure.resourcemanager:azure-resourcemanager-workloadorchestration;current} -->
  <packaging>jar</packaging>

  <name>Microsoft Azure SDK for Workload Orchestration Management</name>
  <description>This package contains Microsoft Azure SDK for Workload Orchestration Management SDK. For documentation on how to use this package, please see https://aka.ms/azsdk/java/mgmt. Microsoft.Edge Resource Provider management API. Package api-version 2025-06-01.</description>
  <url>https://github.com/Azure/azure-sdk-for-java</url>

  <licenses>
    <license>
      <name>The MIT License (MIT)</name>
      <url>http://opensource.org/licenses/MIT</url>
      <distribution>repo</distribution>
    </license>
  </licenses>

  <scm>
    <url>https://github.com/Azure/azure-sdk-for-java</url>
    <connection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</connection>
    <developerConnection>scm:git:git@github.com:Azure/azure-sdk-for-java.git</developerConnection>
    <tag>HEAD</tag>
  </scm>
  <developers>
    <developer>
      <id>microsoft</id>
      <name>Microsoft</name>
    </developer>
  </developers>
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <jacoco.min.linecoverage>0</jacoco.min.linecoverage>
    <jacoco.min.branchcoverage>0</jacoco.min.branchcoverage>
    <revapi.skip>true</revapi.skip>
  </properties>
  <dependencies>
    <dependency>
      <groupId>com.azure</groupId>
      <artifactId>azure-core</artifactId>
      <version>1.56.0</version> <!-- {x-version-update;com.azure:azure-core;dependency} -->
    </dependency>
    <dependency>
      <groupId>com.azure</groupId>
      <artifactId>azure-core-management</artifactId>
      <version>1.19.0</version> <!-- {x-version-update;com.azure:azure-core-management;dependency} -->
    </dependency>
    <dependency>
      <groupId>com.azure</groupId>
      <artifactId>azure-core-test</artifactId>
      <version>1.27.0-beta.11</version> <!-- {x-version-update;com.azure:azure-core-test;dependency} -->
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>com.azure</groupId>
      <artifactId>azure-identity</artifactId>
      <version>1.17.0</version> <!-- {x-version-update;com.azure:azure-identity;dependency} -->
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>



================================================
FILE: azure-resourcemanager-workloadorchestration/SAMPLE.md
================================================
# Code snippets and samples


## ConfigTemplateVersions

- [Get](#configtemplateversions_get)
- [ListByConfigTemplate](#configtemplateversions_listbyconfigtemplate)

## ConfigTemplates

- [CreateOrUpdate](#configtemplates_createorupdate)
- [CreateVersion](#configtemplates_createversion)
- [Delete](#configtemplates_delete)
- [GetByResourceGroup](#configtemplates_getbyresourcegroup)
- [List](#configtemplates_list)
- [ListByResourceGroup](#configtemplates_listbyresourcegroup)
- [RemoveVersion](#configtemplates_removeversion)
- [Update](#configtemplates_update)

## Contexts

- [CreateOrUpdate](#contexts_createorupdate)
- [Delete](#contexts_delete)
- [GetByResourceGroup](#contexts_getbyresourcegroup)
- [List](#contexts_list)
- [ListByResourceGroup](#contexts_listbyresourcegroup)
- [Update](#contexts_update)

## Diagnostics

- [CreateOrUpdate](#diagnostics_createorupdate)
- [Delete](#diagnostics_delete)
- [GetByResourceGroup](#diagnostics_getbyresourcegroup)
- [List](#diagnostics_list)
- [ListByResourceGroup](#diagnostics_listbyresourcegroup)
- [Update](#diagnostics_update)

## DynamicSchemaVersions

- [CreateOrUpdate](#dynamicschemaversions_createorupdate)
- [Delete](#dynamicschemaversions_delete)
- [Get](#dynamicschemaversions_get)
- [ListByDynamicSchema](#dynamicschemaversions_listbydynamicschema)
- [Update](#dynamicschemaversions_update)

## DynamicSchemas

- [CreateOrUpdate](#dynamicschemas_createorupdate)
- [Delete](#dynamicschemas_delete)
- [Get](#dynamicschemas_get)
- [ListBySchema](#dynamicschemas_listbyschema)
- [Update](#dynamicschemas_update)

## Executions

- [CreateOrUpdate](#executions_createorupdate)
- [Delete](#executions_delete)
- [Get](#executions_get)
- [ListByWorkflowVersion](#executions_listbyworkflowversion)
- [Update](#executions_update)

## InstanceHistories

- [Get](#instancehistories_get)
- [ListByInstance](#instancehistories_listbyinstance)

## Instances

- [CreateOrUpdate](#instances_createorupdate)
- [Delete](#instances_delete)
- [Get](#instances_get)
- [ListBySolution](#instances_listbysolution)
- [Update](#instances_update)

## Jobs

- [Get](#jobs_get)
- [ListByTarget](#jobs_listbytarget)

## SchemaReferences

- [Get](#schemareferences_get)
- [ListByResourceGroup](#schemareferences_listbyresourcegroup)

## SchemaVersions

- [CreateOrUpdate](#schemaversions_createorupdate)
- [Delete](#schemaversions_delete)
- [Get](#schemaversions_get)
- [ListBySchema](#schemaversions_listbyschema)
- [Update](#schemaversions_update)

## Schemas

- [CreateOrUpdate](#schemas_createorupdate)
- [CreateVersion](#schemas_createversion)
- [Delete](#schemas_delete)
- [GetByResourceGroup](#schemas_getbyresourcegroup)
- [List](#schemas_list)
- [ListByResourceGroup](#schemas_listbyresourcegroup)
- [RemoveVersion](#schemas_removeversion)
- [Update](#schemas_update)

## SiteReferences

- [CreateOrUpdate](#sitereferences_createorupdate)
- [Delete](#sitereferences_delete)
- [Get](#sitereferences_get)
- [ListByContext](#sitereferences_listbycontext)
- [Update](#sitereferences_update)

## SolutionTemplateVersions

- [BulkDeploySolution](#solutiontemplateversions_bulkdeploysolution)
- [BulkPublishSolution](#solutiontemplateversions_bulkpublishsolution)
- [Get](#solutiontemplateversions_get)
- [ListBySolutionTemplate](#solutiontemplateversions_listbysolutiontemplate)

## SolutionTemplates

- [CreateOrUpdate](#solutiontemplates_createorupdate)
- [CreateVersion](#solutiontemplates_createversion)
- [Delete](#solutiontemplates_delete)
- [GetByResourceGroup](#solutiontemplates_getbyresourcegroup)
- [List](#solutiontemplates_list)
- [ListByResourceGroup](#solutiontemplates_listbyresourcegroup)
- [RemoveVersion](#solutiontemplates_removeversion)
- [Update](#solutiontemplates_update)

## SolutionVersions

- [CreateOrUpdate](#solutionversions_createorupdate)
- [Delete](#solutionversions_delete)
- [Get](#solutionversions_get)
- [ListBySolution](#solutionversions_listbysolution)
- [Update](#solutionversions_update)

## Solutions

- [CreateOrUpdate](#solutions_createorupdate)
- [Delete](#solutions_delete)
- [Get](#solutions_get)
- [ListByTarget](#solutions_listbytarget)
- [Update](#solutions_update)

## Targets

- [CreateOrUpdate](#targets_createorupdate)
- [Delete](#targets_delete)
- [GetByResourceGroup](#targets_getbyresourcegroup)
- [InstallSolution](#targets_installsolution)
- [List](#targets_list)
- [ListByResourceGroup](#targets_listbyresourcegroup)
- [PublishSolutionVersion](#targets_publishsolutionversion)
- [RemoveRevision](#targets_removerevision)
- [ResolveConfiguration](#targets_resolveconfiguration)
- [ReviewSolutionVersion](#targets_reviewsolutionversion)
- [UninstallSolution](#targets_uninstallsolution)
- [Update](#targets_update)
- [UpdateExternalValidationStatus](#targets_updateexternalvalidationstatus)

## WorkflowVersions

- [CreateOrUpdate](#workflowversions_createorupdate)
- [Delete](#workflowversions_delete)
- [Get](#workflowversions_get)
- [ListByWorkflow](#workflowversions_listbyworkflow)
- [Update](#workflowversions_update)

## Workflows

- [CreateOrUpdate](#workflows_createorupdate)
- [Delete](#workflows_delete)
- [Get](#workflows_get)
- [ListByContext](#workflows_listbycontext)
- [Update](#workflows_update)
### ConfigTemplateVersions_Get

```java
/**
 * Samples for ConfigTemplateVersions Get.
 */
public final class ConfigTemplateVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplateVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplateVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplateVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplateVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}
```

### ConfigTemplateVersions_ListByConfigTemplate

```java
/**
 * Samples for ConfigTemplateVersions ListByConfigTemplate.
 */
public final class ConfigTemplateVersionsListByConfigTemplateSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplateVersions_ListByConfigTemplate_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplateVersions_ListByConfigTemplate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplateVersionsListByConfigTemplateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplateVersions()
            .listByConfigTemplate("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### ConfigTemplates_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for ConfigTemplates CreateOrUpdate.
 */
public final class ConfigTemplatesCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates()
            .define("testname")
            .withRegion("egqjo")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key6936", "fakeTokenPlaceholder"))
            .withProperties(new ConfigTemplateProperties().withDescription("ccdyggozwmhyvemlcwlsnhijwg"))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### ConfigTemplates_CreateVersion

```java
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;

/**
 * Samples for ConfigTemplates CreateVersion.
 */
public final class ConfigTemplatesCreateVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_CreateVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_CreateVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesCreateVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates()
            .createVersion("rgconfigurationmanager", "testname",
                new ConfigTemplateVersionWithUpdateTypeInner().withUpdateType(UpdateType.MAJOR)
                    .withVersion("1.0.0")
                    .withConfigTemplateVersion(new ConfigTemplateVersionInner()
                        .withProperties(new ConfigTemplateVersionProperties().withConfigurations("rgricnhvcbqykc"))),
                com.azure.core.util.Context.NONE);
    }
}
```

### ConfigTemplates_Delete

```java
/**
 * Samples for ConfigTemplates Delete.
 */
public final class ConfigTemplatesDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### ConfigTemplates_GetByResourceGroup

```java
/**
 * Samples for ConfigTemplates GetByResourceGroup.
 */
public final class ConfigTemplatesGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### ConfigTemplates_List

```java
/**
 * Samples for ConfigTemplates List.
 */
public final class ConfigTemplatesListSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates().list(com.azure.core.util.Context.NONE);
    }
}
```

### ConfigTemplates_ListByResourceGroup

```java
/**
 * Samples for ConfigTemplates ListByResourceGroup.
 */
public final class ConfigTemplatesListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}
```

### ConfigTemplates_RemoveVersion

```java
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

/**
 * Samples for ConfigTemplates RemoveVersion.
 */
public final class ConfigTemplatesRemoveVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_RemoveVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_RemoveVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesRemoveVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates()
            .removeVersionWithResponse("rgconfigurationmanager", "testname",
                new VersionParameter().withVersion("ghtvdzgmzncaifrnuumg"), com.azure.core.util.Context.NONE);
    }
}
```

### ConfigTemplates_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplate;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for ConfigTemplates Update.
 */
public final class ConfigTemplatesUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        ConfigTemplate resource = manager.configTemplates()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key7701", "fakeTokenPlaceholder"))
            .withProperties(new ConfigTemplateProperties().withDescription("cavjiqnrbzsvedicrixhwnfj"))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Contexts_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.Capability;
import com.azure.resourcemanager.workloadorchestration.models.ContextProperties;
import com.azure.resourcemanager.workloadorchestration.models.Hierarchy;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Contexts CreateOrUpdate.
 */
public final class ContextsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void contextsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts()
            .define("testname")
            .withRegion("pkquwbplcp")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key3046", "fakeTokenPlaceholder"))
            .withProperties(new ContextProperties()
                .withCapabilities(Arrays.asList(new Capability().withName("tpylinjcmlnycfpofpxjtqmt")
                    .withDescription("banbenutsngwytoqh")
                    .withState(ResourceState.ACTIVE)))
                .withHierarchies(Arrays.asList(new Hierarchy().withName("upqe").withDescription("vg"))))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Contexts_Delete

```java
/**
 * Samples for Contexts Delete.
 */
public final class ContextsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        contextsDeleteMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Contexts_GetByResourceGroup

```java
/**
 * Samples for Contexts GetByResourceGroup.
 */
public final class ContextsGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        contextsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Contexts_List

```java
/**
 * Samples for Contexts List.
 */
public final class ContextsListSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void contextsListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts().list(com.azure.core.util.Context.NONE);
    }
}
```

### Contexts_ListByResourceGroup

```java
/**
 * Samples for Contexts ListByResourceGroup.
 */
public final class ContextsListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void contextsListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}
```

### Contexts_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.Capability;
import com.azure.resourcemanager.workloadorchestration.models.ContextModel;
import com.azure.resourcemanager.workloadorchestration.models.ContextProperties;
import com.azure.resourcemanager.workloadorchestration.models.Hierarchy;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Contexts Update.
 */
public final class ContextsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        contextsUpdateMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        ContextModel resource = manager.contexts()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key9545", "fakeTokenPlaceholder"))
            .withProperties(new ContextProperties()
                .withCapabilities(Arrays.asList(new Capability().withName("tpylinjcmlnycfpofpxjtqmt")
                    .withDescription("banbenutsngwytoqh")
                    .withState(ResourceState.ACTIVE)))
                .withHierarchies(Arrays.asList(new Hierarchy().withName("upqe").withDescription("vg"))))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Diagnostics_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Diagnostics CreateOrUpdate.
 */
public final class DiagnosticsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics()
            .define("testname")
            .withRegion("ouwfvnokjvivmjzqpupwrbsmls")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key4304", "fakeTokenPlaceholder"))
            .withProperties(new DiagnosticProperties())
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Diagnostics_Delete

```java
/**
 * Samples for Diagnostics Delete.
 */
public final class DiagnosticsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Diagnostics_GetByResourceGroup

```java
/**
 * Samples for Diagnostics GetByResourceGroup.
 */
public final class DiagnosticsGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        diagnosticsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Diagnostics_List

```java
/**
 * Samples for Diagnostics List.
 */
public final class DiagnosticsListSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics().list(com.azure.core.util.Context.NONE);
    }
}
```

### Diagnostics_ListByResourceGroup

```java
/**
 * Samples for Diagnostics ListByResourceGroup.
 */
public final class DiagnosticsListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}
```

### Diagnostics_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.Diagnostic;
import com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Diagnostics Update.
 */
public final class DiagnosticsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Diagnostic resource = manager.diagnostics()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key1922", "fakeTokenPlaceholder"))
            .withProperties(new DiagnosticProperties())
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### DynamicSchemaVersions_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

/**
 * Samples for DynamicSchemaVersions CreateOrUpdate.
 */
public final class DynamicSchemaVersionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemaVersions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemaVersions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemaVersionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemaVersions()
            .define("1.0.0")
            .withExistingDynamicSchema("rgconfigurationmanager", "testname", "testname")
            .withProperties(new SchemaVersionProperties().withValue("uiaqdwsi"))
            .create();
    }
}
```

### DynamicSchemaVersions_Delete

```java
/**
 * Samples for DynamicSchemaVersions Delete.
 */
public final class DynamicSchemaVersionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemaVersions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemaVersions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemaVersionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemaVersions()
            .delete("rgconfigurationmanager", "testname", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}
```

### DynamicSchemaVersions_Get

```java
/**
 * Samples for DynamicSchemaVersions Get.
 */
public final class DynamicSchemaVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemaVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemaVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemaVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemaVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "1.0.0",
                com.azure.core.util.Context.NONE);
    }
}
```

### DynamicSchemaVersions_ListByDynamicSchema

```java
/**
 * Samples for DynamicSchemaVersions ListByDynamicSchema.
 */
public final class DynamicSchemaVersionsListByDynamicSchemaSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemaVersions_ListByDynamicSchema_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemaVersions_ListByDynamicSchema_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemaVersionsListByDynamicSchemaMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemaVersions()
            .listByDynamicSchema("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### DynamicSchemaVersions_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

/**
 * Samples for DynamicSchemaVersions Update.
 */
public final class DynamicSchemaVersionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemaVersions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemaVersions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemaVersionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        DynamicSchemaVersion resource = manager.dynamicSchemaVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "1.0.0",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SchemaVersionProperties().withValue("muezi")).apply();
    }
}
```

### DynamicSchemas_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties;

/**
 * Samples for DynamicSchemas CreateOrUpdate.
 */
public final class DynamicSchemasCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemas()
            .define("testname")
            .withExistingSchema("rgconfigurationmanager", "testname")
            .withProperties(new DynamicSchemaProperties())
            .create();
    }
}
```

### DynamicSchemas_Delete

```java
/**
 * Samples for DynamicSchemas Delete.
 */
public final class DynamicSchemasDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemas()
            .delete("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### DynamicSchemas_Get

```java
/**
 * Samples for DynamicSchemas Get.
 */
public final class DynamicSchemasGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemas()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### DynamicSchemas_ListBySchema

```java
/**
 * Samples for DynamicSchemas ListBySchema.
 */
public final class DynamicSchemasListBySchemaSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_ListBySchema_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_ListBySchema_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasListBySchemaMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemas().listBySchema("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### DynamicSchemas_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchema;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties;

/**
 * Samples for DynamicSchemas Update.
 */
public final class DynamicSchemasUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        DynamicSchema resource = manager.dynamicSchemas()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new DynamicSchemaProperties()).apply();
    }
}
```

### Executions_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Executions CreateOrUpdate.
 */
public final class ExecutionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_CreateOrUpdate_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsCreateOrUpdateMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.executions()
            .define("abcde")
            .withExistingVersion("rgconfigurationmanager", "abcde", "abcde", "abcde")
            .withProperties(
                new ExecutionProperties().withWorkflowVersionId("souenlqwltljsojdcbpc").withSpecification(mapOf()))
            .withExtendedLocation(new ExtendedLocation().withName("ugf").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Executions_Delete

```java
/**
 * Samples for Executions Delete.
 */
public final class ExecutionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_Delete_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsDeleteMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.executions()
            .delete("rgconfigurationmanager", "abcde", "abcde", "abcde", "abcde", com.azure.core.util.Context.NONE);
    }
}
```

### Executions_Get

```java
/**
 * Samples for Executions Get.
 */
public final class ExecutionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_Get_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsGetMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.executions()
            .getWithResponse("rgconfigurationmanager", "abcde", "abcde", "abcde", "abcde",
                com.azure.core.util.Context.NONE);
    }
}
```

### Executions_ListByWorkflowVersion

```java
/**
 * Samples for Executions ListByWorkflowVersion.
 */
public final class ExecutionsListByWorkflowVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_ListByWorkflowVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_ListByWorkflowVersion_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsListByWorkflowVersionMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.executions()
            .listByWorkflowVersion("rgconfigurationmanager", "abcde", "abcde", "abcde",
                com.azure.core.util.Context.NONE);
    }
}
```

### Executions_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.Execution;
import com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Executions Update.
 */
public final class ExecutionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_Update_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsUpdateMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Execution resource = manager.executions()
            .getWithResponse("rgconfigurationmanager", "abcde", "abcde", "abcde", "abcde",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withProperties(
                new ExecutionProperties().withWorkflowVersionId("xjsxzbfltzvbuvn").withSpecification(mapOf()))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### InstanceHistories_Get

```java
/**
 * Samples for InstanceHistories Get.
 */
public final class InstanceHistoriesGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/InstanceHistories_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: InstanceHistories_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instanceHistoriesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instanceHistories()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}
```

### InstanceHistories_ListByInstance

```java
/**
 * Samples for InstanceHistories ListByInstance.
 */
public final class InstanceHistoriesListByInstanceSamples {
    /*
     * x-ms-original-file: 2025-06-01/InstanceHistories_ListByInstance_MaximumSet_Gen.json
     */
    /**
     * Sample code: InstanceHistories_ListByInstance_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instanceHistoriesListByInstanceMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instanceHistories()
            .listByInstance("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}
```

### Instances_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.InstanceProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;

/**
 * Samples for Instances CreateOrUpdate.
 */
public final class InstancesCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instancesCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instances()
            .define("testname")
            .withExistingSolution("rgconfigurationmanager", "testname", "testname")
            .withProperties(new InstanceProperties().withSolutionVersionId("acpddbkfclsgxg")
                .withTargetId("eguutiftuxrsavvckjrv")
                .withActiveState(ActiveState.ACTIVE)
                .withReconciliationPolicy(new ReconciliationPolicyProperties().withState(ReconciliationState.INACTIVE)
                    .withInterval("szucgzdbydcowvhprhx"))
                .withSolutionScope("testname"))
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }
}
```

### Instances_Delete

```java
/**
 * Samples for Instances Delete.
 */
public final class InstancesDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instancesDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instances()
            .delete("rgconfigurationmanager", "testname", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Instances_Get

```java
/**
 * Samples for Instances Get.
 */
public final class InstancesGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        instancesGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instances()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}
```

### Instances_ListBySolution

```java
/**
 * Samples for Instances ListBySolution.
 */
public final class InstancesListBySolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_ListBySolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_ListBySolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instancesListBySolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instances()
            .listBySolution("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Instances_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.Instance;
import com.azure.resourcemanager.workloadorchestration.models.InstanceProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;

/**
 * Samples for Instances Update.
 */
public final class InstancesUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instancesUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Instance resource = manager.instances()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withProperties(new InstanceProperties().withSolutionVersionId("vrpzlamkvanqibtjarpxit")
                .withTargetId("tqkdvc")
                .withActiveState(ActiveState.ACTIVE)
                .withReconciliationPolicy(new ReconciliationPolicyProperties().withState(ReconciliationState.INACTIVE)
                    .withInterval("cmzlrjwnlshnkgv"))
                .withSolutionScope("testname"))
            .apply();
    }
}
```

### Jobs_Get

```java
/**
 * Samples for Jobs Get.
 */
public final class JobsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Jobs_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Jobs_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        jobsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.jobs().getWithResponse("gt", "jobsName", com.azure.core.util.Context.NONE);
    }
}
```

### Jobs_ListByTarget

```java
/**
 * Samples for Jobs ListByTarget.
 */
public final class JobsListByTargetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Jobs_ListByTarget_MaximumSet_Gen.json
     */
    /**
     * Sample code: Jobs_ListByTarget_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void jobsListByTargetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.jobs().listByTarget("gt", com.azure.core.util.Context.NONE);
    }
}
```

### SchemaReferences_Get

```java
/**
 * Samples for SchemaReferences Get.
 */
public final class SchemaReferencesGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaReferences_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaReferences_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaReferencesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaReferences().getWithResponse("jdvtghygpz", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SchemaReferences_ListByResourceGroup

```java
/**
 * Samples for SchemaReferences ListByResourceGroup.
 */
public final class SchemaReferencesListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaReferences_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaReferences_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaReferencesListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaReferences().listByResourceGroup("jdvtghygpz", com.azure.core.util.Context.NONE);
    }
}
```

### SchemaVersions_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

/**
 * Samples for SchemaVersions CreateOrUpdate.
 */
public final class SchemaVersionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaVersions()
            .define("1.0.0")
            .withExistingSchema("rgconfigurationmanager", "testname")
            .withProperties(new SchemaVersionProperties().withValue("uiaqdwsi"))
            .create();
    }
}
```

### SchemaVersions_Delete

```java
/**
 * Samples for SchemaVersions Delete.
 */
public final class SchemaVersionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaVersions()
            .delete("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}
```

### SchemaVersions_Get

```java
/**
 * Samples for SchemaVersions Get.
 */
public final class SchemaVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}
```

### SchemaVersions_ListBySchema

```java
/**
 * Samples for SchemaVersions ListBySchema.
 */
public final class SchemaVersionsListBySchemaSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_ListBySchema_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_ListBySchema_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsListBySchemaMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaVersions().listBySchema("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SchemaVersions_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

/**
 * Samples for SchemaVersions Update.
 */
public final class SchemaVersionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        SchemaVersion resource = manager.schemaVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SchemaVersionProperties().withValue("muezi")).apply();
    }
}
```

### Schemas_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.SchemaProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Schemas CreateOrUpdate.
 */
public final class SchemasCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas()
            .define("testname")
            .withRegion("alvi")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key7017", "fakeTokenPlaceholder"))
            .withProperties(new SchemaProperties())
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Schemas_CreateVersion

```java
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;

/**
 * Samples for Schemas CreateVersion.
 */
public final class SchemasCreateVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_CreateVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_CreateVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasCreateVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas()
            .createVersion("rgconfigurationmanager", "testname",
                new SchemaVersionWithUpdateTypeInner().withUpdateType(UpdateType.MAJOR)
                    .withVersion("1.0.0")
                    .withSchemaVersion(
                        new SchemaVersionInner().withProperties(new SchemaVersionProperties().withValue("uiaqdwsi"))),
                com.azure.core.util.Context.NONE);
    }
}
```

### Schemas_Delete

```java
/**
 * Samples for Schemas Delete.
 */
public final class SchemasDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        schemasDeleteMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Schemas_GetByResourceGroup

```java
/**
 * Samples for Schemas GetByResourceGroup.
 */
public final class SchemasGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        schemasGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Schemas_List

```java
/**
 * Samples for Schemas List.
 */
public final class SchemasListSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas().list(com.azure.core.util.Context.NONE);
    }
}
```

### Schemas_ListByResourceGroup

```java
/**
 * Samples for Schemas ListByResourceGroup.
 */
public final class SchemasListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}
```

### Schemas_RemoveVersion

```java
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

/**
 * Samples for Schemas RemoveVersion.
 */
public final class SchemasRemoveVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_RemoveVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_RemoveVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasRemoveVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas()
            .removeVersionWithResponse("rgconfigurationmanager", "testname",
                new VersionParameter().withVersion("ghtvdzgmzncaifrnuumg"), com.azure.core.util.Context.NONE);
    }
}
```

### Schemas_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.Schema;
import com.azure.resourcemanager.workloadorchestration.models.SchemaProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Schemas Update.
 */
public final class SchemasUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        schemasUpdateMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Schema resource = manager.schemas()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key6760", "fakeTokenPlaceholder"))
            .withProperties(new SchemaProperties())
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### SiteReferences_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties;

/**
 * Samples for SiteReferences CreateOrUpdate.
 */
public final class SiteReferencesCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.siteReferences()
            .define("testname")
            .withExistingContext("rgconfigurationmanager", "testname")
            .withProperties(new SiteReferenceProperties().withSiteId("xxjpxdcaumewwgpbwzkcrgrcw"))
            .create();
    }
}
```

### SiteReferences_Delete

```java
/**
 * Samples for SiteReferences Delete.
 */
public final class SiteReferencesDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.siteReferences()
            .delete("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SiteReferences_Get

```java
/**
 * Samples for SiteReferences Get.
 */
public final class SiteReferencesGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.siteReferences()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SiteReferences_ListByContext

```java
/**
 * Samples for SiteReferences ListByContext.
 */
public final class SiteReferencesListByContextSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_ListByContext_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_ListByContext_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesListByContextMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.siteReferences().listByContext("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SiteReferences_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.SiteReference;
import com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties;

/**
 * Samples for SiteReferences Update.
 */
public final class SiteReferencesUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        SiteReference resource = manager.siteReferences()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SiteReferenceProperties().withSiteId("nwiuyaro")).apply();
    }
}
```

### SolutionTemplateVersions_BulkDeploySolution

```java
import com.azure.resourcemanager.workloadorchestration.models.BulkDeploySolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.BulkDeployTargetDetails;
import java.util.Arrays;

/**
 * Samples for SolutionTemplateVersions BulkDeploySolution.
 */
public final class SolutionTemplateVersionsBulkDeploySolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplateVersions_BulkDeploySolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplateVersions_BulkDeploySolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplateVersionsBulkDeploySolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplateVersions()
            .bulkDeploySolution("rgconfigurationmanager", "testname", "1.0.0", new BulkDeploySolutionParameter()
                .withTargets(Arrays.asList(new BulkDeployTargetDetails().withSolutionVersionId(
                    "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Edge/Targets/target/Solutions/solution/Versions/solution-1.0.0.1"))),
                com.azure.core.util.Context.NONE);
    }
}
```

### SolutionTemplateVersions_BulkPublishSolution

```java
import com.azure.resourcemanager.workloadorchestration.models.BulkPublishSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.BulkPublishTargetDetails;
import com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter;
import java.util.Arrays;

/**
 * Samples for SolutionTemplateVersions BulkPublishSolution.
 */
public final class SolutionTemplateVersionsBulkPublishSolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplateVersions_BulkPublishSolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplateVersions_BulkPublishSolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplateVersionsBulkPublishSolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplateVersions()
            .bulkPublishSolution("rgconfigurationmanager", "testname", "1.0.0", new BulkPublishSolutionParameter()
                .withTargets(Arrays.asList(new BulkPublishTargetDetails().withTargetId(
                    "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Edge/Targets/target")
                    .withSolutionInstanceName("test-instance")))
                .withSolutionInstanceName("test-instance")
                .withSolutionDependencies(Arrays.asList(new SolutionDependencyParameter().withSolutionVersionId(
                    "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Edge/Targets/target/Solutions/solution/Versions/solution-1.0.0.1")
                    .withSolutionTemplateId(
                        "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Edge/SolutionTemplates/st")
                    .withSolutionTemplateVersion("1.0.0")
                    .withSolutionInstanceName("test-instance")
                    .withTargetId(
                        "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Edge/Targets/target")
                    .withDependencies(Arrays.asList()))),
                com.azure.core.util.Context.NONE);
    }
}
```

### SolutionTemplateVersions_Get

```java
/**
 * Samples for SolutionTemplateVersions Get.
 */
public final class SolutionTemplateVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplateVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplateVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplateVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplateVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}
```

### SolutionTemplateVersions_ListBySolutionTemplate

```java
/**
 * Samples for SolutionTemplateVersions ListBySolutionTemplate.
 */
public final class SolutionTemplateVersionsListBySolutionTemplateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplateVersions_ListBySolutionTemplate_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplateVersions_ListBySolutionTemplate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplateVersionsListBySolutionTemplateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplateVersions()
            .listBySolutionTemplate("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SolutionTemplates_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionTemplates CreateOrUpdate.
 */
public final class SolutionTemplatesCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates()
            .define("testname")
            .withRegion("zheaaqvadewftnctxzpinrgeproqs")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key5091", "fakeTokenPlaceholder"))
            .withProperties(new SolutionTemplateProperties().withDescription("psrftehgzngcdlccivhjmwsmiz")
                .withCapabilities(Arrays.asList("dfoyxbbknrhvlunhmuyyt"))
                .withState(ResourceState.ACTIVE)
                .withEnableExternalValidation(true))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### SolutionTemplates_CreateVersion

```java
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.OrchestratorType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionTemplates CreateVersion.
 */
public final class SolutionTemplatesCreateVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_CreateVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_CreateVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesCreateVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates()
            .createVersion("rgconfigurationmanager", "testname",
                new SolutionTemplateVersionWithUpdateTypeInner().withUpdateType(UpdateType.MAJOR)
                    .withVersion("1.0.0")
                    .withSolutionTemplateVersion(new SolutionTemplateVersionInner().withProperties(
                        new SolutionTemplateVersionProperties().withConfigurations("ofqcsavwmeuwmvtjnqpoybtjvkmrlh")
                            .withSpecification(mapOf())
                            .withOrchestratorType(OrchestratorType.TO))),
                com.azure.core.util.Context.NONE);
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### SolutionTemplates_Delete

```java
/**
 * Samples for SolutionTemplates Delete.
 */
public final class SolutionTemplatesDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SolutionTemplates_GetByResourceGroup

```java
/**
 * Samples for SolutionTemplates GetByResourceGroup.
 */
public final class SolutionTemplatesGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SolutionTemplates_List

```java
/**
 * Samples for SolutionTemplates List.
 */
public final class SolutionTemplatesListSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates().list(com.azure.core.util.Context.NONE);
    }
}
```

### SolutionTemplates_ListByResourceGroup

```java
/**
 * Samples for SolutionTemplates ListByResourceGroup.
 */
public final class SolutionTemplatesListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}
```

### SolutionTemplates_RemoveVersion

```java
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

/**
 * Samples for SolutionTemplates RemoveVersion.
 */
public final class SolutionTemplatesRemoveVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_RemoveVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_RemoveVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesRemoveVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates()
            .removeVersion("rgconfigurationmanager", "testname",
                new VersionParameter().withVersion("ghtvdzgmzncaifrnuumg"), com.azure.core.util.Context.NONE);
    }
}
```

### SolutionTemplates_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplate;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionTemplates Update.
 */
public final class SolutionTemplatesUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        SolutionTemplate resource = manager.solutionTemplates()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key8772", "fakeTokenPlaceholder"))
            .withProperties(new SolutionTemplateProperties().withDescription("onqlteg")
                .withCapabilities(Arrays.asList("relsv"))
                .withState(ResourceState.ACTIVE)
                .withEnableExternalValidation(true))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### SolutionVersions_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionVersions CreateOrUpdate.
 */
public final class SolutionVersionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionVersions()
            .define("testname")
            .withExistingSolution("rgconfigurationmanager", "testname", "testname")
            .withProperties(new SolutionVersionProperties().withSpecification(mapOf()))
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### SolutionVersions_Delete

```java
/**
 * Samples for SolutionVersions Delete.
 */
public final class SolutionVersionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionVersions()
            .delete("rgconfigurationmanager", "testname", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SolutionVersions_Get

```java
/**
 * Samples for SolutionVersions Get.
 */
public final class SolutionVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}
```

### SolutionVersions_ListBySolution

```java
/**
 * Samples for SolutionVersions ListBySolution.
 */
public final class SolutionVersionsListBySolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_ListBySolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_ListBySolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsListBySolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionVersions()
            .listBySolution("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### SolutionVersions_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionVersions Update.
 */
public final class SolutionVersionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        SolutionVersion resource = manager.solutionVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SolutionVersionProperties().withSpecification(mapOf())).apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Solutions_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionProperties;

/**
 * Samples for Solutions CreateOrUpdate.
 */
public final class SolutionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutions()
            .define("testname")
            .withExistingTarget("rgconfigurationmanager", "testname")
            .withProperties(new SolutionProperties())
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }
}
```

### Solutions_Delete

```java
/**
 * Samples for Solutions Delete.
 */
public final class SolutionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutions().delete("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Solutions_Get

```java
/**
 * Samples for Solutions Get.
 */
public final class SolutionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        solutionsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Solutions_ListByTarget

```java
/**
 * Samples for Solutions ListByTarget.
 */
public final class SolutionsListByTargetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_ListByTarget_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_ListByTarget_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionsListByTargetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutions().listByTarget("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Solutions_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.Solution;
import com.azure.resourcemanager.workloadorchestration.models.SolutionProperties;

/**
 * Samples for Solutions Update.
 */
public final class SolutionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Solution resource = manager.solutions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SolutionProperties()).apply();
    }
}
```

### Targets_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.TargetProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Targets CreateOrUpdate.
 */
public final class TargetsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .define("testname")
            .withRegion("kckloegmwsjgwtcl")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key612", "fakeTokenPlaceholder"))
            .withProperties(new TargetProperties().withDescription("riabrxtvhlmizyhffdpjeyhvw")
                .withDisplayName("qjlbshhqzfmwxvvynibkoi")
                .withContextId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                .withTargetSpecification(mapOf())
                .withCapabilities(Arrays.asList("grjapghdidoao"))
                .withHierarchyLevel("octqptfirejhjfavlnfqeiikqx")
                .withSolutionScope("testname")
                .withState(ResourceState.ACTIVE))
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Targets_Delete

```java
/**
 * Samples for Targets Delete.
 */
public final class TargetsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        targetsDeleteMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets().delete("rgconfigurationmanager", "testname", true, com.azure.core.util.Context.NONE);
    }
}
```

### Targets_GetByResourceGroup

```java
/**
 * Samples for Targets GetByResourceGroup.
 */
public final class TargetsGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        targetsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Targets_InstallSolution

```java
import com.azure.resourcemanager.workloadorchestration.models.InstallSolutionParameter;

/**
 * Samples for Targets InstallSolution.
 */
public final class TargetsInstallSolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_InstallSolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_InstallSolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsInstallSolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .installSolution("rgconfigurationmanager", "testname", new InstallSolutionParameter().withSolutionVersionId(
                "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"),
                com.azure.core.util.Context.NONE);
    }
}
```

### Targets_List

```java
/**
 * Samples for Targets List.
 */
public final class TargetsListSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets().list(com.azure.core.util.Context.NONE);
    }
}
```

### Targets_ListByResourceGroup

```java
/**
 * Samples for Targets ListByResourceGroup.
 */
public final class TargetsListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}
```

### Targets_PublishSolutionVersion

```java
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionParameter;

/**
 * Samples for Targets PublishSolutionVersion.
 */
public final class TargetsPublishSolutionVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_PublishSolutionVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_PublishSolutionVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsPublishSolutionVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .publishSolutionVersion("rgconfigurationmanager", "testname",
                new SolutionVersionParameter().withSolutionVersionId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"),
                com.azure.core.util.Context.NONE);
    }
}
```

### Targets_RemoveRevision

```java
import com.azure.resourcemanager.workloadorchestration.models.RemoveRevisionParameter;

/**
 * Samples for Targets RemoveRevision.
 */
public final class TargetsRemoveRevisionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_RemoveRevision_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_RemoveRevision_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsRemoveRevisionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .removeRevision("rgconfigurationmanager", "testname", new RemoveRevisionParameter().withSolutionTemplateId(
                "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                .withSolutionVersion("tomwmqybqomwkfaeukjneva"), com.azure.core.util.Context.NONE);
    }
}
```

### Targets_ResolveConfiguration

```java
import com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import java.util.Arrays;

/**
 * Samples for Targets ResolveConfiguration.
 */
public final class TargetsResolveConfigurationSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_ResolveConfiguration_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_ResolveConfiguration_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsResolveConfigurationMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .resolveConfiguration("rgconfigurationmanager", "testname",
                new SolutionTemplateParameter().withSolutionTemplateVersionId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}/{resourceType}/{resourceName}")
                    .withSolutionInstanceName("testname")
                    .withSolutionDependencies(
                        Arrays.asList(new SolutionDependencyParameter().withSolutionVersionId("cydzqntmjlqtksbavjwteru")
                            .withSolutionTemplateId("liqauthxnscodbiwktwfwrrsg")
                            .withSolutionTemplateVersion("gordjasyxxrj")
                            .withSolutionInstanceName("testname")
                            .withTargetId("steadvphxtyhjokqicrtg")
                            .withDependencies(Arrays.asList()))),
                com.azure.core.util.Context.NONE);
    }
}
```

### Targets_ReviewSolutionVersion

```java
import com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import java.util.Arrays;

/**
 * Samples for Targets ReviewSolutionVersion.
 */
public final class TargetsReviewSolutionVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_ReviewSolutionVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_ReviewSolutionVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsReviewSolutionVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .reviewSolutionVersion("rgconfigurationmanager", "testname",
                new SolutionTemplateParameter().withSolutionTemplateVersionId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}/{resourceType}/{resourceName}")
                    .withSolutionInstanceName("testname")
                    .withSolutionDependencies(
                        Arrays.asList(new SolutionDependencyParameter().withSolutionVersionId("cydzqntmjlqtksbavjwteru")
                            .withSolutionTemplateId("liqauthxnscodbiwktwfwrrsg")
                            .withSolutionTemplateVersion("gordjasyxxrj")
                            .withSolutionInstanceName("testname")
                            .withTargetId("steadvphxtyhjokqicrtg")
                            .withDependencies(Arrays.asList()))),
                com.azure.core.util.Context.NONE);
    }
}
```

### Targets_UninstallSolution

```java
import com.azure.resourcemanager.workloadorchestration.models.UninstallSolutionParameter;

/**
 * Samples for Targets UninstallSolution.
 */
public final class TargetsUninstallSolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_UninstallSolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_UninstallSolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsUninstallSolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .uninstallSolution("rgconfigurationmanager", "testname",
                new UninstallSolutionParameter().withSolutionTemplateId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                    .withSolutionInstanceName("lzihiumrcxbolmkqktvtuqyhg"),
                com.azure.core.util.Context.NONE);
    }
}
```

### Targets_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.Target;
import com.azure.resourcemanager.workloadorchestration.models.TargetProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Targets Update.
 */
public final class TargetsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        targetsUpdateMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Target resource = manager.targets()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key8026", "fakeTokenPlaceholder"))
            .withProperties(new TargetProperties().withDescription("yhnhdpznncdvncmnvoeohqjx")
                .withDisplayName("pguujtzjjvixgjitugybrefp")
                .withContextId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                .withTargetSpecification(mapOf())
                .withCapabilities(Arrays.asList("dasqhyxfakivfzqb"))
                .withHierarchyLevel("hfyntwxetgsmnucbjvvphtyxu")
                .withSolutionScope("testname")
                .withState(ResourceState.ACTIVE))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Targets_UpdateExternalValidationStatus

```java
import com.azure.core.management.exception.ManagementError;
import com.azure.resourcemanager.workloadorchestration.models.UpdateExternalValidationStatusParameter;
import com.azure.resourcemanager.workloadorchestration.models.ValidationStatus;

/**
 * Samples for Targets UpdateExternalValidationStatus.
 */
public final class TargetsUpdateExternalValidationStatusSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_UpdateExternalValidationStatus_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_UpdateExternalValidationStatus_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsUpdateExternalValidationStatusMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .updateExternalValidationStatus("rgconfigurationmanager", "testname",
                new UpdateExternalValidationStatusParameter().withSolutionVersionId("shntcsuwlmpehmuqkrbf")
                    .withErrorDetails(new ManagementError())
                    .withExternalValidationId("ivsjzwy")
                    .withValidationStatus(ValidationStatus.VALID),
                com.azure.core.util.Context.NONE);
    }
}
```

### WorkflowVersions_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.StageSpec;
import com.azure.resourcemanager.workloadorchestration.models.TaskOption;
import com.azure.resourcemanager.workloadorchestration.models.TaskSpec;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for WorkflowVersions CreateOrUpdate.
 */
public final class WorkflowVersionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflowVersions()
            .define("testname")
            .withExistingWorkflow("rgconfigurationmanager", "testname", "testname")
            .withProperties(new WorkflowVersionProperties().withStageSpec(Arrays.asList(new StageSpec()
                .withName("amrbjd")
                .withSpecification(mapOf())
                .withTasks(Arrays.asList(new TaskSpec().withName("xxmeyvmgydbcwxqwjhadjxjod")
                    .withTargetId(
                        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                    .withSpecification(mapOf())))
                .withTaskOption(
                    new TaskOption().withConcurrency(3)
                        .withErrorAction(new ErrorAction().withMode(ErrorActionMode.STOP_ON_ANY_FAILURE)
                            .withMaxToleratedFailures(0)))))
                .withSpecification(mapOf()))
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### WorkflowVersions_Delete

```java
/**
 * Samples for WorkflowVersions Delete.
 */
public final class WorkflowVersionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflowVersions()
            .delete("rgconfigurationmanager", "testname", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### WorkflowVersions_Get

```java
/**
 * Samples for WorkflowVersions Get.
 */
public final class WorkflowVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflowVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}
```

### WorkflowVersions_ListByWorkflow

```java
/**
 * Samples for WorkflowVersions ListByWorkflow.
 */
public final class WorkflowVersionsListByWorkflowSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_ListByWorkflow_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_ListByWorkflow_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsListByWorkflowMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflowVersions()
            .listByWorkflow("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### WorkflowVersions_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode;
import com.azure.resourcemanager.workloadorchestration.models.StageSpec;
import com.azure.resourcemanager.workloadorchestration.models.TaskOption;
import com.azure.resourcemanager.workloadorchestration.models.TaskSpec;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersion;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for WorkflowVersions Update.
 */
public final class WorkflowVersionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        WorkflowVersion resource = manager.workflowVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withProperties(new WorkflowVersionProperties().withStageSpec(Arrays.asList(new StageSpec()
                .withName("amrbjd")
                .withSpecification(mapOf())
                .withTasks(Arrays.asList(new TaskSpec().withName("xxmeyvmgydbcwxqwjhadjxjod")
                    .withTargetId(
                        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                    .withSpecification(mapOf())))
                .withTaskOption(
                    new TaskOption().withConcurrency(3)
                        .withErrorAction(new ErrorAction().withMode(ErrorActionMode.STOP_ON_ANY_FAILURE)
                            .withMaxToleratedFailures(0)))))
                .withSpecification(mapOf()))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}
```

### Workflows_CreateOrUpdate

```java
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties;

/**
 * Samples for Workflows CreateOrUpdate.
 */
public final class WorkflowsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflows()
            .define("testname")
            .withExistingContext("rgconfigurationmanager", "testname")
            .withProperties(new WorkflowProperties())
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }
}
```

### Workflows_Delete

```java
/**
 * Samples for Workflows Delete.
 */
public final class WorkflowsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflows().delete("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Workflows_Get

```java
/**
 * Samples for Workflows Get.
 */
public final class WorkflowsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        workflowsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflows()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Workflows_ListByContext

```java
/**
 * Samples for Workflows ListByContext.
 */
public final class WorkflowsListByContextSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_ListByContext_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_ListByContext_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowsListByContextMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflows().listByContext("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}
```

### Workflows_Update

```java
import com.azure.resourcemanager.workloadorchestration.models.Workflow;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties;

/**
 * Samples for Workflows Update.
 */
public final class WorkflowsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Workflow resource = manager.workflows()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new WorkflowProperties()).apply();
    }
}
```




================================================
FILE: azure-resourcemanager-workloadorchestration/tsp-location.yaml
================================================
directory: specification/edge/Microsoft.Edge.ConfigurationManager.Management
commit: 9a3b5a29ea3c4c7253b77328624bed9cac106055
repo: Azure/azure-rest-api-specs
additionalDirectories: 



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/module-info.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

module com.azure.resourcemanager.workloadorchestration {
    requires transitive com.azure.core.management;

    exports com.azure.resourcemanager.workloadorchestration;
    exports com.azure.resourcemanager.workloadorchestration.fluent;
    exports com.azure.resourcemanager.workloadorchestration.fluent.models;
    exports com.azure.resourcemanager.workloadorchestration.models;

    opens com.azure.resourcemanager.workloadorchestration.fluent.models to com.azure.core;
    opens com.azure.resourcemanager.workloadorchestration.models to com.azure.core;
    opens com.azure.resourcemanager.workloadorchestration.implementation.models to com.azure.core;
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/package-info.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

/**
 * Package containing the classes for WorkloadOrchestration.
 * Microsoft.Edge Resource Provider management API.
 */
package com.azure.resourcemanager.workloadorchestration;



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/WorkloadOrchestrationManager.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration;

import com.azure.core.credential.TokenCredential;
import com.azure.core.http.HttpClient;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.HttpPipelinePosition;
import com.azure.core.http.policy.AddDatePolicy;
import com.azure.core.http.policy.AddHeadersFromContextPolicy;
import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;
import com.azure.core.http.policy.HttpLogOptions;
import com.azure.core.http.policy.HttpLoggingPolicy;
import com.azure.core.http.policy.HttpPipelinePolicy;
import com.azure.core.http.policy.HttpPolicyProviders;
import com.azure.core.http.policy.RequestIdPolicy;
import com.azure.core.http.policy.RetryOptions;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.util.Configuration;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.WorkloadOrchestrationManagementClient;
import com.azure.resourcemanager.workloadorchestration.implementation.ConfigTemplateVersionsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.ConfigTemplatesImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.ContextsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.DiagnosticsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.DynamicSchemaVersionsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.DynamicSchemasImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.ExecutionsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.InstanceHistoriesImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.InstancesImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.JobsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.SchemaReferencesImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.SchemaVersionsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.SchemasImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.SiteReferencesImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.SolutionTemplateVersionsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.SolutionTemplatesImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.SolutionVersionsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.SolutionsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.TargetsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.WorkflowVersionsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.WorkflowsImpl;
import com.azure.resourcemanager.workloadorchestration.implementation.WorkloadOrchestrationManagementClientBuilder;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersions;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplates;
import com.azure.resourcemanager.workloadorchestration.models.Contexts;
import com.azure.resourcemanager.workloadorchestration.models.Diagnostics;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaVersions;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemas;
import com.azure.resourcemanager.workloadorchestration.models.Executions;
import com.azure.resourcemanager.workloadorchestration.models.InstanceHistories;
import com.azure.resourcemanager.workloadorchestration.models.Instances;
import com.azure.resourcemanager.workloadorchestration.models.Jobs;
import com.azure.resourcemanager.workloadorchestration.models.SchemaReferences;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersions;
import com.azure.resourcemanager.workloadorchestration.models.Schemas;
import com.azure.resourcemanager.workloadorchestration.models.SiteReferences;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersions;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplates;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersions;
import com.azure.resourcemanager.workloadorchestration.models.Solutions;
import com.azure.resourcemanager.workloadorchestration.models.Targets;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersions;
import com.azure.resourcemanager.workloadorchestration.models.Workflows;
import java.time.Duration;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Entry point to WorkloadOrchestrationManager.
 * Microsoft.Edge Resource Provider management API.
 */
public final class WorkloadOrchestrationManager {
    private DynamicSchemas dynamicSchemas;

    private Schemas schemas;

    private SchemaVersions schemaVersions;

    private SolutionVersions solutionVersions;

    private Jobs jobs;

    private Targets targets;

    private DynamicSchemaVersions dynamicSchemaVersions;

    private SchemaReferences schemaReferences;

    private Solutions solutions;

    private SolutionTemplateVersions solutionTemplateVersions;

    private SolutionTemplates solutionTemplates;

    private Instances instances;

    private InstanceHistories instanceHistories;

    private ConfigTemplates configTemplates;

    private ConfigTemplateVersions configTemplateVersions;

    private Workflows workflows;

    private WorkflowVersions workflowVersions;

    private Executions executions;

    private Diagnostics diagnostics;

    private Contexts contexts;

    private SiteReferences siteReferences;

    private final WorkloadOrchestrationManagementClient clientObject;

    private WorkloadOrchestrationManager(HttpPipeline httpPipeline, AzureProfile profile,
        Duration defaultPollInterval) {
        Objects.requireNonNull(httpPipeline, "'httpPipeline' cannot be null.");
        Objects.requireNonNull(profile, "'profile' cannot be null.");
        this.clientObject = new WorkloadOrchestrationManagementClientBuilder().pipeline(httpPipeline)
            .endpoint(profile.getEnvironment().getResourceManagerEndpoint())
            .subscriptionId(profile.getSubscriptionId())
            .defaultPollInterval(defaultPollInterval)
            .buildClient();
    }

    /**
     * Creates an instance of Workload Orchestration service API entry point.
     * 
     * @param credential the credential to use.
     * @param profile the Azure profile for client.
     * @return the Workload Orchestration service API instance.
     */
    public static WorkloadOrchestrationManager authenticate(TokenCredential credential, AzureProfile profile) {
        Objects.requireNonNull(credential, "'credential' cannot be null.");
        Objects.requireNonNull(profile, "'profile' cannot be null.");
        return configure().authenticate(credential, profile);
    }

    /**
     * Creates an instance of Workload Orchestration service API entry point.
     * 
     * @param httpPipeline the {@link HttpPipeline} configured with Azure authentication credential.
     * @param profile the Azure profile for client.
     * @return the Workload Orchestration service API instance.
     */
    public static WorkloadOrchestrationManager authenticate(HttpPipeline httpPipeline, AzureProfile profile) {
        Objects.requireNonNull(httpPipeline, "'httpPipeline' cannot be null.");
        Objects.requireNonNull(profile, "'profile' cannot be null.");
        return new WorkloadOrchestrationManager(httpPipeline, profile, null);
    }

    /**
     * Gets a Configurable instance that can be used to create WorkloadOrchestrationManager with optional configuration.
     * 
     * @return the Configurable instance allowing configurations.
     */
    public static Configurable configure() {
        return new WorkloadOrchestrationManager.Configurable();
    }

    /**
     * The Configurable allowing configurations to be set.
     */
    public static final class Configurable {
        private static final ClientLogger LOGGER = new ClientLogger(Configurable.class);
        private static final String SDK_VERSION = "version";
        private static final Map<String, String> PROPERTIES
            = CoreUtils.getProperties("azure-resourcemanager-workloadorchestration.properties");

        private HttpClient httpClient;
        private HttpLogOptions httpLogOptions;
        private final List<HttpPipelinePolicy> policies = new ArrayList<>();
        private final List<String> scopes = new ArrayList<>();
        private RetryPolicy retryPolicy;
        private RetryOptions retryOptions;
        private Duration defaultPollInterval;

        private Configurable() {
        }

        /**
         * Sets the http client.
         *
         * @param httpClient the HTTP client.
         * @return the configurable object itself.
         */
        public Configurable withHttpClient(HttpClient httpClient) {
            this.httpClient = Objects.requireNonNull(httpClient, "'httpClient' cannot be null.");
            return this;
        }

        /**
         * Sets the logging options to the HTTP pipeline.
         *
         * @param httpLogOptions the HTTP log options.
         * @return the configurable object itself.
         */
        public Configurable withLogOptions(HttpLogOptions httpLogOptions) {
            this.httpLogOptions = Objects.requireNonNull(httpLogOptions, "'httpLogOptions' cannot be null.");
            return this;
        }

        /**
         * Adds the pipeline policy to the HTTP pipeline.
         *
         * @param policy the HTTP pipeline policy.
         * @return the configurable object itself.
         */
        public Configurable withPolicy(HttpPipelinePolicy policy) {
            this.policies.add(Objects.requireNonNull(policy, "'policy' cannot be null."));
            return this;
        }

        /**
         * Adds the scope to permission sets.
         *
         * @param scope the scope.
         * @return the configurable object itself.
         */
        public Configurable withScope(String scope) {
            this.scopes.add(Objects.requireNonNull(scope, "'scope' cannot be null."));
            return this;
        }

        /**
         * Sets the retry policy to the HTTP pipeline.
         *
         * @param retryPolicy the HTTP pipeline retry policy.
         * @return the configurable object itself.
         */
        public Configurable withRetryPolicy(RetryPolicy retryPolicy) {
            this.retryPolicy = Objects.requireNonNull(retryPolicy, "'retryPolicy' cannot be null.");
            return this;
        }

        /**
         * Sets the retry options for the HTTP pipeline retry policy.
         * <p>
         * This setting has no effect, if retry policy is set via {@link #withRetryPolicy(RetryPolicy)}.
         *
         * @param retryOptions the retry options for the HTTP pipeline retry policy.
         * @return the configurable object itself.
         */
        public Configurable withRetryOptions(RetryOptions retryOptions) {
            this.retryOptions = Objects.requireNonNull(retryOptions, "'retryOptions' cannot be null.");
            return this;
        }

        /**
         * Sets the default poll interval, used when service does not provide "Retry-After" header.
         *
         * @param defaultPollInterval the default poll interval.
         * @return the configurable object itself.
         */
        public Configurable withDefaultPollInterval(Duration defaultPollInterval) {
            this.defaultPollInterval
                = Objects.requireNonNull(defaultPollInterval, "'defaultPollInterval' cannot be null.");
            if (this.defaultPollInterval.isNegative()) {
                throw LOGGER
                    .logExceptionAsError(new IllegalArgumentException("'defaultPollInterval' cannot be negative"));
            }
            return this;
        }

        /**
         * Creates an instance of Workload Orchestration service API entry point.
         *
         * @param credential the credential to use.
         * @param profile the Azure profile for client.
         * @return the Workload Orchestration service API instance.
         */
        public WorkloadOrchestrationManager authenticate(TokenCredential credential, AzureProfile profile) {
            Objects.requireNonNull(credential, "'credential' cannot be null.");
            Objects.requireNonNull(profile, "'profile' cannot be null.");

            String clientVersion = PROPERTIES.getOrDefault(SDK_VERSION, "UnknownVersion");

            StringBuilder userAgentBuilder = new StringBuilder();
            userAgentBuilder.append("azsdk-java")
                .append("-")
                .append("com.azure.resourcemanager.workloadorchestration")
                .append("/")
                .append(clientVersion);
            if (!Configuration.getGlobalConfiguration().get("AZURE_TELEMETRY_DISABLED", false)) {
                userAgentBuilder.append(" (")
                    .append(Configuration.getGlobalConfiguration().get("java.version"))
                    .append("; ")
                    .append(Configuration.getGlobalConfiguration().get("os.name"))
                    .append("; ")
                    .append(Configuration.getGlobalConfiguration().get("os.version"))
                    .append("; auto-generated)");
            } else {
                userAgentBuilder.append(" (auto-generated)");
            }

            if (scopes.isEmpty()) {
                scopes.add(profile.getEnvironment().getManagementEndpoint() + "/.default");
            }
            if (retryPolicy == null) {
                if (retryOptions != null) {
                    retryPolicy = new RetryPolicy(retryOptions);
                } else {
                    retryPolicy = new RetryPolicy("Retry-After", ChronoUnit.SECONDS);
                }
            }
            List<HttpPipelinePolicy> policies = new ArrayList<>();
            policies.add(new UserAgentPolicy(userAgentBuilder.toString()));
            policies.add(new AddHeadersFromContextPolicy());
            policies.add(new RequestIdPolicy());
            policies.addAll(this.policies.stream()
                .filter(p -> p.getPipelinePosition() == HttpPipelinePosition.PER_CALL)
                .collect(Collectors.toList()));
            HttpPolicyProviders.addBeforeRetryPolicies(policies);
            policies.add(retryPolicy);
            policies.add(new AddDatePolicy());
            policies.add(new BearerTokenAuthenticationPolicy(credential, scopes.toArray(new String[0])));
            policies.addAll(this.policies.stream()
                .filter(p -> p.getPipelinePosition() == HttpPipelinePosition.PER_RETRY)
                .collect(Collectors.toList()));
            HttpPolicyProviders.addAfterRetryPolicies(policies);
            policies.add(new HttpLoggingPolicy(httpLogOptions));
            HttpPipeline httpPipeline = new HttpPipelineBuilder().httpClient(httpClient)
                .policies(policies.toArray(new HttpPipelinePolicy[0]))
                .build();
            return new WorkloadOrchestrationManager(httpPipeline, profile, defaultPollInterval);
        }
    }

    /**
     * Gets the resource collection API of DynamicSchemas. It manages DynamicSchema.
     * 
     * @return Resource collection API of DynamicSchemas.
     */
    public DynamicSchemas dynamicSchemas() {
        if (this.dynamicSchemas == null) {
            this.dynamicSchemas = new DynamicSchemasImpl(clientObject.getDynamicSchemas(), this);
        }
        return dynamicSchemas;
    }

    /**
     * Gets the resource collection API of Schemas. It manages Schema.
     * 
     * @return Resource collection API of Schemas.
     */
    public Schemas schemas() {
        if (this.schemas == null) {
            this.schemas = new SchemasImpl(clientObject.getSchemas(), this);
        }
        return schemas;
    }

    /**
     * Gets the resource collection API of SchemaVersions. It manages SchemaVersion.
     * 
     * @return Resource collection API of SchemaVersions.
     */
    public SchemaVersions schemaVersions() {
        if (this.schemaVersions == null) {
            this.schemaVersions = new SchemaVersionsImpl(clientObject.getSchemaVersions(), this);
        }
        return schemaVersions;
    }

    /**
     * Gets the resource collection API of SolutionVersions. It manages SolutionVersion.
     * 
     * @return Resource collection API of SolutionVersions.
     */
    public SolutionVersions solutionVersions() {
        if (this.solutionVersions == null) {
            this.solutionVersions = new SolutionVersionsImpl(clientObject.getSolutionVersions(), this);
        }
        return solutionVersions;
    }

    /**
     * Gets the resource collection API of Jobs.
     * 
     * @return Resource collection API of Jobs.
     */
    public Jobs jobs() {
        if (this.jobs == null) {
            this.jobs = new JobsImpl(clientObject.getJobs(), this);
        }
        return jobs;
    }

    /**
     * Gets the resource collection API of Targets. It manages Target.
     * 
     * @return Resource collection API of Targets.
     */
    public Targets targets() {
        if (this.targets == null) {
            this.targets = new TargetsImpl(clientObject.getTargets(), this);
        }
        return targets;
    }

    /**
     * Gets the resource collection API of DynamicSchemaVersions. It manages DynamicSchemaVersion.
     * 
     * @return Resource collection API of DynamicSchemaVersions.
     */
    public DynamicSchemaVersions dynamicSchemaVersions() {
        if (this.dynamicSchemaVersions == null) {
            this.dynamicSchemaVersions = new DynamicSchemaVersionsImpl(clientObject.getDynamicSchemaVersions(), this);
        }
        return dynamicSchemaVersions;
    }

    /**
     * Gets the resource collection API of SchemaReferences.
     * 
     * @return Resource collection API of SchemaReferences.
     */
    public SchemaReferences schemaReferences() {
        if (this.schemaReferences == null) {
            this.schemaReferences = new SchemaReferencesImpl(clientObject.getSchemaReferences(), this);
        }
        return schemaReferences;
    }

    /**
     * Gets the resource collection API of Solutions. It manages Solution.
     * 
     * @return Resource collection API of Solutions.
     */
    public Solutions solutions() {
        if (this.solutions == null) {
            this.solutions = new SolutionsImpl(clientObject.getSolutions(), this);
        }
        return solutions;
    }

    /**
     * Gets the resource collection API of SolutionTemplateVersions.
     * 
     * @return Resource collection API of SolutionTemplateVersions.
     */
    public SolutionTemplateVersions solutionTemplateVersions() {
        if (this.solutionTemplateVersions == null) {
            this.solutionTemplateVersions
                = new SolutionTemplateVersionsImpl(clientObject.getSolutionTemplateVersions(), this);
        }
        return solutionTemplateVersions;
    }

    /**
     * Gets the resource collection API of SolutionTemplates. It manages SolutionTemplate.
     * 
     * @return Resource collection API of SolutionTemplates.
     */
    public SolutionTemplates solutionTemplates() {
        if (this.solutionTemplates == null) {
            this.solutionTemplates = new SolutionTemplatesImpl(clientObject.getSolutionTemplates(), this);
        }
        return solutionTemplates;
    }

    /**
     * Gets the resource collection API of Instances. It manages Instance.
     * 
     * @return Resource collection API of Instances.
     */
    public Instances instances() {
        if (this.instances == null) {
            this.instances = new InstancesImpl(clientObject.getInstances(), this);
        }
        return instances;
    }

    /**
     * Gets the resource collection API of InstanceHistories.
     * 
     * @return Resource collection API of InstanceHistories.
     */
    public InstanceHistories instanceHistories() {
        if (this.instanceHistories == null) {
            this.instanceHistories = new InstanceHistoriesImpl(clientObject.getInstanceHistories(), this);
        }
        return instanceHistories;
    }

    /**
     * Gets the resource collection API of ConfigTemplates. It manages ConfigTemplate.
     * 
     * @return Resource collection API of ConfigTemplates.
     */
    public ConfigTemplates configTemplates() {
        if (this.configTemplates == null) {
            this.configTemplates = new ConfigTemplatesImpl(clientObject.getConfigTemplates(), this);
        }
        return configTemplates;
    }

    /**
     * Gets the resource collection API of ConfigTemplateVersions.
     * 
     * @return Resource collection API of ConfigTemplateVersions.
     */
    public ConfigTemplateVersions configTemplateVersions() {
        if (this.configTemplateVersions == null) {
            this.configTemplateVersions
                = new ConfigTemplateVersionsImpl(clientObject.getConfigTemplateVersions(), this);
        }
        return configTemplateVersions;
    }

    /**
     * Gets the resource collection API of Workflows. It manages Workflow.
     * 
     * @return Resource collection API of Workflows.
     */
    public Workflows workflows() {
        if (this.workflows == null) {
            this.workflows = new WorkflowsImpl(clientObject.getWorkflows(), this);
        }
        return workflows;
    }

    /**
     * Gets the resource collection API of WorkflowVersions. It manages WorkflowVersion.
     * 
     * @return Resource collection API of WorkflowVersions.
     */
    public WorkflowVersions workflowVersions() {
        if (this.workflowVersions == null) {
            this.workflowVersions = new WorkflowVersionsImpl(clientObject.getWorkflowVersions(), this);
        }
        return workflowVersions;
    }

    /**
     * Gets the resource collection API of Executions. It manages Execution.
     * 
     * @return Resource collection API of Executions.
     */
    public Executions executions() {
        if (this.executions == null) {
            this.executions = new ExecutionsImpl(clientObject.getExecutions(), this);
        }
        return executions;
    }

    /**
     * Gets the resource collection API of Diagnostics. It manages Diagnostic.
     * 
     * @return Resource collection API of Diagnostics.
     */
    public Diagnostics diagnostics() {
        if (this.diagnostics == null) {
            this.diagnostics = new DiagnosticsImpl(clientObject.getDiagnostics(), this);
        }
        return diagnostics;
    }

    /**
     * Gets the resource collection API of Contexts. It manages ContextModel.
     * 
     * @return Resource collection API of Contexts.
     */
    public Contexts contexts() {
        if (this.contexts == null) {
            this.contexts = new ContextsImpl(clientObject.getContexts(), this);
        }
        return contexts;
    }

    /**
     * Gets the resource collection API of SiteReferences. It manages SiteReference.
     * 
     * @return Resource collection API of SiteReferences.
     */
    public SiteReferences siteReferences() {
        if (this.siteReferences == null) {
            this.siteReferences = new SiteReferencesImpl(clientObject.getSiteReferences(), this);
        }
        return siteReferences;
    }

    /**
     * Gets wrapped service client WorkloadOrchestrationManagementClient providing direct access to the underlying
     * auto-generated API implementation, based on Azure REST API.
     * 
     * @return Wrapped service client WorkloadOrchestrationManagementClient.
     */
    public WorkloadOrchestrationManagementClient serviceClient() {
        return this.clientObject;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/ConfigTemplatesClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

/**
 * An instance of this class provides access to all the operations defined in ConfigTemplatesClient.
 */
public interface ConfigTemplatesClient {
    /**
     * Get a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<ConfigTemplateInner> getByResourceGroupWithResponse(String resourceGroupName, String configTemplateName,
        Context context);

    /**
     * Get a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ConfigTemplateInner getByResourceGroup(String resourceGroupName, String configTemplateName);

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ConfigTemplateInner>, ConfigTemplateInner> beginCreateOrUpdate(String resourceGroupName,
        String configTemplateName, ConfigTemplateInner resource);

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ConfigTemplateInner>, ConfigTemplateInner> beginCreateOrUpdate(String resourceGroupName,
        String configTemplateName, ConfigTemplateInner resource, Context context);

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ConfigTemplateInner createOrUpdate(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner resource);

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ConfigTemplateInner createOrUpdate(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner resource, Context context);

    /**
     * update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<ConfigTemplateInner> updateWithResponse(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner properties, Context context);

    /**
     * update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ConfigTemplateInner update(String resourceGroupName, String configTemplateName, ConfigTemplateInner properties);

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ConfigTemplateVersionInner>, ConfigTemplateVersionInner> beginCreateVersion(
        String resourceGroupName, String configTemplateName, ConfigTemplateVersionWithUpdateTypeInner body);

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ConfigTemplateVersionInner>, ConfigTemplateVersionInner> beginCreateVersion(
        String resourceGroupName, String configTemplateName, ConfigTemplateVersionWithUpdateTypeInner body,
        Context context);

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ConfigTemplateVersionInner createVersion(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body);

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ConfigTemplateVersionInner createVersion(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body, Context context);

    /**
     * Remove Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<RemoveVersionResponseInner> removeVersionWithResponse(String resourceGroupName, String configTemplateName,
        VersionParameter body, Context context);

    /**
     * Remove Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    RemoveVersionResponseInner removeVersion(String resourceGroupName, String configTemplateName,
        VersionParameter body);

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String configTemplateName);

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String configTemplateName,
        Context context);

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String configTemplateName);

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String configTemplateName, Context context);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ConfigTemplateInner> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ConfigTemplateInner> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ConfigTemplateInner> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ConfigTemplateInner> list(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/ConfigTemplateVersionsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;

/**
 * An instance of this class provides access to all the operations defined in ConfigTemplateVersionsClient.
 */
public interface ConfigTemplateVersionsClient {
    /**
     * Get a Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param configTemplateVersionName The name of the ConfigTemplateVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<ConfigTemplateVersionInner> getWithResponse(String resourceGroupName, String configTemplateName,
        String configTemplateVersionName, Context context);

    /**
     * Get a Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param configTemplateVersionName The name of the ConfigTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ConfigTemplateVersionInner get(String resourceGroupName, String configTemplateName,
        String configTemplateVersionName);

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ConfigTemplateVersionInner> listByConfigTemplate(String resourceGroupName, String configTemplateName);

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ConfigTemplateVersionInner> listByConfigTemplate(String resourceGroupName, String configTemplateName,
        Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/ContextsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner;

/**
 * An instance of this class provides access to all the operations defined in ContextsClient.
 */
public interface ContextsClient {
    /**
     * Get Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<ContextInner> getByResourceGroupWithResponse(String resourceGroupName, String contextName,
        Context context);

    /**
     * Get Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ContextInner getByResourceGroup(String resourceGroupName, String contextName);

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ContextInner>, ContextInner> beginCreateOrUpdate(String resourceGroupName, String contextName,
        ContextInner resource);

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ContextInner>, ContextInner> beginCreateOrUpdate(String resourceGroupName, String contextName,
        ContextInner resource, Context context);

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ContextInner createOrUpdate(String resourceGroupName, String contextName, ContextInner resource);

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ContextInner createOrUpdate(String resourceGroupName, String contextName, ContextInner resource, Context context);

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ContextInner>, ContextInner> beginUpdate(String resourceGroupName, String contextName,
        ContextInner properties);

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ContextInner>, ContextInner> beginUpdate(String resourceGroupName, String contextName,
        ContextInner properties, Context context);

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ContextInner update(String resourceGroupName, String contextName, ContextInner properties);

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ContextInner update(String resourceGroupName, String contextName, ContextInner properties, Context context);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ContextInner> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ContextInner> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ContextInner> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ContextInner> list(Context context);

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName);

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName, Context context);

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName);

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/DiagnosticsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner;

/**
 * An instance of this class provides access to all the operations defined in DiagnosticsClient.
 */
public interface DiagnosticsClient {
    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<DiagnosticInner> getByResourceGroupWithResponse(String resourceGroupName, String diagnosticName,
        Context context);

    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DiagnosticInner getByResourceGroup(String resourceGroupName, String diagnosticName);

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<DiagnosticInner>, DiagnosticInner> beginCreateOrUpdate(String resourceGroupName,
        String diagnosticName, DiagnosticInner resource);

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<DiagnosticInner>, DiagnosticInner> beginCreateOrUpdate(String resourceGroupName,
        String diagnosticName, DiagnosticInner resource, Context context);

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DiagnosticInner createOrUpdate(String resourceGroupName, String diagnosticName, DiagnosticInner resource);

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DiagnosticInner createOrUpdate(String resourceGroupName, String diagnosticName, DiagnosticInner resource,
        Context context);

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<DiagnosticInner>, DiagnosticInner> beginUpdate(String resourceGroupName,
        String diagnosticName, DiagnosticInner properties);

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<DiagnosticInner>, DiagnosticInner> beginUpdate(String resourceGroupName,
        String diagnosticName, DiagnosticInner properties, Context context);

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DiagnosticInner update(String resourceGroupName, String diagnosticName, DiagnosticInner properties);

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DiagnosticInner update(String resourceGroupName, String diagnosticName, DiagnosticInner properties,
        Context context);

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String diagnosticName);

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String diagnosticName, Context context);

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String diagnosticName);

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String diagnosticName, Context context);

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<DiagnosticInner> listByResourceGroup(String resourceGroupName);

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<DiagnosticInner> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<DiagnosticInner> list();

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<DiagnosticInner> list(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/DynamicSchemasClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner;

/**
 * An instance of this class provides access to all the operations defined in DynamicSchemasClient.
 */
public interface DynamicSchemasClient {
    /**
     * Get a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<DynamicSchemaInner> getWithResponse(String resourceGroupName, String schemaName, String dynamicSchemaName,
        Context context);

    /**
     * Get a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DynamicSchemaInner get(String resourceGroupName, String schemaName, String dynamicSchemaName);

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<DynamicSchemaInner>, DynamicSchemaInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, String dynamicSchemaName, DynamicSchemaInner resource);

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<DynamicSchemaInner>, DynamicSchemaInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, String dynamicSchemaName, DynamicSchemaInner resource, Context context);

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DynamicSchemaInner createOrUpdate(String resourceGroupName, String schemaName, String dynamicSchemaName,
        DynamicSchemaInner resource);

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DynamicSchemaInner createOrUpdate(String resourceGroupName, String schemaName, String dynamicSchemaName,
        DynamicSchemaInner resource, Context context);

    /**
     * update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<DynamicSchemaInner> updateWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, DynamicSchemaInner properties, Context context);

    /**
     * update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DynamicSchemaInner update(String resourceGroupName, String schemaName, String dynamicSchemaName,
        DynamicSchemaInner properties);

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String dynamicSchemaName);

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String dynamicSchemaName, Context context);

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String schemaName, String dynamicSchemaName);

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String schemaName, String dynamicSchemaName, Context context);

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<DynamicSchemaInner> listBySchema(String resourceGroupName, String schemaName);

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<DynamicSchemaInner> listBySchema(String resourceGroupName, String schemaName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/DynamicSchemaVersionsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner;

/**
 * An instance of this class provides access to all the operations defined in DynamicSchemaVersionsClient.
 */
public interface DynamicSchemaVersionsClient {
    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<DynamicSchemaVersionInner> getWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, Context context);

    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DynamicSchemaVersionInner get(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName);

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<DynamicSchemaVersionInner>, DynamicSchemaVersionInner> beginCreateOrUpdate(
        String resourceGroupName, String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName,
        DynamicSchemaVersionInner resource);

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<DynamicSchemaVersionInner>, DynamicSchemaVersionInner> beginCreateOrUpdate(
        String resourceGroupName, String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName,
        DynamicSchemaVersionInner resource, Context context);

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DynamicSchemaVersionInner createOrUpdate(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName, DynamicSchemaVersionInner resource);

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DynamicSchemaVersionInner createOrUpdate(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName, DynamicSchemaVersionInner resource, Context context);

    /**
     * update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<DynamicSchemaVersionInner> updateWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, DynamicSchemaVersionInner properties,
        Context context);

    /**
     * update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    DynamicSchemaVersionInner update(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName, DynamicSchemaVersionInner properties);

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName);

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, Context context);

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName);

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName,
        Context context);

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<DynamicSchemaVersionInner> listByDynamicSchema(String resourceGroupName, String schemaName,
        String dynamicSchemaName);

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<DynamicSchemaVersionInner> listByDynamicSchema(String resourceGroupName, String schemaName,
        String dynamicSchemaName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/ExecutionsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner;

/**
 * An instance of this class provides access to all the operations defined in ExecutionsClient.
 */
public interface ExecutionsClient {
    /**
     * Get Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<ExecutionInner> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, Context context);

    /**
     * Get Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ExecutionInner get(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName);

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ExecutionInner>, ExecutionInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, String executionName, ExecutionInner resource);

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ExecutionInner>, ExecutionInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, String executionName, ExecutionInner resource,
        Context context);

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ExecutionInner createOrUpdate(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, ExecutionInner resource);

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ExecutionInner createOrUpdate(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, ExecutionInner resource, Context context);

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ExecutionInner>, ExecutionInner> beginUpdate(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName, ExecutionInner properties);

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ExecutionInner>, ExecutionInner> beginUpdate(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName, ExecutionInner properties, Context context);

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ExecutionInner update(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, ExecutionInner properties);

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ExecutionInner update(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, ExecutionInner properties, Context context);

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName);

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, Context context);

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName);

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, Context context);

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ExecutionInner> listByWorkflowVersion(String resourceGroupName, String contextName,
        String workflowName, String versionName);

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<ExecutionInner> listByWorkflowVersion(String resourceGroupName, String contextName,
        String workflowName, String versionName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/InstanceHistoriesClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner;

/**
 * An instance of this class provides access to all the operations defined in InstanceHistoriesClient.
 */
public interface InstanceHistoriesClient {
    /**
     * Get InstanceHistory Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param instanceHistoryName Name of the instance history.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instanceHistory Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<InstanceHistoryInner> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, String instanceHistoryName, Context context);

    /**
     * Get InstanceHistory Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param instanceHistoryName Name of the instance history.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instanceHistory Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    InstanceHistoryInner get(String resourceGroupName, String targetName, String solutionName, String instanceName,
        String instanceHistoryName);

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<InstanceHistoryInner> listByInstance(String resourceGroupName, String targetName, String solutionName,
        String instanceName);

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<InstanceHistoryInner> listByInstance(String resourceGroupName, String targetName, String solutionName,
        String instanceName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/InstancesClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner;

/**
 * An instance of this class provides access to all the operations defined in InstancesClient.
 */
public interface InstancesClient {
    /**
     * Get Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<InstanceInner> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, Context context);

    /**
     * Get Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    InstanceInner get(String resourceGroupName, String targetName, String solutionName, String instanceName);

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<InstanceInner>, InstanceInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, String instanceName, InstanceInner resource);

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<InstanceInner>, InstanceInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, String instanceName, InstanceInner resource, Context context);

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    InstanceInner createOrUpdate(String resourceGroupName, String targetName, String solutionName, String instanceName,
        InstanceInner resource);

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    InstanceInner createOrUpdate(String resourceGroupName, String targetName, String solutionName, String instanceName,
        InstanceInner resource, Context context);

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<InstanceInner>, InstanceInner> beginUpdate(String resourceGroupName, String targetName,
        String solutionName, String instanceName, InstanceInner properties);

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<InstanceInner>, InstanceInner> beginUpdate(String resourceGroupName, String targetName,
        String solutionName, String instanceName, InstanceInner properties, Context context);

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    InstanceInner update(String resourceGroupName, String targetName, String solutionName, String instanceName,
        InstanceInner properties);

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    InstanceInner update(String resourceGroupName, String targetName, String solutionName, String instanceName,
        InstanceInner properties, Context context);

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName, String solutionName,
        String instanceName);

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName, String solutionName,
        String instanceName, Context context);

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String targetName, String solutionName, String instanceName);

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String targetName, String solutionName, String instanceName, Context context);

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<InstanceInner> listBySolution(String resourceGroupName, String targetName, String solutionName);

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<InstanceInner> listBySolution(String resourceGroupName, String targetName, String solutionName,
        Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/JobsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.JobInner;

/**
 * An instance of this class provides access to all the operations defined in JobsClient.
 */
public interface JobsClient {
    /**
     * Get a Job resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param jobName The name of the Job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Job resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<JobInner> getWithResponse(String resourceUri, String jobName, Context context);

    /**
     * Get a Job resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param jobName The name of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Job resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    JobInner get(String resourceUri, String jobName);

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<JobInner> listByTarget(String resourceUri);

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<JobInner> listByTarget(String resourceUri, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/package-info.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

/**
 * Package containing the service clients for WorkloadOrchestration.
 * Microsoft.Edge Resource Provider management API.
 */
package com.azure.resourcemanager.workloadorchestration.fluent;



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/SchemaReferencesClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner;

/**
 * An instance of this class provides access to all the operations defined in SchemaReferencesClient.
 */
public interface SchemaReferencesClient {
    /**
     * Get a Schema Reference Resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param schemaReferenceName The name of the SchemaReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SchemaReferenceInner> getWithResponse(String resourceUri, String schemaReferenceName, Context context);

    /**
     * Get a Schema Reference Resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param schemaReferenceName The name of the SchemaReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaReferenceInner get(String resourceUri, String schemaReferenceName);

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SchemaReferenceInner> listByResourceGroup(String resourceUri);

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SchemaReferenceInner> listByResourceGroup(String resourceUri, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/SchemasClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

/**
 * An instance of this class provides access to all the operations defined in SchemasClient.
 */
public interface SchemasClient {
    /**
     * Get a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SchemaInner> getByResourceGroupWithResponse(String resourceGroupName, String schemaName, Context context);

    /**
     * Get a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaInner getByResourceGroup(String resourceGroupName, String schemaName);

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of schema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SchemaInner>, SchemaInner> beginCreateOrUpdate(String resourceGroupName, String schemaName,
        SchemaInner resource);

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of schema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SchemaInner>, SchemaInner> beginCreateOrUpdate(String resourceGroupName, String schemaName,
        SchemaInner resource, Context context);

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaInner createOrUpdate(String resourceGroupName, String schemaName, SchemaInner resource);

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaInner createOrUpdate(String resourceGroupName, String schemaName, SchemaInner resource, Context context);

    /**
     * update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SchemaInner> updateWithResponse(String resourceGroupName, String schemaName, SchemaInner properties,
        Context context);

    /**
     * update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaInner update(String resourceGroupName, String schemaName, SchemaInner properties);

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName);

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName, Context context);

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String schemaName);

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String schemaName, Context context);

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SchemaVersionInner>, SchemaVersionInner> beginCreateVersion(String resourceGroupName,
        String schemaName, SchemaVersionWithUpdateTypeInner body);

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SchemaVersionInner>, SchemaVersionInner> beginCreateVersion(String resourceGroupName,
        String schemaName, SchemaVersionWithUpdateTypeInner body, Context context);

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaVersionInner createVersion(String resourceGroupName, String schemaName,
        SchemaVersionWithUpdateTypeInner body);

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaVersionInner createVersion(String resourceGroupName, String schemaName, SchemaVersionWithUpdateTypeInner body,
        Context context);

    /**
     * Remove Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<RemoveVersionResponseInner> removeVersionWithResponse(String resourceGroupName, String schemaName,
        VersionParameter body, Context context);

    /**
     * Remove Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    RemoveVersionResponseInner removeVersion(String resourceGroupName, String schemaName, VersionParameter body);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SchemaInner> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SchemaInner> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SchemaInner> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SchemaInner> list(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/SchemaVersionsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;

/**
 * An instance of this class provides access to all the operations defined in SchemaVersionsClient.
 */
public interface SchemaVersionsClient {
    /**
     * Get a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SchemaVersionInner> getWithResponse(String resourceGroupName, String schemaName, String schemaVersionName,
        Context context);

    /**
     * Get a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaVersionInner get(String resourceGroupName, String schemaName, String schemaVersionName);

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SchemaVersionInner>, SchemaVersionInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, String schemaVersionName, SchemaVersionInner resource);

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SchemaVersionInner>, SchemaVersionInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, String schemaVersionName, SchemaVersionInner resource, Context context);

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaVersionInner createOrUpdate(String resourceGroupName, String schemaName, String schemaVersionName,
        SchemaVersionInner resource);

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaVersionInner createOrUpdate(String resourceGroupName, String schemaName, String schemaVersionName,
        SchemaVersionInner resource, Context context);

    /**
     * update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SchemaVersionInner> updateWithResponse(String resourceGroupName, String schemaName,
        String schemaVersionName, SchemaVersionInner properties, Context context);

    /**
     * update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SchemaVersionInner update(String resourceGroupName, String schemaName, String schemaVersionName,
        SchemaVersionInner properties);

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String schemaVersionName);

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String schemaVersionName, Context context);

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String schemaName, String schemaVersionName);

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String schemaName, String schemaVersionName, Context context);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SchemaVersionInner> listBySchema(String resourceGroupName, String schemaName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SchemaVersionInner> listBySchema(String resourceGroupName, String schemaName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/SiteReferencesClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner;

/**
 * An instance of this class provides access to all the operations defined in SiteReferencesClient.
 */
public interface SiteReferencesClient {
    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SiteReferenceInner> getWithResponse(String resourceGroupName, String contextName, String siteReferenceName,
        Context context);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SiteReferenceInner get(String resourceGroupName, String contextName, String siteReferenceName);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SiteReferenceInner>, SiteReferenceInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner resource);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SiteReferenceInner>, SiteReferenceInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner resource, Context context);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SiteReferenceInner createOrUpdate(String resourceGroupName, String contextName, String siteReferenceName,
        SiteReferenceInner resource);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SiteReferenceInner createOrUpdate(String resourceGroupName, String contextName, String siteReferenceName,
        SiteReferenceInner resource, Context context);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SiteReferenceInner>, SiteReferenceInner> beginUpdate(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner properties);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SiteReferenceInner>, SiteReferenceInner> beginUpdate(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner properties, Context context);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SiteReferenceInner update(String resourceGroupName, String contextName, String siteReferenceName,
        SiteReferenceInner properties);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SiteReferenceInner update(String resourceGroupName, String contextName, String siteReferenceName,
        SiteReferenceInner properties, Context context);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String siteReferenceName);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String siteReferenceName, Context context);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName, String siteReferenceName);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName, String siteReferenceName, Context context);

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SiteReferenceInner> listByContext(String resourceGroupName, String contextName);

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SiteReferenceInner> listByContext(String resourceGroupName, String contextName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/SolutionsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner;

/**
 * An instance of this class provides access to all the operations defined in SolutionsClient.
 */
public interface SolutionsClient {
    /**
     * Get a Solution resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SolutionInner> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        Context context);

    /**
     * Get a Solution resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionInner get(String resourceGroupName, String targetName, String solutionName);

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionInner>, SolutionInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, SolutionInner resource);

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionInner>, SolutionInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, SolutionInner resource, Context context);

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        SolutionInner resource);

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        SolutionInner resource, Context context);

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionInner>, SolutionInner> beginUpdate(String resourceGroupName, String targetName,
        String solutionName, SolutionInner properties);

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionInner>, SolutionInner> beginUpdate(String resourceGroupName, String targetName,
        String solutionName, SolutionInner properties, Context context);

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionInner update(String resourceGroupName, String targetName, String solutionName, SolutionInner properties);

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionInner update(String resourceGroupName, String targetName, String solutionName, SolutionInner properties,
        Context context);

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName, String solutionName);

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName, String solutionName,
        Context context);

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String targetName, String solutionName);

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String targetName, String solutionName, Context context);

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionInner> listByTarget(String resourceGroupName, String targetName);

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionInner> listByTarget(String resourceGroupName, String targetName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/SolutionTemplatesClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

/**
 * An instance of this class provides access to all the operations defined in SolutionTemplatesClient.
 */
public interface SolutionTemplatesClient {
    /**
     * Get a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SolutionTemplateInner> getByResourceGroupWithResponse(String resourceGroupName,
        String solutionTemplateName, Context context);

    /**
     * Get a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionTemplateInner getByResourceGroup(String resourceGroupName, String solutionTemplateName);

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionTemplateInner>, SolutionTemplateInner> beginCreateOrUpdate(String resourceGroupName,
        String solutionTemplateName, SolutionTemplateInner resource);

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionTemplateInner>, SolutionTemplateInner> beginCreateOrUpdate(String resourceGroupName,
        String solutionTemplateName, SolutionTemplateInner resource, Context context);

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionTemplateInner createOrUpdate(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner resource);

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionTemplateInner createOrUpdate(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner resource, Context context);

    /**
     * update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SolutionTemplateInner> updateWithResponse(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner properties, Context context);

    /**
     * update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionTemplateInner update(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner properties);

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionTemplateVersionInner>, SolutionTemplateVersionInner> beginCreateVersion(
        String resourceGroupName, String solutionTemplateName, SolutionTemplateVersionWithUpdateTypeInner body);

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionTemplateVersionInner>, SolutionTemplateVersionInner> beginCreateVersion(
        String resourceGroupName, String solutionTemplateName, SolutionTemplateVersionWithUpdateTypeInner body,
        Context context);

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionTemplateVersionInner createVersion(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body);

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionTemplateVersionInner createVersion(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body, Context context);

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginRemoveVersion(String resourceGroupName, String solutionTemplateName,
        VersionParameter body);

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginRemoveVersion(String resourceGroupName, String solutionTemplateName,
        VersionParameter body, Context context);

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void removeVersion(String resourceGroupName, String solutionTemplateName, VersionParameter body);

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void removeVersion(String resourceGroupName, String solutionTemplateName, VersionParameter body, Context context);

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String solutionTemplateName);

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String solutionTemplateName,
        Context context);

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String solutionTemplateName);

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String solutionTemplateName, Context context);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionTemplateInner> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionTemplateInner> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionTemplateInner> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionTemplateInner> list(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/SolutionTemplateVersionsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.BulkDeploySolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.BulkPublishSolutionParameter;

/**
 * An instance of this class provides access to all the operations defined in SolutionTemplateVersionsClient.
 */
public interface SolutionTemplateVersionsClient {
    /**
     * Get a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SolutionTemplateVersionInner> getWithResponse(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, Context context);

    /**
     * Get a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionTemplateVersionInner get(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName);

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionTemplateVersionInner> listBySolutionTemplate(String resourceGroupName,
        String solutionTemplateName);

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionTemplateVersionInner> listBySolutionTemplate(String resourceGroupName,
        String solutionTemplateName, Context context);

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginBulkDeploySolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkDeploySolutionParameter body);

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginBulkDeploySolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkDeploySolutionParameter body, Context context);

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void bulkDeploySolution(String resourceGroupName, String solutionTemplateName, String solutionTemplateVersionName,
        BulkDeploySolutionParameter body);

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void bulkDeploySolution(String resourceGroupName, String solutionTemplateName, String solutionTemplateVersionName,
        BulkDeploySolutionParameter body, Context context);

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginBulkPublishSolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkPublishSolutionParameter body);

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginBulkPublishSolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkPublishSolutionParameter body, Context context);

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void bulkPublishSolution(String resourceGroupName, String solutionTemplateName, String solutionTemplateVersionName,
        BulkPublishSolutionParameter body);

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void bulkPublishSolution(String resourceGroupName, String solutionTemplateName, String solutionTemplateVersionName,
        BulkPublishSolutionParameter body, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/SolutionVersionsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner;

/**
 * An instance of this class provides access to all the operations defined in SolutionVersionsClient.
 */
public interface SolutionVersionsClient {
    /**
     * Get a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<SolutionVersionInner> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, Context context);

    /**
     * Get a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner get(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName);

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, String solutionVersionName, SolutionVersionInner resource);

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, String solutionVersionName, SolutionVersionInner resource,
        Context context);

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner resource);

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner resource, Context context);

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdate(String resourceGroupName,
        String targetName, String solutionName, String solutionVersionName, SolutionVersionInner properties);

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdate(String resourceGroupName,
        String targetName, String solutionName, String solutionVersionName, SolutionVersionInner properties,
        Context context);

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner update(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner properties);

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner update(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner properties, Context context);

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName);

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, Context context);

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String targetName, String solutionName, String solutionVersionName);

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String targetName, String solutionName, String solutionVersionName,
        Context context);

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionVersionInner> listBySolution(String resourceGroupName, String targetName,
        String solutionName);

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<SolutionVersionInner> listBySolution(String resourceGroupName, String targetName, String solutionName,
        Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/TargetsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ResolvedConfigurationInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner;
import com.azure.resourcemanager.workloadorchestration.models.InstallSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.RemoveRevisionParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionParameter;
import com.azure.resourcemanager.workloadorchestration.models.UninstallSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.UpdateExternalValidationStatusParameter;

/**
 * An instance of this class provides access to all the operations defined in TargetsClient.
 */
public interface TargetsClient {
    /**
     * Get a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<TargetInner> getByResourceGroupWithResponse(String resourceGroupName, String targetName, Context context);

    /**
     * Get a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    TargetInner getByResourceGroup(String resourceGroupName, String targetName);

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<TargetInner>, TargetInner> beginCreateOrUpdate(String resourceGroupName, String targetName,
        TargetInner resource);

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<TargetInner>, TargetInner> beginCreateOrUpdate(String resourceGroupName, String targetName,
        TargetInner resource, Context context);

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    TargetInner createOrUpdate(String resourceGroupName, String targetName, TargetInner resource);

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    TargetInner createOrUpdate(String resourceGroupName, String targetName, TargetInner resource, Context context);

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<TargetInner>, TargetInner> beginUpdate(String resourceGroupName, String targetName,
        TargetInner properties);

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<TargetInner>, TargetInner> beginUpdate(String resourceGroupName, String targetName,
        TargetInner properties, Context context);

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    TargetInner update(String resourceGroupName, String targetName, TargetInner properties);

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    TargetInner update(String resourceGroupName, String targetName, TargetInner properties, Context context);

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName);

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName, Boolean forceDelete,
        Context context);

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String targetName);

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String targetName, Boolean forceDelete, Context context);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<TargetInner> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<TargetInner> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<TargetInner> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<TargetInner> list(Context context);

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginInstallSolution(String resourceGroupName, String targetName,
        InstallSolutionParameter body);

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginInstallSolution(String resourceGroupName, String targetName,
        InstallSolutionParameter body, Context context);

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void installSolution(String resourceGroupName, String targetName, InstallSolutionParameter body);

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void installSolution(String resourceGroupName, String targetName, InstallSolutionParameter body, Context context);

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginUninstallSolution(String resourceGroupName, String targetName,
        UninstallSolutionParameter body);

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginUninstallSolution(String resourceGroupName, String targetName,
        UninstallSolutionParameter body, Context context);

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void uninstallSolution(String resourceGroupName, String targetName, UninstallSolutionParameter body);

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void uninstallSolution(String resourceGroupName, String targetName, UninstallSolutionParameter body,
        Context context);

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginRemoveRevision(String resourceGroupName, String targetName,
        RemoveRevisionParameter body);

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginRemoveRevision(String resourceGroupName, String targetName,
        RemoveRevisionParameter body, Context context);

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void removeRevision(String resourceGroupName, String targetName, RemoveRevisionParameter body);

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void removeRevision(String resourceGroupName, String targetName, RemoveRevisionParameter body, Context context);

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ResolvedConfigurationInner>, ResolvedConfigurationInner>
        beginResolveConfiguration(String resourceGroupName, String targetName, SolutionTemplateParameter body);

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<ResolvedConfigurationInner>, ResolvedConfigurationInner> beginResolveConfiguration(
        String resourceGroupName, String targetName, SolutionTemplateParameter body, Context context);

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ResolvedConfigurationInner resolveConfiguration(String resourceGroupName, String targetName,
        SolutionTemplateParameter body);

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    ResolvedConfigurationInner resolveConfiguration(String resourceGroupName, String targetName,
        SolutionTemplateParameter body, Context context);

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner>
        beginReviewSolutionVersion(String resourceGroupName, String targetName, SolutionTemplateParameter body);

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginReviewSolutionVersion(
        String resourceGroupName, String targetName, SolutionTemplateParameter body, Context context);

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner reviewSolutionVersion(String resourceGroupName, String targetName,
        SolutionTemplateParameter body);

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner reviewSolutionVersion(String resourceGroupName, String targetName,
        SolutionTemplateParameter body, Context context);

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner>
        beginPublishSolutionVersion(String resourceGroupName, String targetName, SolutionVersionParameter body);

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginPublishSolutionVersion(
        String resourceGroupName, String targetName, SolutionVersionParameter body, Context context);

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner publishSolutionVersion(String resourceGroupName, String targetName,
        SolutionVersionParameter body);

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner publishSolutionVersion(String resourceGroupName, String targetName,
        SolutionVersionParameter body, Context context);

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdateExternalValidationStatus(
        String resourceGroupName, String targetName, UpdateExternalValidationStatusParameter body);

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdateExternalValidationStatus(
        String resourceGroupName, String targetName, UpdateExternalValidationStatusParameter body, Context context);

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner updateExternalValidationStatus(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body);

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    SolutionVersionInner updateExternalValidationStatus(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/WorkflowsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner;

/**
 * An instance of this class provides access to all the operations defined in WorkflowsClient.
 */
public interface WorkflowsClient {
    /**
     * Get a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<WorkflowInner> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        Context context);

    /**
     * Get a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowInner get(String resourceGroupName, String contextName, String workflowName);

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<WorkflowInner>, WorkflowInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, WorkflowInner resource);

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<WorkflowInner>, WorkflowInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, WorkflowInner resource, Context context);

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner resource);

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner resource, Context context);

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<WorkflowInner>, WorkflowInner> beginUpdate(String resourceGroupName, String contextName,
        String workflowName, WorkflowInner properties);

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<WorkflowInner>, WorkflowInner> beginUpdate(String resourceGroupName, String contextName,
        String workflowName, WorkflowInner properties, Context context);

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowInner update(String resourceGroupName, String contextName, String workflowName, WorkflowInner properties);

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowInner update(String resourceGroupName, String contextName, String workflowName, WorkflowInner properties,
        Context context);

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName, String workflowName);

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName, String workflowName,
        Context context);

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName, String workflowName);

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName, String workflowName, Context context);

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<WorkflowInner> listByContext(String resourceGroupName, String contextName);

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<WorkflowInner> listByContext(String resourceGroupName, String contextName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/WorkflowVersionsClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.Context;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner;

/**
 * An instance of this class provides access to all the operations defined in WorkflowVersionsClient.
 */
public interface WorkflowVersionsClient {
    /**
     * Get a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    Response<WorkflowVersionInner> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, Context context);

    /**
     * Get a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowVersionInner get(String resourceGroupName, String contextName, String workflowName, String versionName);

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, WorkflowVersionInner resource);

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, WorkflowVersionInner resource, Context context);

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowVersionInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        String versionName, WorkflowVersionInner resource);

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowVersionInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        String versionName, WorkflowVersionInner resource, Context context);

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, WorkflowVersionInner properties);

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, WorkflowVersionInner properties, Context context);

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowVersionInner update(String resourceGroupName, String contextName, String workflowName, String versionName,
        WorkflowVersionInner properties);

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    WorkflowVersionInner update(String resourceGroupName, String contextName, String workflowName, String versionName,
        WorkflowVersionInner properties, Context context);

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName, String workflowName,
        String versionName);

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName, String workflowName,
        String versionName, Context context);

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName, String workflowName, String versionName);

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    void delete(String resourceGroupName, String contextName, String workflowName, String versionName, Context context);

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<WorkflowVersionInner> listByWorkflow(String resourceGroupName, String contextName,
        String workflowName);

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    PagedIterable<WorkflowVersionInner> listByWorkflow(String resourceGroupName, String contextName,
        String workflowName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/WorkloadOrchestrationManagementClient.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent;

import com.azure.core.http.HttpPipeline;
import java.time.Duration;

/**
 * The interface for WorkloadOrchestrationManagementClient class.
 */
public interface WorkloadOrchestrationManagementClient {
    /**
     * Gets Service host.
     * 
     * @return the endpoint value.
     */
    String getEndpoint();

    /**
     * Gets Version parameter.
     * 
     * @return the apiVersion value.
     */
    String getApiVersion();

    /**
     * Gets The ID of the target subscription. The value must be an UUID.
     * 
     * @return the subscriptionId value.
     */
    String getSubscriptionId();

    /**
     * Gets The HTTP pipeline to send requests through.
     * 
     * @return the httpPipeline value.
     */
    HttpPipeline getHttpPipeline();

    /**
     * Gets The default poll interval for long-running operation.
     * 
     * @return the defaultPollInterval value.
     */
    Duration getDefaultPollInterval();

    /**
     * Gets the DynamicSchemasClient object to access its operations.
     * 
     * @return the DynamicSchemasClient object.
     */
    DynamicSchemasClient getDynamicSchemas();

    /**
     * Gets the SchemasClient object to access its operations.
     * 
     * @return the SchemasClient object.
     */
    SchemasClient getSchemas();

    /**
     * Gets the SchemaVersionsClient object to access its operations.
     * 
     * @return the SchemaVersionsClient object.
     */
    SchemaVersionsClient getSchemaVersions();

    /**
     * Gets the SolutionVersionsClient object to access its operations.
     * 
     * @return the SolutionVersionsClient object.
     */
    SolutionVersionsClient getSolutionVersions();

    /**
     * Gets the JobsClient object to access its operations.
     * 
     * @return the JobsClient object.
     */
    JobsClient getJobs();

    /**
     * Gets the TargetsClient object to access its operations.
     * 
     * @return the TargetsClient object.
     */
    TargetsClient getTargets();

    /**
     * Gets the DynamicSchemaVersionsClient object to access its operations.
     * 
     * @return the DynamicSchemaVersionsClient object.
     */
    DynamicSchemaVersionsClient getDynamicSchemaVersions();

    /**
     * Gets the SchemaReferencesClient object to access its operations.
     * 
     * @return the SchemaReferencesClient object.
     */
    SchemaReferencesClient getSchemaReferences();

    /**
     * Gets the SolutionsClient object to access its operations.
     * 
     * @return the SolutionsClient object.
     */
    SolutionsClient getSolutions();

    /**
     * Gets the SolutionTemplateVersionsClient object to access its operations.
     * 
     * @return the SolutionTemplateVersionsClient object.
     */
    SolutionTemplateVersionsClient getSolutionTemplateVersions();

    /**
     * Gets the SolutionTemplatesClient object to access its operations.
     * 
     * @return the SolutionTemplatesClient object.
     */
    SolutionTemplatesClient getSolutionTemplates();

    /**
     * Gets the InstancesClient object to access its operations.
     * 
     * @return the InstancesClient object.
     */
    InstancesClient getInstances();

    /**
     * Gets the InstanceHistoriesClient object to access its operations.
     * 
     * @return the InstanceHistoriesClient object.
     */
    InstanceHistoriesClient getInstanceHistories();

    /**
     * Gets the ConfigTemplatesClient object to access its operations.
     * 
     * @return the ConfigTemplatesClient object.
     */
    ConfigTemplatesClient getConfigTemplates();

    /**
     * Gets the ConfigTemplateVersionsClient object to access its operations.
     * 
     * @return the ConfigTemplateVersionsClient object.
     */
    ConfigTemplateVersionsClient getConfigTemplateVersions();

    /**
     * Gets the WorkflowsClient object to access its operations.
     * 
     * @return the WorkflowsClient object.
     */
    WorkflowsClient getWorkflows();

    /**
     * Gets the WorkflowVersionsClient object to access its operations.
     * 
     * @return the WorkflowVersionsClient object.
     */
    WorkflowVersionsClient getWorkflowVersions();

    /**
     * Gets the ExecutionsClient object to access its operations.
     * 
     * @return the ExecutionsClient object.
     */
    ExecutionsClient getExecutions();

    /**
     * Gets the DiagnosticsClient object to access its operations.
     * 
     * @return the DiagnosticsClient object.
     */
    DiagnosticsClient getDiagnostics();

    /**
     * Gets the ContextsClient object to access its operations.
     * 
     * @return the ContextsClient object.
     */
    ContextsClient getContexts();

    /**
     * Gets the SiteReferencesClient object to access its operations.
     * 
     * @return the SiteReferencesClient object.
     */
    SiteReferencesClient getSiteReferences();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/ConfigTemplateInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.Resource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties;
import java.io.IOException;
import java.util.Map;

/**
 * Config Template Resource. Contains configuration expressions using the predefined expression language.
 */
@Fluent
public final class ConfigTemplateInner extends Resource {
    /*
     * The resource-specific properties for this resource.
     */
    private ConfigTemplateProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of ConfigTemplateInner class.
     */
    public ConfigTemplateInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public ConfigTemplateProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the ConfigTemplateInner object itself.
     */
    public ConfigTemplateInner withProperties(ConfigTemplateProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ConfigTemplateInner withLocation(String location) {
        super.withLocation(location);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ConfigTemplateInner withTags(Map<String, String> tags) {
        super.withTags(tags);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("location", location());
        jsonWriter.writeMapField("tags", tags(), (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ConfigTemplateInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ConfigTemplateInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ConfigTemplateInner.
     */
    public static ConfigTemplateInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ConfigTemplateInner deserializedConfigTemplateInner = new ConfigTemplateInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedConfigTemplateInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedConfigTemplateInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedConfigTemplateInner.type = reader.getString();
                } else if ("location".equals(fieldName)) {
                    deserializedConfigTemplateInner.withLocation(reader.getString());
                } else if ("tags".equals(fieldName)) {
                    Map<String, String> tags = reader.readMap(reader1 -> reader1.getString());
                    deserializedConfigTemplateInner.withTags(tags);
                } else if ("properties".equals(fieldName)) {
                    deserializedConfigTemplateInner.properties = ConfigTemplateProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedConfigTemplateInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedConfigTemplateInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedConfigTemplateInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/ConfigTemplateVersionInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties;
import java.io.IOException;

/**
 * Config Template Version Resource.
 */
@Fluent
public final class ConfigTemplateVersionInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private ConfigTemplateVersionProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of ConfigTemplateVersionInner class.
     */
    public ConfigTemplateVersionInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public ConfigTemplateVersionProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the ConfigTemplateVersionInner object itself.
     */
    public ConfigTemplateVersionInner withProperties(ConfigTemplateVersionProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ConfigTemplateVersionInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ConfigTemplateVersionInner if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ConfigTemplateVersionInner.
     */
    public static ConfigTemplateVersionInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ConfigTemplateVersionInner deserializedConfigTemplateVersionInner = new ConfigTemplateVersionInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedConfigTemplateVersionInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedConfigTemplateVersionInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedConfigTemplateVersionInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedConfigTemplateVersionInner.properties
                        = ConfigTemplateVersionProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedConfigTemplateVersionInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedConfigTemplateVersionInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedConfigTemplateVersionInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/ConfigTemplateVersionWithUpdateTypeInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import java.io.IOException;

/**
 * Config Template Version With Update Type.
 */
@Fluent
public final class ConfigTemplateVersionWithUpdateTypeInner
    implements JsonSerializable<ConfigTemplateVersionWithUpdateTypeInner> {
    /*
     * Update type
     */
    private UpdateType updateType;

    /*
     * Version to create
     */
    private String version;

    /*
     * Config Template Version
     */
    private ConfigTemplateVersionInner configTemplateVersion;

    /**
     * Creates an instance of ConfigTemplateVersionWithUpdateTypeInner class.
     */
    public ConfigTemplateVersionWithUpdateTypeInner() {
    }

    /**
     * Get the updateType property: Update type.
     * 
     * @return the updateType value.
     */
    public UpdateType updateType() {
        return this.updateType;
    }

    /**
     * Set the updateType property: Update type.
     * 
     * @param updateType the updateType value to set.
     * @return the ConfigTemplateVersionWithUpdateTypeInner object itself.
     */
    public ConfigTemplateVersionWithUpdateTypeInner withUpdateType(UpdateType updateType) {
        this.updateType = updateType;
        return this;
    }

    /**
     * Get the version property: Version to create.
     * 
     * @return the version value.
     */
    public String version() {
        return this.version;
    }

    /**
     * Set the version property: Version to create.
     * 
     * @param version the version value to set.
     * @return the ConfigTemplateVersionWithUpdateTypeInner object itself.
     */
    public ConfigTemplateVersionWithUpdateTypeInner withVersion(String version) {
        this.version = version;
        return this;
    }

    /**
     * Get the configTemplateVersion property: Config Template Version.
     * 
     * @return the configTemplateVersion value.
     */
    public ConfigTemplateVersionInner configTemplateVersion() {
        return this.configTemplateVersion;
    }

    /**
     * Set the configTemplateVersion property: Config Template Version.
     * 
     * @param configTemplateVersion the configTemplateVersion value to set.
     * @return the ConfigTemplateVersionWithUpdateTypeInner object itself.
     */
    public ConfigTemplateVersionWithUpdateTypeInner
        withConfigTemplateVersion(ConfigTemplateVersionInner configTemplateVersion) {
        this.configTemplateVersion = configTemplateVersion;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (configTemplateVersion() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property configTemplateVersion in model ConfigTemplateVersionWithUpdateTypeInner"));
        } else {
            configTemplateVersion().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ConfigTemplateVersionWithUpdateTypeInner.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("configTemplateVersion", this.configTemplateVersion);
        jsonWriter.writeStringField("updateType", this.updateType == null ? null : this.updateType.toString());
        jsonWriter.writeStringField("version", this.version);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ConfigTemplateVersionWithUpdateTypeInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ConfigTemplateVersionWithUpdateTypeInner if the JsonReader was pointing to an instance of
     * it, or null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ConfigTemplateVersionWithUpdateTypeInner.
     */
    public static ConfigTemplateVersionWithUpdateTypeInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ConfigTemplateVersionWithUpdateTypeInner deserializedConfigTemplateVersionWithUpdateTypeInner
                = new ConfigTemplateVersionWithUpdateTypeInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("configTemplateVersion".equals(fieldName)) {
                    deserializedConfigTemplateVersionWithUpdateTypeInner.configTemplateVersion
                        = ConfigTemplateVersionInner.fromJson(reader);
                } else if ("updateType".equals(fieldName)) {
                    deserializedConfigTemplateVersionWithUpdateTypeInner.updateType
                        = UpdateType.fromString(reader.getString());
                } else if ("version".equals(fieldName)) {
                    deserializedConfigTemplateVersionWithUpdateTypeInner.version = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedConfigTemplateVersionWithUpdateTypeInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/ContextInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.Resource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ContextProperties;
import java.io.IOException;
import java.util.Map;

/**
 * Context Resource.
 */
@Fluent
public final class ContextInner extends Resource {
    /*
     * The resource-specific properties for this resource.
     */
    private ContextProperties properties;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of ContextInner class.
     */
    public ContextInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public ContextProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the ContextInner object itself.
     */
    public ContextInner withProperties(ContextProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ContextInner withLocation(String location) {
        super.withLocation(location);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ContextInner withTags(Map<String, String> tags) {
        super.withTags(tags);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("location", location());
        jsonWriter.writeMapField("tags", tags(), (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ContextInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ContextInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ContextInner.
     */
    public static ContextInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ContextInner deserializedContextInner = new ContextInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedContextInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedContextInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedContextInner.type = reader.getString();
                } else if ("location".equals(fieldName)) {
                    deserializedContextInner.withLocation(reader.getString());
                } else if ("tags".equals(fieldName)) {
                    Map<String, String> tags = reader.readMap(reader1 -> reader1.getString());
                    deserializedContextInner.withTags(tags);
                } else if ("properties".equals(fieldName)) {
                    deserializedContextInner.properties = ContextProperties.fromJson(reader);
                } else if ("systemData".equals(fieldName)) {
                    deserializedContextInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedContextInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/DiagnosticInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.Resource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import java.io.IOException;
import java.util.Map;

/**
 * A Diagnostic resource.
 */
@Fluent
public final class DiagnosticInner extends Resource {
    /*
     * The resource-specific properties for this resource.
     */
    private DiagnosticProperties properties;

    /*
     * The extendedLocation property.
     */
    private ExtendedLocation extendedLocation;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of DiagnosticInner class.
     */
    public DiagnosticInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public DiagnosticProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the DiagnosticInner object itself.
     */
    public DiagnosticInner withProperties(DiagnosticProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    public ExtendedLocation extendedLocation() {
        return this.extendedLocation;
    }

    /**
     * Set the extendedLocation property: The extendedLocation property.
     * 
     * @param extendedLocation the extendedLocation value to set.
     * @return the DiagnosticInner object itself.
     */
    public DiagnosticInner withExtendedLocation(ExtendedLocation extendedLocation) {
        this.extendedLocation = extendedLocation;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DiagnosticInner withLocation(String location) {
        super.withLocation(location);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DiagnosticInner withTags(Map<String, String> tags) {
        super.withTags(tags);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
        if (extendedLocation() != null) {
            extendedLocation().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("location", location());
        jsonWriter.writeMapField("tags", tags(), (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("properties", this.properties);
        jsonWriter.writeJsonField("extendedLocation", this.extendedLocation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DiagnosticInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DiagnosticInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the DiagnosticInner.
     */
    public static DiagnosticInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DiagnosticInner deserializedDiagnosticInner = new DiagnosticInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedDiagnosticInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedDiagnosticInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedDiagnosticInner.type = reader.getString();
                } else if ("location".equals(fieldName)) {
                    deserializedDiagnosticInner.withLocation(reader.getString());
                } else if ("tags".equals(fieldName)) {
                    Map<String, String> tags = reader.readMap(reader1 -> reader1.getString());
                    deserializedDiagnosticInner.withTags(tags);
                } else if ("properties".equals(fieldName)) {
                    deserializedDiagnosticInner.properties = DiagnosticProperties.fromJson(reader);
                } else if ("extendedLocation".equals(fieldName)) {
                    deserializedDiagnosticInner.extendedLocation = ExtendedLocation.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedDiagnosticInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedDiagnosticInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDiagnosticInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/DynamicSchemaInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties;
import java.io.IOException;

/**
 * DynamicSchema Resource.
 */
@Fluent
public final class DynamicSchemaInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private DynamicSchemaProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of DynamicSchemaInner class.
     */
    public DynamicSchemaInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public DynamicSchemaProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the DynamicSchemaInner object itself.
     */
    public DynamicSchemaInner withProperties(DynamicSchemaProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DynamicSchemaInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DynamicSchemaInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the DynamicSchemaInner.
     */
    public static DynamicSchemaInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DynamicSchemaInner deserializedDynamicSchemaInner = new DynamicSchemaInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedDynamicSchemaInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedDynamicSchemaInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedDynamicSchemaInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedDynamicSchemaInner.properties = DynamicSchemaProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedDynamicSchemaInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedDynamicSchemaInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDynamicSchemaInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/DynamicSchemaVersionInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import java.io.IOException;

/**
 * Dynamic Schema Version Resource.
 */
@Fluent
public final class DynamicSchemaVersionInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private SchemaVersionProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of DynamicSchemaVersionInner class.
     */
    public DynamicSchemaVersionInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public SchemaVersionProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the DynamicSchemaVersionInner object itself.
     */
    public DynamicSchemaVersionInner withProperties(SchemaVersionProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DynamicSchemaVersionInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DynamicSchemaVersionInner if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the DynamicSchemaVersionInner.
     */
    public static DynamicSchemaVersionInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DynamicSchemaVersionInner deserializedDynamicSchemaVersionInner = new DynamicSchemaVersionInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedDynamicSchemaVersionInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedDynamicSchemaVersionInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedDynamicSchemaVersionInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedDynamicSchemaVersionInner.properties = SchemaVersionProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedDynamicSchemaVersionInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedDynamicSchemaVersionInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDynamicSchemaVersionInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/ExecutionInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import java.io.IOException;

/**
 * Execution Resource.
 */
@Fluent
public final class ExecutionInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private ExecutionProperties properties;

    /*
     * The extendedLocation property.
     */
    private ExtendedLocation extendedLocation;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of ExecutionInner class.
     */
    public ExecutionInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public ExecutionProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the ExecutionInner object itself.
     */
    public ExecutionInner withProperties(ExecutionProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    public ExtendedLocation extendedLocation() {
        return this.extendedLocation;
    }

    /**
     * Set the extendedLocation property: The extendedLocation property.
     * 
     * @param extendedLocation the extendedLocation value to set.
     * @return the ExecutionInner object itself.
     */
    public ExecutionInner withExtendedLocation(ExtendedLocation extendedLocation) {
        this.extendedLocation = extendedLocation;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
        if (extendedLocation() != null) {
            extendedLocation().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        jsonWriter.writeJsonField("extendedLocation", this.extendedLocation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ExecutionInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ExecutionInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ExecutionInner.
     */
    public static ExecutionInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ExecutionInner deserializedExecutionInner = new ExecutionInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedExecutionInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedExecutionInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedExecutionInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedExecutionInner.properties = ExecutionProperties.fromJson(reader);
                } else if ("extendedLocation".equals(fieldName)) {
                    deserializedExecutionInner.extendedLocation = ExtendedLocation.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedExecutionInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedExecutionInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedExecutionInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/InstanceHistoryInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.InstanceHistoryProperties;
import java.io.IOException;

/**
 * InstanceHistory Resource.
 */
@Immutable
public final class InstanceHistoryInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private InstanceHistoryProperties properties;

    /*
     * The extendedLocation property.
     */
    private ExtendedLocation extendedLocation;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of InstanceHistoryInner class.
     */
    private InstanceHistoryInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public InstanceHistoryProperties properties() {
        return this.properties;
    }

    /**
     * Get the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    public ExtendedLocation extendedLocation() {
        return this.extendedLocation;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
        if (extendedLocation() != null) {
            extendedLocation().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        jsonWriter.writeJsonField("extendedLocation", this.extendedLocation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of InstanceHistoryInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of InstanceHistoryInner if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the InstanceHistoryInner.
     */
    public static InstanceHistoryInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            InstanceHistoryInner deserializedInstanceHistoryInner = new InstanceHistoryInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedInstanceHistoryInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedInstanceHistoryInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedInstanceHistoryInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedInstanceHistoryInner.properties = InstanceHistoryProperties.fromJson(reader);
                } else if ("extendedLocation".equals(fieldName)) {
                    deserializedInstanceHistoryInner.extendedLocation = ExtendedLocation.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedInstanceHistoryInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedInstanceHistoryInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedInstanceHistoryInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/InstanceInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.InstanceProperties;
import java.io.IOException;

/**
 * Instance Resource. Represents a deployment object.
 */
@Fluent
public final class InstanceInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private InstanceProperties properties;

    /*
     * The extendedLocation property.
     */
    private ExtendedLocation extendedLocation;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of InstanceInner class.
     */
    public InstanceInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public InstanceProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the InstanceInner object itself.
     */
    public InstanceInner withProperties(InstanceProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    public ExtendedLocation extendedLocation() {
        return this.extendedLocation;
    }

    /**
     * Set the extendedLocation property: The extendedLocation property.
     * 
     * @param extendedLocation the extendedLocation value to set.
     * @return the InstanceInner object itself.
     */
    public InstanceInner withExtendedLocation(ExtendedLocation extendedLocation) {
        this.extendedLocation = extendedLocation;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
        if (extendedLocation() != null) {
            extendedLocation().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        jsonWriter.writeJsonField("extendedLocation", this.extendedLocation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of InstanceInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of InstanceInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the InstanceInner.
     */
    public static InstanceInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            InstanceInner deserializedInstanceInner = new InstanceInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedInstanceInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedInstanceInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedInstanceInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedInstanceInner.properties = InstanceProperties.fromJson(reader);
                } else if ("extendedLocation".equals(fieldName)) {
                    deserializedInstanceInner.extendedLocation = ExtendedLocation.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedInstanceInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedInstanceInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedInstanceInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/JobInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.JobProperties;
import java.io.IOException;

/**
 * Job extension resource for tracking job execution and substatuses.
 */
@Immutable
public final class JobInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private JobProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of JobInner class.
     */
    private JobInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public JobProperties properties() {
        return this.properties;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of JobInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of JobInner if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the JobInner.
     */
    public static JobInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            JobInner deserializedJobInner = new JobInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedJobInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedJobInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedJobInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedJobInner.properties = JobProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedJobInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedJobInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedJobInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/package-info.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

/**
 * Package containing the inner data models for WorkloadOrchestration.
 * Microsoft.Edge Resource Provider management API.
 */
package com.azure.resourcemanager.workloadorchestration.fluent.models;



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/RemoveVersionResponseInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Remove Version response.
 */
@Immutable
public final class RemoveVersionResponseInner implements JsonSerializable<RemoveVersionResponseInner> {
    /*
     * Status for remove version response
     */
    private String status;

    /**
     * Creates an instance of RemoveVersionResponseInner class.
     */
    private RemoveVersionResponseInner() {
    }

    /**
     * Get the status property: Status for remove version response.
     * 
     * @return the status value.
     */
    public String status() {
        return this.status;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (status() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property status in model RemoveVersionResponseInner"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(RemoveVersionResponseInner.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("status", this.status);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of RemoveVersionResponseInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of RemoveVersionResponseInner if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the RemoveVersionResponseInner.
     */
    public static RemoveVersionResponseInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            RemoveVersionResponseInner deserializedRemoveVersionResponseInner = new RemoveVersionResponseInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("status".equals(fieldName)) {
                    deserializedRemoveVersionResponseInner.status = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedRemoveVersionResponseInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/ResolvedConfigurationInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Resolved Configuration.
 */
@Immutable
public final class ResolvedConfigurationInner implements JsonSerializable<ResolvedConfigurationInner> {
    /*
     * Resolved Configuration as string
     */
    private String configuration;

    /**
     * Creates an instance of ResolvedConfigurationInner class.
     */
    private ResolvedConfigurationInner() {
    }

    /**
     * Get the configuration property: Resolved Configuration as string.
     * 
     * @return the configuration value.
     */
    public String configuration() {
        return this.configuration;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (configuration() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property configuration in model ResolvedConfigurationInner"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ResolvedConfigurationInner.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("configuration", this.configuration);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ResolvedConfigurationInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ResolvedConfigurationInner if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ResolvedConfigurationInner.
     */
    public static ResolvedConfigurationInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ResolvedConfigurationInner deserializedResolvedConfigurationInner = new ResolvedConfigurationInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("configuration".equals(fieldName)) {
                    deserializedResolvedConfigurationInner.configuration = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedResolvedConfigurationInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SchemaInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.Resource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.SchemaProperties;
import java.io.IOException;
import java.util.Map;

/**
 * Schema Resource.
 */
@Fluent
public final class SchemaInner extends Resource {
    /*
     * The resource-specific properties for this resource.
     */
    private SchemaProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of SchemaInner class.
     */
    public SchemaInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public SchemaProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the SchemaInner object itself.
     */
    public SchemaInner withProperties(SchemaProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SchemaInner withLocation(String location) {
        super.withLocation(location);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SchemaInner withTags(Map<String, String> tags) {
        super.withTags(tags);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("location", location());
        jsonWriter.writeMapField("tags", tags(), (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaInner.
     */
    public static SchemaInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaInner deserializedSchemaInner = new SchemaInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedSchemaInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedSchemaInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedSchemaInner.type = reader.getString();
                } else if ("location".equals(fieldName)) {
                    deserializedSchemaInner.withLocation(reader.getString());
                } else if ("tags".equals(fieldName)) {
                    Map<String, String> tags = reader.readMap(reader1 -> reader1.getString());
                    deserializedSchemaInner.withTags(tags);
                } else if ("properties".equals(fieldName)) {
                    deserializedSchemaInner.properties = SchemaProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedSchemaInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedSchemaInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SchemaReferenceInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.SchemaReferenceProperties;
import java.io.IOException;

/**
 * Schema Reference Resource.
 */
@Immutable
public final class SchemaReferenceInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private SchemaReferenceProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of SchemaReferenceInner class.
     */
    private SchemaReferenceInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public SchemaReferenceProperties properties() {
        return this.properties;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaReferenceInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaReferenceInner if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaReferenceInner.
     */
    public static SchemaReferenceInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaReferenceInner deserializedSchemaReferenceInner = new SchemaReferenceInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedSchemaReferenceInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedSchemaReferenceInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedSchemaReferenceInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedSchemaReferenceInner.properties = SchemaReferenceProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedSchemaReferenceInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedSchemaReferenceInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaReferenceInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SchemaVersionInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import java.io.IOException;

/**
 * Schema Version Resource.
 */
@Fluent
public final class SchemaVersionInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private SchemaVersionProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of SchemaVersionInner class.
     */
    public SchemaVersionInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public SchemaVersionProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the SchemaVersionInner object itself.
     */
    public SchemaVersionInner withProperties(SchemaVersionProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaVersionInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaVersionInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaVersionInner.
     */
    public static SchemaVersionInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaVersionInner deserializedSchemaVersionInner = new SchemaVersionInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedSchemaVersionInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedSchemaVersionInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedSchemaVersionInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedSchemaVersionInner.properties = SchemaVersionProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedSchemaVersionInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedSchemaVersionInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaVersionInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SchemaVersionWithUpdateTypeInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import java.io.IOException;

/**
 * Schema Version With Update Type.
 */
@Fluent
public final class SchemaVersionWithUpdateTypeInner implements JsonSerializable<SchemaVersionWithUpdateTypeInner> {
    /*
     * Update type
     */
    private UpdateType updateType;

    /*
     * Version to create
     */
    private String version;

    /*
     * Schema Version
     */
    private SchemaVersionInner schemaVersion;

    /**
     * Creates an instance of SchemaVersionWithUpdateTypeInner class.
     */
    public SchemaVersionWithUpdateTypeInner() {
    }

    /**
     * Get the updateType property: Update type.
     * 
     * @return the updateType value.
     */
    public UpdateType updateType() {
        return this.updateType;
    }

    /**
     * Set the updateType property: Update type.
     * 
     * @param updateType the updateType value to set.
     * @return the SchemaVersionWithUpdateTypeInner object itself.
     */
    public SchemaVersionWithUpdateTypeInner withUpdateType(UpdateType updateType) {
        this.updateType = updateType;
        return this;
    }

    /**
     * Get the version property: Version to create.
     * 
     * @return the version value.
     */
    public String version() {
        return this.version;
    }

    /**
     * Set the version property: Version to create.
     * 
     * @param version the version value to set.
     * @return the SchemaVersionWithUpdateTypeInner object itself.
     */
    public SchemaVersionWithUpdateTypeInner withVersion(String version) {
        this.version = version;
        return this;
    }

    /**
     * Get the schemaVersion property: Schema Version.
     * 
     * @return the schemaVersion value.
     */
    public SchemaVersionInner schemaVersion() {
        return this.schemaVersion;
    }

    /**
     * Set the schemaVersion property: Schema Version.
     * 
     * @param schemaVersion the schemaVersion value to set.
     * @return the SchemaVersionWithUpdateTypeInner object itself.
     */
    public SchemaVersionWithUpdateTypeInner withSchemaVersion(SchemaVersionInner schemaVersion) {
        this.schemaVersion = schemaVersion;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (schemaVersion() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property schemaVersion in model SchemaVersionWithUpdateTypeInner"));
        } else {
            schemaVersion().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemaVersionWithUpdateTypeInner.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("schemaVersion", this.schemaVersion);
        jsonWriter.writeStringField("updateType", this.updateType == null ? null : this.updateType.toString());
        jsonWriter.writeStringField("version", this.version);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaVersionWithUpdateTypeInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaVersionWithUpdateTypeInner if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaVersionWithUpdateTypeInner.
     */
    public static SchemaVersionWithUpdateTypeInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaVersionWithUpdateTypeInner deserializedSchemaVersionWithUpdateTypeInner
                = new SchemaVersionWithUpdateTypeInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("schemaVersion".equals(fieldName)) {
                    deserializedSchemaVersionWithUpdateTypeInner.schemaVersion = SchemaVersionInner.fromJson(reader);
                } else if ("updateType".equals(fieldName)) {
                    deserializedSchemaVersionWithUpdateTypeInner.updateType = UpdateType.fromString(reader.getString());
                } else if ("version".equals(fieldName)) {
                    deserializedSchemaVersionWithUpdateTypeInner.version = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaVersionWithUpdateTypeInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SiteReferenceInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties;
import java.io.IOException;

/**
 * Site Reference Resource.
 */
@Fluent
public final class SiteReferenceInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private SiteReferenceProperties properties;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of SiteReferenceInner class.
     */
    public SiteReferenceInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public SiteReferenceProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the SiteReferenceInner object itself.
     */
    public SiteReferenceInner withProperties(SiteReferenceProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SiteReferenceInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SiteReferenceInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SiteReferenceInner.
     */
    public static SiteReferenceInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SiteReferenceInner deserializedSiteReferenceInner = new SiteReferenceInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedSiteReferenceInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedSiteReferenceInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedSiteReferenceInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedSiteReferenceInner.properties = SiteReferenceProperties.fromJson(reader);
                } else if ("systemData".equals(fieldName)) {
                    deserializedSiteReferenceInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSiteReferenceInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SolutionInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.SolutionProperties;
import java.io.IOException;

/**
 * Solution Resource attached to a Target.
 */
@Fluent
public final class SolutionInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private SolutionProperties properties;

    /*
     * The extendedLocation property.
     */
    private ExtendedLocation extendedLocation;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of SolutionInner class.
     */
    public SolutionInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public SolutionProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the SolutionInner object itself.
     */
    public SolutionInner withProperties(SolutionProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    public ExtendedLocation extendedLocation() {
        return this.extendedLocation;
    }

    /**
     * Set the extendedLocation property: The extendedLocation property.
     * 
     * @param extendedLocation the extendedLocation value to set.
     * @return the SolutionInner object itself.
     */
    public SolutionInner withExtendedLocation(ExtendedLocation extendedLocation) {
        this.extendedLocation = extendedLocation;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
        if (extendedLocation() != null) {
            extendedLocation().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        jsonWriter.writeJsonField("extendedLocation", this.extendedLocation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionInner.
     */
    public static SolutionInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionInner deserializedSolutionInner = new SolutionInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedSolutionInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedSolutionInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedSolutionInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedSolutionInner.properties = SolutionProperties.fromJson(reader);
                } else if ("extendedLocation".equals(fieldName)) {
                    deserializedSolutionInner.extendedLocation = ExtendedLocation.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedSolutionInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedSolutionInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SolutionTemplateInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.Resource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties;
import java.io.IOException;
import java.util.Map;

/**
 * Solution Template Resource. Contains capabilities and operations for creating versions.
 */
@Fluent
public final class SolutionTemplateInner extends Resource {
    /*
     * The resource-specific properties for this resource.
     */
    private SolutionTemplateProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of SolutionTemplateInner class.
     */
    public SolutionTemplateInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public SolutionTemplateProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the SolutionTemplateInner object itself.
     */
    public SolutionTemplateInner withProperties(SolutionTemplateProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SolutionTemplateInner withLocation(String location) {
        super.withLocation(location);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SolutionTemplateInner withTags(Map<String, String> tags) {
        super.withTags(tags);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("location", location());
        jsonWriter.writeMapField("tags", tags(), (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionTemplateInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionTemplateInner if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionTemplateInner.
     */
    public static SolutionTemplateInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionTemplateInner deserializedSolutionTemplateInner = new SolutionTemplateInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedSolutionTemplateInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedSolutionTemplateInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedSolutionTemplateInner.type = reader.getString();
                } else if ("location".equals(fieldName)) {
                    deserializedSolutionTemplateInner.withLocation(reader.getString());
                } else if ("tags".equals(fieldName)) {
                    Map<String, String> tags = reader.readMap(reader1 -> reader1.getString());
                    deserializedSolutionTemplateInner.withTags(tags);
                } else if ("properties".equals(fieldName)) {
                    deserializedSolutionTemplateInner.properties = SolutionTemplateProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedSolutionTemplateInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedSolutionTemplateInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionTemplateInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SolutionTemplateVersionInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties;
import java.io.IOException;

/**
 * Solution Template Version Resource. Contains configurations that use expressions which can be resolved hierarchically
 * along with edge specifications.
 */
@Fluent
public final class SolutionTemplateVersionInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private SolutionTemplateVersionProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of SolutionTemplateVersionInner class.
     */
    public SolutionTemplateVersionInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public SolutionTemplateVersionProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the SolutionTemplateVersionInner object itself.
     */
    public SolutionTemplateVersionInner withProperties(SolutionTemplateVersionProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionTemplateVersionInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionTemplateVersionInner if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionTemplateVersionInner.
     */
    public static SolutionTemplateVersionInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionTemplateVersionInner deserializedSolutionTemplateVersionInner = new SolutionTemplateVersionInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedSolutionTemplateVersionInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedSolutionTemplateVersionInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedSolutionTemplateVersionInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedSolutionTemplateVersionInner.properties
                        = SolutionTemplateVersionProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedSolutionTemplateVersionInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedSolutionTemplateVersionInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionTemplateVersionInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SolutionTemplateVersionWithUpdateTypeInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import java.io.IOException;

/**
 * Solution Template Version With Update Type.
 */
@Fluent
public final class SolutionTemplateVersionWithUpdateTypeInner
    implements JsonSerializable<SolutionTemplateVersionWithUpdateTypeInner> {
    /*
     * Update type
     */
    private UpdateType updateType;

    /*
     * Version to create
     */
    private String version;

    /*
     * Solution Template Version
     */
    private SolutionTemplateVersionInner solutionTemplateVersion;

    /**
     * Creates an instance of SolutionTemplateVersionWithUpdateTypeInner class.
     */
    public SolutionTemplateVersionWithUpdateTypeInner() {
    }

    /**
     * Get the updateType property: Update type.
     * 
     * @return the updateType value.
     */
    public UpdateType updateType() {
        return this.updateType;
    }

    /**
     * Set the updateType property: Update type.
     * 
     * @param updateType the updateType value to set.
     * @return the SolutionTemplateVersionWithUpdateTypeInner object itself.
     */
    public SolutionTemplateVersionWithUpdateTypeInner withUpdateType(UpdateType updateType) {
        this.updateType = updateType;
        return this;
    }

    /**
     * Get the version property: Version to create.
     * 
     * @return the version value.
     */
    public String version() {
        return this.version;
    }

    /**
     * Set the version property: Version to create.
     * 
     * @param version the version value to set.
     * @return the SolutionTemplateVersionWithUpdateTypeInner object itself.
     */
    public SolutionTemplateVersionWithUpdateTypeInner withVersion(String version) {
        this.version = version;
        return this;
    }

    /**
     * Get the solutionTemplateVersion property: Solution Template Version.
     * 
     * @return the solutionTemplateVersion value.
     */
    public SolutionTemplateVersionInner solutionTemplateVersion() {
        return this.solutionTemplateVersion;
    }

    /**
     * Set the solutionTemplateVersion property: Solution Template Version.
     * 
     * @param solutionTemplateVersion the solutionTemplateVersion value to set.
     * @return the SolutionTemplateVersionWithUpdateTypeInner object itself.
     */
    public SolutionTemplateVersionWithUpdateTypeInner
        withSolutionTemplateVersion(SolutionTemplateVersionInner solutionTemplateVersion) {
        this.solutionTemplateVersion = solutionTemplateVersion;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionTemplateVersion() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionTemplateVersion in model SolutionTemplateVersionWithUpdateTypeInner"));
        } else {
            solutionTemplateVersion().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplateVersionWithUpdateTypeInner.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("solutionTemplateVersion", this.solutionTemplateVersion);
        jsonWriter.writeStringField("updateType", this.updateType == null ? null : this.updateType.toString());
        jsonWriter.writeStringField("version", this.version);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionTemplateVersionWithUpdateTypeInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionTemplateVersionWithUpdateTypeInner if the JsonReader was pointing to an instance
     * of it, or null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionTemplateVersionWithUpdateTypeInner.
     */
    public static SolutionTemplateVersionWithUpdateTypeInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionTemplateVersionWithUpdateTypeInner deserializedSolutionTemplateVersionWithUpdateTypeInner
                = new SolutionTemplateVersionWithUpdateTypeInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionTemplateVersion".equals(fieldName)) {
                    deserializedSolutionTemplateVersionWithUpdateTypeInner.solutionTemplateVersion
                        = SolutionTemplateVersionInner.fromJson(reader);
                } else if ("updateType".equals(fieldName)) {
                    deserializedSolutionTemplateVersionWithUpdateTypeInner.updateType
                        = UpdateType.fromString(reader.getString());
                } else if ("version".equals(fieldName)) {
                    deserializedSolutionTemplateVersionWithUpdateTypeInner.version = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionTemplateVersionWithUpdateTypeInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/SolutionVersionInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionProperties;
import java.io.IOException;

/**
 * Solution Version Resource. It has the resolved configuration along with edge specification.
 */
@Fluent
public final class SolutionVersionInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private SolutionVersionProperties properties;

    /*
     * The extendedLocation property.
     */
    private ExtendedLocation extendedLocation;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of SolutionVersionInner class.
     */
    public SolutionVersionInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public SolutionVersionProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the SolutionVersionInner object itself.
     */
    public SolutionVersionInner withProperties(SolutionVersionProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    public ExtendedLocation extendedLocation() {
        return this.extendedLocation;
    }

    /**
     * Set the extendedLocation property: The extendedLocation property.
     * 
     * @param extendedLocation the extendedLocation value to set.
     * @return the SolutionVersionInner object itself.
     */
    public SolutionVersionInner withExtendedLocation(ExtendedLocation extendedLocation) {
        this.extendedLocation = extendedLocation;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
        if (extendedLocation() != null) {
            extendedLocation().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        jsonWriter.writeJsonField("extendedLocation", this.extendedLocation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionVersionInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionVersionInner if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionVersionInner.
     */
    public static SolutionVersionInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionVersionInner deserializedSolutionVersionInner = new SolutionVersionInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedSolutionVersionInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedSolutionVersionInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedSolutionVersionInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedSolutionVersionInner.properties = SolutionVersionProperties.fromJson(reader);
                } else if ("extendedLocation".equals(fieldName)) {
                    deserializedSolutionVersionInner.extendedLocation = ExtendedLocation.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedSolutionVersionInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedSolutionVersionInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionVersionInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/TargetInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.Resource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.TargetProperties;
import java.io.IOException;
import java.util.Map;

/**
 * Target Resource. Represents a resource to be deployed on the edge.
 */
@Fluent
public final class TargetInner extends Resource {
    /*
     * The resource-specific properties for this resource.
     */
    private TargetProperties properties;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * The extendedLocation property.
     */
    private ExtendedLocation extendedLocation;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of TargetInner class.
     */
    public TargetInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public TargetProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the TargetInner object itself.
     */
    public TargetInner withProperties(TargetProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    public ExtendedLocation extendedLocation() {
        return this.extendedLocation;
    }

    /**
     * Set the extendedLocation property: The extendedLocation property.
     * 
     * @param extendedLocation the extendedLocation value to set.
     * @return the TargetInner object itself.
     */
    public TargetInner withExtendedLocation(ExtendedLocation extendedLocation) {
        this.extendedLocation = extendedLocation;
        return this;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public TargetInner withLocation(String location) {
        super.withLocation(location);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public TargetInner withTags(Map<String, String> tags) {
        super.withTags(tags);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
        if (extendedLocation() != null) {
            extendedLocation().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("location", location());
        jsonWriter.writeMapField("tags", tags(), (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("properties", this.properties);
        jsonWriter.writeJsonField("extendedLocation", this.extendedLocation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TargetInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TargetInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TargetInner.
     */
    public static TargetInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TargetInner deserializedTargetInner = new TargetInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedTargetInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedTargetInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedTargetInner.type = reader.getString();
                } else if ("location".equals(fieldName)) {
                    deserializedTargetInner.withLocation(reader.getString());
                } else if ("tags".equals(fieldName)) {
                    Map<String, String> tags = reader.readMap(reader1 -> reader1.getString());
                    deserializedTargetInner.withTags(tags);
                } else if ("properties".equals(fieldName)) {
                    deserializedTargetInner.properties = TargetProperties.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedTargetInner.eTag = reader.getString();
                } else if ("extendedLocation".equals(fieldName)) {
                    deserializedTargetInner.extendedLocation = ExtendedLocation.fromJson(reader);
                } else if ("systemData".equals(fieldName)) {
                    deserializedTargetInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTargetInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/WorkflowInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties;
import java.io.IOException;

/**
 * Workflow Resource.
 */
@Fluent
public final class WorkflowInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private WorkflowProperties properties;

    /*
     * The extendedLocation property.
     */
    private ExtendedLocation extendedLocation;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of WorkflowInner class.
     */
    public WorkflowInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public WorkflowProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the WorkflowInner object itself.
     */
    public WorkflowInner withProperties(WorkflowProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    public ExtendedLocation extendedLocation() {
        return this.extendedLocation;
    }

    /**
     * Set the extendedLocation property: The extendedLocation property.
     * 
     * @param extendedLocation the extendedLocation value to set.
     * @return the WorkflowInner object itself.
     */
    public WorkflowInner withExtendedLocation(ExtendedLocation extendedLocation) {
        this.extendedLocation = extendedLocation;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
        if (extendedLocation() != null) {
            extendedLocation().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        jsonWriter.writeJsonField("extendedLocation", this.extendedLocation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of WorkflowInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of WorkflowInner if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the WorkflowInner.
     */
    public static WorkflowInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            WorkflowInner deserializedWorkflowInner = new WorkflowInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedWorkflowInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedWorkflowInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedWorkflowInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedWorkflowInner.properties = WorkflowProperties.fromJson(reader);
                } else if ("extendedLocation".equals(fieldName)) {
                    deserializedWorkflowInner.extendedLocation = ExtendedLocation.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedWorkflowInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedWorkflowInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedWorkflowInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/fluent/models/WorkflowVersionInner.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.fluent.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.ProxyResource;
import com.azure.core.management.SystemData;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties;
import java.io.IOException;

/**
 * Workflow Version Resource.
 */
@Fluent
public final class WorkflowVersionInner extends ProxyResource {
    /*
     * The resource-specific properties for this resource.
     */
    private WorkflowVersionProperties properties;

    /*
     * The extendedLocation property.
     */
    private ExtendedLocation extendedLocation;

    /*
     * If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
     * Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity
     * tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section
     * 14.27) header fields.
     */
    private String eTag;

    /*
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    private SystemData systemData;

    /*
     * The type of the resource.
     */
    private String type;

    /*
     * The name of the resource.
     */
    private String name;

    /*
     * Fully qualified resource Id for the resource.
     */
    private String id;

    /**
     * Creates an instance of WorkflowVersionInner class.
     */
    public WorkflowVersionInner() {
    }

    /**
     * Get the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    public WorkflowVersionProperties properties() {
        return this.properties;
    }

    /**
     * Set the properties property: The resource-specific properties for this resource.
     * 
     * @param properties the properties value to set.
     * @return the WorkflowVersionInner object itself.
     */
    public WorkflowVersionInner withProperties(WorkflowVersionProperties properties) {
        this.properties = properties;
        return this;
    }

    /**
     * Get the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    public ExtendedLocation extendedLocation() {
        return this.extendedLocation;
    }

    /**
     * Set the extendedLocation property: The extendedLocation property.
     * 
     * @param extendedLocation the extendedLocation value to set.
     * @return the WorkflowVersionInner object itself.
     */
    public WorkflowVersionInner withExtendedLocation(ExtendedLocation extendedLocation) {
        this.extendedLocation = extendedLocation;
        return this;
    }

    /**
     * Get the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    public String eTag() {
        return this.eTag;
    }

    /**
     * Get the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    public SystemData systemData() {
        return this.systemData;
    }

    /**
     * Get the type property: The type of the resource.
     * 
     * @return the type value.
     */
    @Override
    public String type() {
        return this.type;
    }

    /**
     * Get the name property: The name of the resource.
     * 
     * @return the name value.
     */
    @Override
    public String name() {
        return this.name;
    }

    /**
     * Get the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    @Override
    public String id() {
        return this.id;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (properties() != null) {
            properties().validate();
        }
        if (extendedLocation() != null) {
            extendedLocation().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("properties", this.properties);
        jsonWriter.writeJsonField("extendedLocation", this.extendedLocation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of WorkflowVersionInner from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of WorkflowVersionInner if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the WorkflowVersionInner.
     */
    public static WorkflowVersionInner fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            WorkflowVersionInner deserializedWorkflowVersionInner = new WorkflowVersionInner();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("id".equals(fieldName)) {
                    deserializedWorkflowVersionInner.id = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedWorkflowVersionInner.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedWorkflowVersionInner.type = reader.getString();
                } else if ("properties".equals(fieldName)) {
                    deserializedWorkflowVersionInner.properties = WorkflowVersionProperties.fromJson(reader);
                } else if ("extendedLocation".equals(fieldName)) {
                    deserializedWorkflowVersionInner.extendedLocation = ExtendedLocation.fromJson(reader);
                } else if ("eTag".equals(fieldName)) {
                    deserializedWorkflowVersionInner.eTag = reader.getString();
                } else if ("systemData".equals(fieldName)) {
                    deserializedWorkflowVersionInner.systemData = SystemData.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedWorkflowVersionInner;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ConfigTemplateImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.Response;
import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplate;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.RemoveVersionResponse;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;
import java.util.Collections;
import java.util.Map;

public final class ConfigTemplateImpl implements ConfigTemplate, ConfigTemplate.Definition, ConfigTemplate.Update {
    private ConfigTemplateInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public String location() {
        return this.innerModel().location();
    }

    public Map<String, String> tags() {
        Map<String, String> inner = this.innerModel().tags();
        if (inner != null) {
            return Collections.unmodifiableMap(inner);
        } else {
            return Collections.emptyMap();
        }
    }

    public ConfigTemplateProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public Region region() {
        return Region.fromName(this.regionName());
    }

    public String regionName() {
        return this.location();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public ConfigTemplateInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String configTemplateName;

    public ConfigTemplateImpl withExistingResourceGroup(String resourceGroupName) {
        this.resourceGroupName = resourceGroupName;
        return this;
    }

    public ConfigTemplate create() {
        this.innerObject = serviceManager.serviceClient()
            .getConfigTemplates()
            .createOrUpdate(resourceGroupName, configTemplateName, this.innerModel(), Context.NONE);
        return this;
    }

    public ConfigTemplate create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getConfigTemplates()
            .createOrUpdate(resourceGroupName, configTemplateName, this.innerModel(), context);
        return this;
    }

    ConfigTemplateImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new ConfigTemplateInner();
        this.serviceManager = serviceManager;
        this.configTemplateName = name;
    }

    public ConfigTemplateImpl update() {
        return this;
    }

    public ConfigTemplate apply() {
        this.innerObject = serviceManager.serviceClient()
            .getConfigTemplates()
            .updateWithResponse(resourceGroupName, configTemplateName, this.innerModel(), Context.NONE)
            .getValue();
        return this;
    }

    public ConfigTemplate apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getConfigTemplates()
            .updateWithResponse(resourceGroupName, configTemplateName, this.innerModel(), context)
            .getValue();
        return this;
    }

    ConfigTemplateImpl(ConfigTemplateInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.configTemplateName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "configTemplates");
    }

    public ConfigTemplate refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getConfigTemplates()
            .getByResourceGroupWithResponse(resourceGroupName, configTemplateName, Context.NONE)
            .getValue();
        return this;
    }

    public ConfigTemplate refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getConfigTemplates()
            .getByResourceGroupWithResponse(resourceGroupName, configTemplateName, context)
            .getValue();
        return this;
    }

    public ConfigTemplateVersion createVersion(ConfigTemplateVersionWithUpdateTypeInner body) {
        return serviceManager.configTemplates().createVersion(resourceGroupName, configTemplateName, body);
    }

    public ConfigTemplateVersion createVersion(ConfigTemplateVersionWithUpdateTypeInner body, Context context) {
        return serviceManager.configTemplates().createVersion(resourceGroupName, configTemplateName, body, context);
    }

    public Response<RemoveVersionResponse> removeVersionWithResponse(VersionParameter body, Context context) {
        return serviceManager.configTemplates()
            .removeVersionWithResponse(resourceGroupName, configTemplateName, body, context);
    }

    public RemoveVersionResponse removeVersion(VersionParameter body) {
        return serviceManager.configTemplates().removeVersion(resourceGroupName, configTemplateName, body);
    }

    public ConfigTemplateImpl withRegion(Region location) {
        this.innerModel().withLocation(location.toString());
        return this;
    }

    public ConfigTemplateImpl withRegion(String location) {
        this.innerModel().withLocation(location);
        return this;
    }

    public ConfigTemplateImpl withTags(Map<String, String> tags) {
        this.innerModel().withTags(tags);
        return this;
    }

    public ConfigTemplateImpl withProperties(ConfigTemplateProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ConfigTemplatesClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.ConfigTemplateListResult;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in ConfigTemplatesClient.
 */
public final class ConfigTemplatesClientImpl implements ConfigTemplatesClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final ConfigTemplatesService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of ConfigTemplatesClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    ConfigTemplatesClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(ConfigTemplatesService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientConfigTemplates to be used by
     * the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientConfigTemplates")
    public interface ConfigTemplatesService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ConfigTemplateInner>> getByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ConfigTemplateInner> getByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Accept") String accept,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") ConfigTemplateInner resource,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") ConfigTemplateInner resource,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ConfigTemplateInner>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") ConfigTemplateInner properties,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ConfigTemplateInner> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") ConfigTemplateInner properties,
            Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/createVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createVersion(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept,
            @BodyParam("application/json") ConfigTemplateVersionWithUpdateTypeInner body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/createVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createVersionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept,
            @BodyParam("application/json") ConfigTemplateVersionWithUpdateTypeInner body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/removeVersion")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<RemoveVersionResponseInner>> removeVersion(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") VersionParameter body,
            Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/removeVersion")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<RemoveVersionResponseInner> removeVersionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") VersionParameter body,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ConfigTemplateListResult>> listByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ConfigTemplateListResult> listByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/configTemplates")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ConfigTemplateListResult>> list(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/configTemplates")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ConfigTemplateListResult> listSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ConfigTemplateListResult>> listByResourceGroupNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ConfigTemplateListResult> listByResourceGroupNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ConfigTemplateListResult>> listBySubscriptionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ConfigTemplateListResult> listBySubscriptionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<ConfigTemplateInner>> getByResourceGroupWithResponseAsync(String resourceGroupName,
        String configTemplateName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ConfigTemplateInner> getByResourceGroupAsync(String resourceGroupName, String configTemplateName) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, configTemplateName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ConfigTemplateInner> getByResourceGroupWithResponse(String resourceGroupName,
        String configTemplateName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getByResourceGroupSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, configTemplateName, accept, context);
    }

    /**
     * Get a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ConfigTemplateInner getByResourceGroup(String resourceGroupName, String configTemplateName) {
        return getByResourceGroupWithResponse(resourceGroupName, configTemplateName, Context.NONE).getValue();
    }

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String configTemplateName, ConfigTemplateInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, resource,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, resource,
            Context.NONE);
    }

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, resource,
            context);
    }

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<ConfigTemplateInner>, ConfigTemplateInner>
        beginCreateOrUpdateAsync(String resourceGroupName, String configTemplateName, ConfigTemplateInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, configTemplateName, resource);
        return this.client.<ConfigTemplateInner, ConfigTemplateInner>getLroResult(mono, this.client.getHttpPipeline(),
            ConfigTemplateInner.class, ConfigTemplateInner.class, this.client.getContext());
    }

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ConfigTemplateInner>, ConfigTemplateInner>
        beginCreateOrUpdate(String resourceGroupName, String configTemplateName, ConfigTemplateInner resource) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, configTemplateName, resource);
        return this.client.<ConfigTemplateInner, ConfigTemplateInner>getLroResult(response, ConfigTemplateInner.class,
            ConfigTemplateInner.class, Context.NONE);
    }

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ConfigTemplateInner>, ConfigTemplateInner> beginCreateOrUpdate(
        String resourceGroupName, String configTemplateName, ConfigTemplateInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, configTemplateName, resource, context);
        return this.client.<ConfigTemplateInner, ConfigTemplateInner>getLroResult(response, ConfigTemplateInner.class,
            ConfigTemplateInner.class, context);
    }

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ConfigTemplateInner> createOrUpdateAsync(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, configTemplateName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ConfigTemplateInner createOrUpdate(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner resource) {
        return beginCreateOrUpdate(resourceGroupName, configTemplateName, resource).getFinalResult();
    }

    /**
     * Create or update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ConfigTemplateInner createOrUpdate(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, configTemplateName, resource, context).getFinalResult();
    }

    /**
     * update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<ConfigTemplateInner>> updateWithResponseAsync(String resourceGroupName,
        String configTemplateName, ConfigTemplateInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, properties,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ConfigTemplateInner> updateAsync(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner properties) {
        return updateWithResponseAsync(resourceGroupName, configTemplateName, properties)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ConfigTemplateInner> updateWithResponse(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, properties,
            context);
    }

    /**
     * update a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return config Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ConfigTemplateInner update(String resourceGroupName, String configTemplateName,
        ConfigTemplateInner properties) {
        return updateWithResponse(resourceGroupName, configTemplateName, properties, Context.NONE).getValue();
    }

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createVersionWithResponseAsync(String resourceGroupName,
        String configTemplateName, ConfigTemplateVersionWithUpdateTypeInner body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createVersion(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, body,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createVersionWithResponse(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, body,
            Context.NONE);
    }

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createVersionWithResponse(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, body, context);
    }

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<ConfigTemplateVersionInner>, ConfigTemplateVersionInner> beginCreateVersionAsync(
        String resourceGroupName, String configTemplateName, ConfigTemplateVersionWithUpdateTypeInner body) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createVersionWithResponseAsync(resourceGroupName, configTemplateName, body);
        return this.client.<ConfigTemplateVersionInner, ConfigTemplateVersionInner>getLroResult(mono,
            this.client.getHttpPipeline(), ConfigTemplateVersionInner.class, ConfigTemplateVersionInner.class,
            this.client.getContext());
    }

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ConfigTemplateVersionInner>, ConfigTemplateVersionInner> beginCreateVersion(
        String resourceGroupName, String configTemplateName, ConfigTemplateVersionWithUpdateTypeInner body) {
        Response<BinaryData> response = createVersionWithResponse(resourceGroupName, configTemplateName, body);
        return this.client.<ConfigTemplateVersionInner, ConfigTemplateVersionInner>getLroResult(response,
            ConfigTemplateVersionInner.class, ConfigTemplateVersionInner.class, Context.NONE);
    }

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ConfigTemplateVersionInner>, ConfigTemplateVersionInner> beginCreateVersion(
        String resourceGroupName, String configTemplateName, ConfigTemplateVersionWithUpdateTypeInner body,
        Context context) {
        Response<BinaryData> response = createVersionWithResponse(resourceGroupName, configTemplateName, body, context);
        return this.client.<ConfigTemplateVersionInner, ConfigTemplateVersionInner>getLroResult(response,
            ConfigTemplateVersionInner.class, ConfigTemplateVersionInner.class, context);
    }

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ConfigTemplateVersionInner> createVersionAsync(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body) {
        return beginCreateVersionAsync(resourceGroupName, configTemplateName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ConfigTemplateVersionInner createVersion(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body) {
        return beginCreateVersion(resourceGroupName, configTemplateName, body).getFinalResult();
    }

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ConfigTemplateVersionInner createVersion(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body, Context context) {
        return beginCreateVersion(resourceGroupName, configTemplateName, body, context).getFinalResult();
    }

    /**
     * Remove Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<RemoveVersionResponseInner>> removeVersionWithResponseAsync(String resourceGroupName,
        String configTemplateName, VersionParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.removeVersion(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, body,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Remove Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<RemoveVersionResponseInner> removeVersionAsync(String resourceGroupName, String configTemplateName,
        VersionParameter body) {
        return removeVersionWithResponseAsync(resourceGroupName, configTemplateName, body)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Remove Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RemoveVersionResponseInner> removeVersionWithResponse(String resourceGroupName,
        String configTemplateName, VersionParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.removeVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, configTemplateName, contentType, accept, body, context);
    }

    /**
     * Remove Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RemoveVersionResponseInner removeVersion(String resourceGroupName, String configTemplateName,
        VersionParameter body) {
        return removeVersionWithResponse(resourceGroupName, configTemplateName, body, Context.NONE).getValue();
    }

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName,
        String configTemplateName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String configTemplateName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, configTemplateName, Context.NONE);
    }

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String configTemplateName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, configTemplateName, context);
    }

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String configTemplateName) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, configTemplateName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String configTemplateName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, configTemplateName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String configTemplateName,
        Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, configTemplateName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String configTemplateName) {
        return beginDeleteAsync(resourceGroupName, configTemplateName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String configTemplateName) {
        beginDelete(resourceGroupName, configTemplateName).getFinalResult();
    }

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String configTemplateName, Context context) {
        beginDelete(resourceGroupName, configTemplateName, context).getFinalResult();
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ConfigTemplateInner>> listByResourceGroupSinglePageAsync(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, accept, context))
            .<PagedResponse<ConfigTemplateInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<ConfigTemplateInner> listByResourceGroupAsync(String resourceGroupName) {
        return new PagedFlux<>(() -> listByResourceGroupSinglePageAsync(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateInner> listByResourceGroupSinglePage(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateInner> listByResourceGroupSinglePage(String resourceGroupName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ConfigTemplateInner> listByResourceGroup(String resourceGroupName) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePage(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ConfigTemplateInner> listByResourceGroup(String resourceGroupName, Context context) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName, context),
            nextLink -> listByResourceGroupNextSinglePage(nextLink, context));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ConfigTemplateInner>> listSinglePageAsync() {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.list(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), accept, context))
            .<PagedResponse<ConfigTemplateInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<ConfigTemplateInner> listAsync() {
        return new PagedFlux<>(() -> listSinglePageAsync(),
            nextLink -> listBySubscriptionNextSinglePageAsync(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateInner> listSinglePage() {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateListResult> res = service.listSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateInner> listSinglePage(Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateListResult> res = service.listSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ConfigTemplateInner> list() {
        return new PagedIterable<>(() -> listSinglePage(), nextLink -> listBySubscriptionNextSinglePage(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ConfigTemplateInner> list(Context context) {
        return new PagedIterable<>(() -> listSinglePage(context),
            nextLink -> listBySubscriptionNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ConfigTemplateInner>> listByResourceGroupNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<ConfigTemplateInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateInner> listByResourceGroupNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateInner> listByResourceGroupNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ConfigTemplateInner>> listBySubscriptionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listBySubscriptionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<ConfigTemplateInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateInner> listBySubscriptionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateInner> listBySubscriptionNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(ConfigTemplatesClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ConfigTemplatesImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplate;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplates;
import com.azure.resourcemanager.workloadorchestration.models.RemoveVersionResponse;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

public final class ConfigTemplatesImpl implements ConfigTemplates {
    private static final ClientLogger LOGGER = new ClientLogger(ConfigTemplatesImpl.class);

    private final ConfigTemplatesClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public ConfigTemplatesImpl(ConfigTemplatesClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<ConfigTemplate> getByResourceGroupWithResponse(String resourceGroupName, String configTemplateName,
        Context context) {
        Response<ConfigTemplateInner> inner
            = this.serviceClient().getByResourceGroupWithResponse(resourceGroupName, configTemplateName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new ConfigTemplateImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public ConfigTemplate getByResourceGroup(String resourceGroupName, String configTemplateName) {
        ConfigTemplateInner inner = this.serviceClient().getByResourceGroup(resourceGroupName, configTemplateName);
        if (inner != null) {
            return new ConfigTemplateImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public ConfigTemplateVersion createVersion(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body) {
        ConfigTemplateVersionInner inner
            = this.serviceClient().createVersion(resourceGroupName, configTemplateName, body);
        if (inner != null) {
            return new ConfigTemplateVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public ConfigTemplateVersion createVersion(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body, Context context) {
        ConfigTemplateVersionInner inner
            = this.serviceClient().createVersion(resourceGroupName, configTemplateName, body, context);
        if (inner != null) {
            return new ConfigTemplateVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public Response<RemoveVersionResponse> removeVersionWithResponse(String resourceGroupName,
        String configTemplateName, VersionParameter body, Context context) {
        Response<RemoveVersionResponseInner> inner
            = this.serviceClient().removeVersionWithResponse(resourceGroupName, configTemplateName, body, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new RemoveVersionResponseImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public RemoveVersionResponse removeVersion(String resourceGroupName, String configTemplateName,
        VersionParameter body) {
        RemoveVersionResponseInner inner
            = this.serviceClient().removeVersion(resourceGroupName, configTemplateName, body);
        if (inner != null) {
            return new RemoveVersionResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void deleteByResourceGroup(String resourceGroupName, String configTemplateName) {
        this.serviceClient().delete(resourceGroupName, configTemplateName);
    }

    public void delete(String resourceGroupName, String configTemplateName, Context context) {
        this.serviceClient().delete(resourceGroupName, configTemplateName, context);
    }

    public PagedIterable<ConfigTemplate> listByResourceGroup(String resourceGroupName) {
        PagedIterable<ConfigTemplateInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ConfigTemplateImpl(inner1, this.manager()));
    }

    public PagedIterable<ConfigTemplate> listByResourceGroup(String resourceGroupName, Context context) {
        PagedIterable<ConfigTemplateInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ConfigTemplateImpl(inner1, this.manager()));
    }

    public PagedIterable<ConfigTemplate> list() {
        PagedIterable<ConfigTemplateInner> inner = this.serviceClient().list();
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ConfigTemplateImpl(inner1, this.manager()));
    }

    public PagedIterable<ConfigTemplate> list(Context context) {
        PagedIterable<ConfigTemplateInner> inner = this.serviceClient().list(context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ConfigTemplateImpl(inner1, this.manager()));
    }

    public ConfigTemplate getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String configTemplateName = ResourceManagerUtils.getValueFromIdByName(id, "configTemplates");
        if (configTemplateName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'configTemplates'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, configTemplateName, Context.NONE).getValue();
    }

    public Response<ConfigTemplate> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String configTemplateName = ResourceManagerUtils.getValueFromIdByName(id, "configTemplates");
        if (configTemplateName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'configTemplates'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, configTemplateName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String configTemplateName = ResourceManagerUtils.getValueFromIdByName(id, "configTemplates");
        if (configTemplateName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'configTemplates'.", id)));
        }
        this.delete(resourceGroupName, configTemplateName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String configTemplateName = ResourceManagerUtils.getValueFromIdByName(id, "configTemplates");
        if (configTemplateName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'configTemplates'.", id)));
        }
        this.delete(resourceGroupName, configTemplateName, context);
    }

    private ConfigTemplatesClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public ConfigTemplateImpl define(String name) {
        return new ConfigTemplateImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ConfigTemplateVersionImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties;

public final class ConfigTemplateVersionImpl implements ConfigTemplateVersion {
    private ConfigTemplateVersionInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    ConfigTemplateVersionImpl(ConfigTemplateVersionInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public ConfigTemplateVersionProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public ConfigTemplateVersionInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ConfigTemplateVersionsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.ConfigTemplateVersionListResult;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in ConfigTemplateVersionsClient.
 */
public final class ConfigTemplateVersionsClientImpl implements ConfigTemplateVersionsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final ConfigTemplateVersionsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of ConfigTemplateVersionsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    ConfigTemplateVersionsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service = RestProxy.create(ConfigTemplateVersionsService.class, client.getHttpPipeline(),
            client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientConfigTemplateVersions to be
     * used by the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientConfigTemplateVersions")
    public interface ConfigTemplateVersionsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ConfigTemplateVersionInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName,
            @PathParam("configTemplateVersionName") String configTemplateVersionName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ConfigTemplateVersionInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName,
            @PathParam("configTemplateVersionName") String configTemplateVersionName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ConfigTemplateVersionListResult>> listByConfigTemplate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ConfigTemplateVersionListResult> listByConfigTemplateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("configTemplateName") String configTemplateName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ConfigTemplateVersionListResult>> listByConfigTemplateNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ConfigTemplateVersionListResult> listByConfigTemplateNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param configTemplateVersionName The name of the ConfigTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<ConfigTemplateVersionInner>> getWithResponseAsync(String resourceGroupName,
        String configTemplateName, String configTemplateVersionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (configTemplateVersionName == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter configTemplateVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, configTemplateVersionName,
                accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param configTemplateVersionName The name of the ConfigTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ConfigTemplateVersionInner> getAsync(String resourceGroupName, String configTemplateName,
        String configTemplateVersionName) {
        return getWithResponseAsync(resourceGroupName, configTemplateName, configTemplateVersionName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param configTemplateVersionName The name of the ConfigTemplateVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ConfigTemplateVersionInner> getWithResponse(String resourceGroupName, String configTemplateName,
        String configTemplateVersionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        if (configTemplateVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter configTemplateVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, configTemplateName, configTemplateVersionName, accept, context);
    }

    /**
     * Get a Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param configTemplateVersionName The name of the ConfigTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ConfigTemplateVersionInner get(String resourceGroupName, String configTemplateName,
        String configTemplateVersionName) {
        return getWithResponse(resourceGroupName, configTemplateName, configTemplateVersionName, Context.NONE)
            .getValue();
    }

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ConfigTemplateVersionInner>>
        listByConfigTemplateSinglePageAsync(String resourceGroupName, String configTemplateName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByConfigTemplate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, accept, context))
            .<PagedResponse<ConfigTemplateVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<ConfigTemplateVersionInner> listByConfigTemplateAsync(String resourceGroupName,
        String configTemplateName) {
        return new PagedFlux<>(() -> listByConfigTemplateSinglePageAsync(resourceGroupName, configTemplateName),
            nextLink -> listByConfigTemplateNextSinglePageAsync(nextLink));
    }

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateVersionInner> listByConfigTemplateSinglePage(String resourceGroupName,
        String configTemplateName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateVersionListResult> res
            = service.listByConfigTemplateSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateVersionInner> listByConfigTemplateSinglePage(String resourceGroupName,
        String configTemplateName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (configTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter configTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateVersionListResult> res
            = service.listByConfigTemplateSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, configTemplateName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ConfigTemplateVersionInner> listByConfigTemplate(String resourceGroupName,
        String configTemplateName) {
        return new PagedIterable<>(() -> listByConfigTemplateSinglePage(resourceGroupName, configTemplateName),
            nextLink -> listByConfigTemplateNextSinglePage(nextLink));
    }

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ConfigTemplateVersionInner> listByConfigTemplate(String resourceGroupName,
        String configTemplateName, Context context) {
        return new PagedIterable<>(() -> listByConfigTemplateSinglePage(resourceGroupName, configTemplateName, context),
            nextLink -> listByConfigTemplateNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ConfigTemplateVersionInner>> listByConfigTemplateNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByConfigTemplateNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<ConfigTemplateVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateVersionInner> listByConfigTemplateNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateVersionListResult> res
            = service.listByConfigTemplateNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ConfigTemplateVersionInner> listByConfigTemplateNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ConfigTemplateVersionListResult> res
            = service.listByConfigTemplateNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(ConfigTemplateVersionsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ConfigTemplateVersionsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersions;

public final class ConfigTemplateVersionsImpl implements ConfigTemplateVersions {
    private static final ClientLogger LOGGER = new ClientLogger(ConfigTemplateVersionsImpl.class);

    private final ConfigTemplateVersionsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public ConfigTemplateVersionsImpl(ConfigTemplateVersionsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<ConfigTemplateVersion> getWithResponse(String resourceGroupName, String configTemplateName,
        String configTemplateVersionName, Context context) {
        Response<ConfigTemplateVersionInner> inner = this.serviceClient()
            .getWithResponse(resourceGroupName, configTemplateName, configTemplateVersionName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new ConfigTemplateVersionImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public ConfigTemplateVersion get(String resourceGroupName, String configTemplateName,
        String configTemplateVersionName) {
        ConfigTemplateVersionInner inner
            = this.serviceClient().get(resourceGroupName, configTemplateName, configTemplateVersionName);
        if (inner != null) {
            return new ConfigTemplateVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public PagedIterable<ConfigTemplateVersion> listByConfigTemplate(String resourceGroupName,
        String configTemplateName) {
        PagedIterable<ConfigTemplateVersionInner> inner
            = this.serviceClient().listByConfigTemplate(resourceGroupName, configTemplateName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ConfigTemplateVersionImpl(inner1, this.manager()));
    }

    public PagedIterable<ConfigTemplateVersion> listByConfigTemplate(String resourceGroupName,
        String configTemplateName, Context context) {
        PagedIterable<ConfigTemplateVersionInner> inner
            = this.serviceClient().listByConfigTemplate(resourceGroupName, configTemplateName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ConfigTemplateVersionImpl(inner1, this.manager()));
    }

    private ConfigTemplateVersionsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ConfigTemplateVersionWithUpdateTypeImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionWithUpdateType;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;

public final class ConfigTemplateVersionWithUpdateTypeImpl implements ConfigTemplateVersionWithUpdateType {
    private ConfigTemplateVersionWithUpdateTypeInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    ConfigTemplateVersionWithUpdateTypeImpl(ConfigTemplateVersionWithUpdateTypeInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public UpdateType updateType() {
        return this.innerModel().updateType();
    }

    public String version() {
        return this.innerModel().version();
    }

    public ConfigTemplateVersion configTemplateVersion() {
        ConfigTemplateVersionInner inner = this.innerModel().configTemplateVersion();
        if (inner != null) {
            return new ConfigTemplateVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public ConfigTemplateVersionWithUpdateTypeInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ContextModelImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner;
import com.azure.resourcemanager.workloadorchestration.models.ContextModel;
import com.azure.resourcemanager.workloadorchestration.models.ContextProperties;
import java.util.Collections;
import java.util.Map;

public final class ContextModelImpl implements ContextModel, ContextModel.Definition, ContextModel.Update {
    private ContextInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public String location() {
        return this.innerModel().location();
    }

    public Map<String, String> tags() {
        Map<String, String> inner = this.innerModel().tags();
        if (inner != null) {
            return Collections.unmodifiableMap(inner);
        } else {
            return Collections.emptyMap();
        }
    }

    public ContextProperties properties() {
        return this.innerModel().properties();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public Region region() {
        return Region.fromName(this.regionName());
    }

    public String regionName() {
        return this.location();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public ContextInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String contextName;

    public ContextModelImpl withExistingResourceGroup(String resourceGroupName) {
        this.resourceGroupName = resourceGroupName;
        return this;
    }

    public ContextModel create() {
        this.innerObject = serviceManager.serviceClient()
            .getContexts()
            .createOrUpdate(resourceGroupName, contextName, this.innerModel(), Context.NONE);
        return this;
    }

    public ContextModel create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getContexts()
            .createOrUpdate(resourceGroupName, contextName, this.innerModel(), context);
        return this;
    }

    ContextModelImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new ContextInner();
        this.serviceManager = serviceManager;
        this.contextName = name;
    }

    public ContextModelImpl update() {
        return this;
    }

    public ContextModel apply() {
        this.innerObject = serviceManager.serviceClient()
            .getContexts()
            .update(resourceGroupName, contextName, this.innerModel(), Context.NONE);
        return this;
    }

    public ContextModel apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getContexts()
            .update(resourceGroupName, contextName, this.innerModel(), context);
        return this;
    }

    ContextModelImpl(ContextInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.contextName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "contexts");
    }

    public ContextModel refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getContexts()
            .getByResourceGroupWithResponse(resourceGroupName, contextName, Context.NONE)
            .getValue();
        return this;
    }

    public ContextModel refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getContexts()
            .getByResourceGroupWithResponse(resourceGroupName, contextName, context)
            .getValue();
        return this;
    }

    public ContextModelImpl withRegion(Region location) {
        this.innerModel().withLocation(location.toString());
        return this;
    }

    public ContextModelImpl withRegion(String location) {
        this.innerModel().withLocation(location);
        return this;
    }

    public ContextModelImpl withTags(Map<String, String> tags) {
        this.innerModel().withTags(tags);
        return this;
    }

    public ContextModelImpl withProperties(ContextProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ContextsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.ContextListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in ContextsClient.
 */
public final class ContextsClientImpl implements ContextsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final ContextsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of ContextsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    ContextsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service = RestProxy.create(ContextsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientContexts to be used by the proxy
     * service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientContexts")
    public interface ContextsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ContextInner>> getByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ContextInner> getByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") ContextInner resource, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") ContextInner resource, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") ContextInner properties, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") ContextInner properties, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ContextListResult>> listByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ContextListResult> listByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/contexts")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ContextListResult>> list(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/contexts")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ContextListResult> listSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ContextListResult>> listByResourceGroupNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ContextListResult> listByResourceGroupNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ContextListResult>> listBySubscriptionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ContextListResult> listBySubscriptionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<ContextInner>> getByResourceGroupWithResponseAsync(String resourceGroupName,
        String contextName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ContextInner> getByResourceGroupAsync(String resourceGroupName, String contextName) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, contextName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ContextInner> getByResourceGroupWithResponse(String resourceGroupName, String contextName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getByResourceGroupSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, accept, context);
    }

    /**
     * Get Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ContextInner getByResourceGroup(String resourceGroupName, String contextName) {
        return getByResourceGroupWithResponse(resourceGroupName, contextName, Context.NONE).getValue();
    }

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String contextName, ContextInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, contentType, accept, resource,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        ContextInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, contentType, accept, resource,
            Context.NONE);
    }

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        ContextInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, contentType, accept, resource, context);
    }

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<ContextInner>, ContextInner> beginCreateOrUpdateAsync(String resourceGroupName,
        String contextName, ContextInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, contextName, resource);
        return this.client.<ContextInner, ContextInner>getLroResult(mono, this.client.getHttpPipeline(),
            ContextInner.class, ContextInner.class, this.client.getContext());
    }

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ContextInner>, ContextInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, ContextInner resource) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, contextName, resource);
        return this.client.<ContextInner, ContextInner>getLroResult(response, ContextInner.class, ContextInner.class,
            Context.NONE);
    }

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ContextInner>, ContextInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, ContextInner resource, Context context) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, contextName, resource, context);
        return this.client.<ContextInner, ContextInner>getLroResult(response, ContextInner.class, ContextInner.class,
            context);
    }

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ContextInner> createOrUpdateAsync(String resourceGroupName, String contextName,
        ContextInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, contextName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ContextInner createOrUpdate(String resourceGroupName, String contextName, ContextInner resource) {
        return beginCreateOrUpdate(resourceGroupName, contextName, resource).getFinalResult();
    }

    /**
     * Create or update Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ContextInner createOrUpdate(String resourceGroupName, String contextName, ContextInner resource,
        Context context) {
        return beginCreateOrUpdate(resourceGroupName, contextName, resource, context).getFinalResult();
    }

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String contextName,
        ContextInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, contentType, accept, properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName,
        ContextInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, contentType, accept, properties,
            Context.NONE);
    }

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName,
        ContextInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, contentType, accept, properties, context);
    }

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<ContextInner>, ContextInner> beginUpdateAsync(String resourceGroupName,
        String contextName, ContextInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono = updateWithResponseAsync(resourceGroupName, contextName, properties);
        return this.client.<ContextInner, ContextInner>getLroResult(mono, this.client.getHttpPipeline(),
            ContextInner.class, ContextInner.class, this.client.getContext());
    }

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ContextInner>, ContextInner> beginUpdate(String resourceGroupName, String contextName,
        ContextInner properties) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, contextName, properties);
        return this.client.<ContextInner, ContextInner>getLroResult(response, ContextInner.class, ContextInner.class,
            Context.NONE);
    }

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of context Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ContextInner>, ContextInner> beginUpdate(String resourceGroupName, String contextName,
        ContextInner properties, Context context) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, contextName, properties, context);
        return this.client.<ContextInner, ContextInner>getLroResult(response, ContextInner.class, ContextInner.class,
            context);
    }

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ContextInner> updateAsync(String resourceGroupName, String contextName, ContextInner properties) {
        return beginUpdateAsync(resourceGroupName, contextName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ContextInner update(String resourceGroupName, String contextName, ContextInner properties) {
        return beginUpdate(resourceGroupName, contextName, properties).getFinalResult();
    }

    /**
     * update an Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ContextInner update(String resourceGroupName, String contextName, ContextInner properties, Context context) {
        return beginUpdate(resourceGroupName, contextName, properties, context).getFinalResult();
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ContextInner>> listByResourceGroupSinglePageAsync(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, accept, context))
            .<PagedResponse<ContextInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<ContextInner> listByResourceGroupAsync(String resourceGroupName) {
        return new PagedFlux<>(() -> listByResourceGroupSinglePageAsync(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ContextInner> listByResourceGroupSinglePage(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ContextListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ContextInner> listByResourceGroupSinglePage(String resourceGroupName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ContextListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ContextInner> listByResourceGroup(String resourceGroupName) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePage(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ContextInner> listByResourceGroup(String resourceGroupName, Context context) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName, context),
            nextLink -> listByResourceGroupNextSinglePage(nextLink, context));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ContextInner>> listSinglePageAsync() {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.list(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), accept, context))
            .<PagedResponse<ContextInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<ContextInner> listAsync() {
        return new PagedFlux<>(() -> listSinglePageAsync(),
            nextLink -> listBySubscriptionNextSinglePageAsync(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ContextInner> listSinglePage() {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ContextListResult> res = service.listSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ContextInner> listSinglePage(Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ContextListResult> res = service.listSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ContextInner> list() {
        return new PagedIterable<>(() -> listSinglePage(), nextLink -> listBySubscriptionNextSinglePage(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ContextInner> list(Context context) {
        return new PagedIterable<>(() -> listSinglePage(context),
            nextLink -> listBySubscriptionNextSinglePage(nextLink, context));
    }

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String contextName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, Context.NONE);
    }

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, context);
    }

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String contextName) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, contextName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, contextName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, contextName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String contextName) {
        return beginDeleteAsync(resourceGroupName, contextName).last().flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName) {
        beginDelete(resourceGroupName, contextName).getFinalResult();
    }

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName, Context context) {
        beginDelete(resourceGroupName, contextName, context).getFinalResult();
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ContextInner>> listByResourceGroupNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<ContextInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ContextInner> listByResourceGroupNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ContextListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ContextInner> listByResourceGroupNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ContextListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ContextInner>> listBySubscriptionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listBySubscriptionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<ContextInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ContextInner> listBySubscriptionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ContextListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ContextInner> listBySubscriptionNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ContextListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(ContextsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ContextsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner;
import com.azure.resourcemanager.workloadorchestration.models.ContextModel;
import com.azure.resourcemanager.workloadorchestration.models.Contexts;

public final class ContextsImpl implements Contexts {
    private static final ClientLogger LOGGER = new ClientLogger(ContextsImpl.class);

    private final ContextsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public ContextsImpl(ContextsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<ContextModel> getByResourceGroupWithResponse(String resourceGroupName, String contextName,
        Context context) {
        Response<ContextInner> inner
            = this.serviceClient().getByResourceGroupWithResponse(resourceGroupName, contextName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new ContextModelImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public ContextModel getByResourceGroup(String resourceGroupName, String contextName) {
        ContextInner inner = this.serviceClient().getByResourceGroup(resourceGroupName, contextName);
        if (inner != null) {
            return new ContextModelImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public PagedIterable<ContextModel> listByResourceGroup(String resourceGroupName) {
        PagedIterable<ContextInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ContextModelImpl(inner1, this.manager()));
    }

    public PagedIterable<ContextModel> listByResourceGroup(String resourceGroupName, Context context) {
        PagedIterable<ContextInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ContextModelImpl(inner1, this.manager()));
    }

    public PagedIterable<ContextModel> list() {
        PagedIterable<ContextInner> inner = this.serviceClient().list();
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ContextModelImpl(inner1, this.manager()));
    }

    public PagedIterable<ContextModel> list(Context context) {
        PagedIterable<ContextInner> inner = this.serviceClient().list(context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ContextModelImpl(inner1, this.manager()));
    }

    public void deleteByResourceGroup(String resourceGroupName, String contextName) {
        this.serviceClient().delete(resourceGroupName, contextName);
    }

    public void delete(String resourceGroupName, String contextName, Context context) {
        this.serviceClient().delete(resourceGroupName, contextName, context);
    }

    public ContextModel getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, contextName, Context.NONE).getValue();
    }

    public Response<ContextModel> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, contextName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        this.delete(resourceGroupName, contextName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        this.delete(resourceGroupName, contextName, context);
    }

    private ContextsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public ContextModelImpl define(String name) {
        return new ContextModelImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/DiagnosticImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner;
import com.azure.resourcemanager.workloadorchestration.models.Diagnostic;
import com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import java.util.Collections;
import java.util.Map;

public final class DiagnosticImpl implements Diagnostic, Diagnostic.Definition, Diagnostic.Update {
    private DiagnosticInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public String location() {
        return this.innerModel().location();
    }

    public Map<String, String> tags() {
        Map<String, String> inner = this.innerModel().tags();
        if (inner != null) {
            return Collections.unmodifiableMap(inner);
        } else {
            return Collections.emptyMap();
        }
    }

    public DiagnosticProperties properties() {
        return this.innerModel().properties();
    }

    public ExtendedLocation extendedLocation() {
        return this.innerModel().extendedLocation();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public Region region() {
        return Region.fromName(this.regionName());
    }

    public String regionName() {
        return this.location();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public DiagnosticInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String diagnosticName;

    public DiagnosticImpl withExistingResourceGroup(String resourceGroupName) {
        this.resourceGroupName = resourceGroupName;
        return this;
    }

    public Diagnostic create() {
        this.innerObject = serviceManager.serviceClient()
            .getDiagnostics()
            .createOrUpdate(resourceGroupName, diagnosticName, this.innerModel(), Context.NONE);
        return this;
    }

    public Diagnostic create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getDiagnostics()
            .createOrUpdate(resourceGroupName, diagnosticName, this.innerModel(), context);
        return this;
    }

    DiagnosticImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new DiagnosticInner();
        this.serviceManager = serviceManager;
        this.diagnosticName = name;
    }

    public DiagnosticImpl update() {
        return this;
    }

    public Diagnostic apply() {
        this.innerObject = serviceManager.serviceClient()
            .getDiagnostics()
            .update(resourceGroupName, diagnosticName, this.innerModel(), Context.NONE);
        return this;
    }

    public Diagnostic apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getDiagnostics()
            .update(resourceGroupName, diagnosticName, this.innerModel(), context);
        return this;
    }

    DiagnosticImpl(DiagnosticInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.diagnosticName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "diagnostics");
    }

    public Diagnostic refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getDiagnostics()
            .getByResourceGroupWithResponse(resourceGroupName, diagnosticName, Context.NONE)
            .getValue();
        return this;
    }

    public Diagnostic refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getDiagnostics()
            .getByResourceGroupWithResponse(resourceGroupName, diagnosticName, context)
            .getValue();
        return this;
    }

    public DiagnosticImpl withRegion(Region location) {
        this.innerModel().withLocation(location.toString());
        return this;
    }

    public DiagnosticImpl withRegion(String location) {
        this.innerModel().withLocation(location);
        return this;
    }

    public DiagnosticImpl withTags(Map<String, String> tags) {
        this.innerModel().withTags(tags);
        return this;
    }

    public DiagnosticImpl withProperties(DiagnosticProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }

    public DiagnosticImpl withExtendedLocation(ExtendedLocation extendedLocation) {
        this.innerModel().withExtendedLocation(extendedLocation);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/DiagnosticsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.DiagnosticListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in DiagnosticsClient.
 */
public final class DiagnosticsClientImpl implements DiagnosticsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final DiagnosticsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of DiagnosticsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    DiagnosticsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(DiagnosticsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientDiagnostics to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientDiagnostics")
    public interface DiagnosticsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DiagnosticInner>> getByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("diagnosticName") String diagnosticName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DiagnosticInner> getByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("diagnosticName") String diagnosticName, @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("diagnosticName") String diagnosticName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") DiagnosticInner resource,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("diagnosticName") String diagnosticName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") DiagnosticInner resource,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("diagnosticName") String diagnosticName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") DiagnosticInner properties,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("diagnosticName") String diagnosticName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") DiagnosticInner properties,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("diagnosticName") String diagnosticName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("diagnosticName") String diagnosticName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DiagnosticListResult>> listByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DiagnosticListResult> listByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/diagnostics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DiagnosticListResult>> list(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/diagnostics")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DiagnosticListResult> listSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DiagnosticListResult>> listByResourceGroupNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DiagnosticListResult> listByResourceGroupNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DiagnosticListResult>> listBySubscriptionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DiagnosticListResult> listBySubscriptionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<DiagnosticInner>> getByResourceGroupWithResponseAsync(String resourceGroupName,
        String diagnosticName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            return Mono.error(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, diagnosticName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<DiagnosticInner> getByResourceGroupAsync(String resourceGroupName, String diagnosticName) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, diagnosticName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DiagnosticInner> getByResourceGroupWithResponse(String resourceGroupName, String diagnosticName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getByResourceGroupSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, diagnosticName, accept, context);
    }

    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticInner getByResourceGroup(String resourceGroupName, String diagnosticName) {
        return getByResourceGroupWithResponse(resourceGroupName, diagnosticName, Context.NONE).getValue();
    }

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String diagnosticName, DiagnosticInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            return Mono.error(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, diagnosticName, contentType, accept, resource,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String diagnosticName,
        DiagnosticInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, diagnosticName, contentType, accept, resource,
            Context.NONE);
    }

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String diagnosticName,
        DiagnosticInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, diagnosticName, contentType, accept, resource, context);
    }

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<DiagnosticInner>, DiagnosticInner> beginCreateOrUpdateAsync(String resourceGroupName,
        String diagnosticName, DiagnosticInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, diagnosticName, resource);
        return this.client.<DiagnosticInner, DiagnosticInner>getLroResult(mono, this.client.getHttpPipeline(),
            DiagnosticInner.class, DiagnosticInner.class, this.client.getContext());
    }

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<DiagnosticInner>, DiagnosticInner> beginCreateOrUpdate(String resourceGroupName,
        String diagnosticName, DiagnosticInner resource) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, diagnosticName, resource);
        return this.client.<DiagnosticInner, DiagnosticInner>getLroResult(response, DiagnosticInner.class,
            DiagnosticInner.class, Context.NONE);
    }

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<DiagnosticInner>, DiagnosticInner> beginCreateOrUpdate(String resourceGroupName,
        String diagnosticName, DiagnosticInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, diagnosticName, resource, context);
        return this.client.<DiagnosticInner, DiagnosticInner>getLroResult(response, DiagnosticInner.class,
            DiagnosticInner.class, context);
    }

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<DiagnosticInner> createOrUpdateAsync(String resourceGroupName, String diagnosticName,
        DiagnosticInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, diagnosticName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticInner createOrUpdate(String resourceGroupName, String diagnosticName, DiagnosticInner resource) {
        return beginCreateOrUpdate(resourceGroupName, diagnosticName, resource).getFinalResult();
    }

    /**
     * Creates new or updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticInner createOrUpdate(String resourceGroupName, String diagnosticName, DiagnosticInner resource,
        Context context) {
        return beginCreateOrUpdate(resourceGroupName, diagnosticName, resource, context).getFinalResult();
    }

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String diagnosticName,
        DiagnosticInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            return Mono.error(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, diagnosticName, contentType, accept, properties,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String diagnosticName,
        DiagnosticInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, diagnosticName, contentType, accept, properties,
            Context.NONE);
    }

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String diagnosticName,
        DiagnosticInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, diagnosticName, contentType, accept, properties,
            context);
    }

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<DiagnosticInner>, DiagnosticInner> beginUpdateAsync(String resourceGroupName,
        String diagnosticName, DiagnosticInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono = updateWithResponseAsync(resourceGroupName, diagnosticName, properties);
        return this.client.<DiagnosticInner, DiagnosticInner>getLroResult(mono, this.client.getHttpPipeline(),
            DiagnosticInner.class, DiagnosticInner.class, this.client.getContext());
    }

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<DiagnosticInner>, DiagnosticInner> beginUpdate(String resourceGroupName,
        String diagnosticName, DiagnosticInner properties) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, diagnosticName, properties);
        return this.client.<DiagnosticInner, DiagnosticInner>getLroResult(response, DiagnosticInner.class,
            DiagnosticInner.class, Context.NONE);
    }

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<DiagnosticInner>, DiagnosticInner> beginUpdate(String resourceGroupName,
        String diagnosticName, DiagnosticInner properties, Context context) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, diagnosticName, properties, context);
        return this.client.<DiagnosticInner, DiagnosticInner>getLroResult(response, DiagnosticInner.class,
            DiagnosticInner.class, context);
    }

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<DiagnosticInner> updateAsync(String resourceGroupName, String diagnosticName,
        DiagnosticInner properties) {
        return beginUpdateAsync(resourceGroupName, diagnosticName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticInner update(String resourceGroupName, String diagnosticName, DiagnosticInner properties) {
        return beginUpdate(resourceGroupName, diagnosticName, properties).getFinalResult();
    }

    /**
     * Updates existing Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DiagnosticInner update(String resourceGroupName, String diagnosticName, DiagnosticInner properties,
        Context context) {
        return beginUpdate(resourceGroupName, diagnosticName, properties, context).getFinalResult();
    }

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String diagnosticName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            return Mono.error(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, diagnosticName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String diagnosticName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, diagnosticName, Context.NONE);
    }

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String diagnosticName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (diagnosticName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter diagnosticName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, diagnosticName, context);
    }

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String diagnosticName) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, diagnosticName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String diagnosticName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, diagnosticName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String diagnosticName,
        Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, diagnosticName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String diagnosticName) {
        return beginDeleteAsync(resourceGroupName, diagnosticName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String diagnosticName) {
        beginDelete(resourceGroupName, diagnosticName).getFinalResult();
    }

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String diagnosticName, Context context) {
        beginDelete(resourceGroupName, diagnosticName, context).getFinalResult();
    }

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DiagnosticInner>> listByResourceGroupSinglePageAsync(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, accept, context))
            .<PagedResponse<DiagnosticInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<DiagnosticInner> listByResourceGroupAsync(String resourceGroupName) {
        return new PagedFlux<>(() -> listByResourceGroupSinglePageAsync(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticInner> listByResourceGroupSinglePage(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticInner> listByResourceGroupSinglePage(String resourceGroupName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DiagnosticInner> listByResourceGroup(String resourceGroupName) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePage(nextLink));
    }

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DiagnosticInner> listByResourceGroup(String resourceGroupName, Context context) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName, context),
            nextLink -> listByResourceGroupNextSinglePage(nextLink, context));
    }

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DiagnosticInner>> listSinglePageAsync() {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.list(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), accept, context))
            .<PagedResponse<DiagnosticInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<DiagnosticInner> listAsync() {
        return new PagedFlux<>(() -> listSinglePageAsync(),
            nextLink -> listBySubscriptionNextSinglePageAsync(nextLink));
    }

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticInner> listSinglePage() {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticListResult> res = service.listSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticInner> listSinglePage(Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticListResult> res = service.listSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DiagnosticInner> list() {
        return new PagedIterable<>(() -> listSinglePage(), nextLink -> listBySubscriptionNextSinglePage(nextLink));
    }

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DiagnosticInner> list(Context context) {
        return new PagedIterable<>(() -> listSinglePage(context),
            nextLink -> listBySubscriptionNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DiagnosticInner>> listByResourceGroupNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<DiagnosticInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticInner> listByResourceGroupNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticInner> listByResourceGroupNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DiagnosticInner>> listBySubscriptionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listBySubscriptionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<DiagnosticInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticInner> listBySubscriptionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DiagnosticInner> listBySubscriptionNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DiagnosticListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(DiagnosticsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/DiagnosticsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner;
import com.azure.resourcemanager.workloadorchestration.models.Diagnostic;
import com.azure.resourcemanager.workloadorchestration.models.Diagnostics;

public final class DiagnosticsImpl implements Diagnostics {
    private static final ClientLogger LOGGER = new ClientLogger(DiagnosticsImpl.class);

    private final DiagnosticsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public DiagnosticsImpl(DiagnosticsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<Diagnostic> getByResourceGroupWithResponse(String resourceGroupName, String diagnosticName,
        Context context) {
        Response<DiagnosticInner> inner
            = this.serviceClient().getByResourceGroupWithResponse(resourceGroupName, diagnosticName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new DiagnosticImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public Diagnostic getByResourceGroup(String resourceGroupName, String diagnosticName) {
        DiagnosticInner inner = this.serviceClient().getByResourceGroup(resourceGroupName, diagnosticName);
        if (inner != null) {
            return new DiagnosticImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void deleteByResourceGroup(String resourceGroupName, String diagnosticName) {
        this.serviceClient().delete(resourceGroupName, diagnosticName);
    }

    public void delete(String resourceGroupName, String diagnosticName, Context context) {
        this.serviceClient().delete(resourceGroupName, diagnosticName, context);
    }

    public PagedIterable<Diagnostic> listByResourceGroup(String resourceGroupName) {
        PagedIterable<DiagnosticInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new DiagnosticImpl(inner1, this.manager()));
    }

    public PagedIterable<Diagnostic> listByResourceGroup(String resourceGroupName, Context context) {
        PagedIterable<DiagnosticInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new DiagnosticImpl(inner1, this.manager()));
    }

    public PagedIterable<Diagnostic> list() {
        PagedIterable<DiagnosticInner> inner = this.serviceClient().list();
        return ResourceManagerUtils.mapPage(inner, inner1 -> new DiagnosticImpl(inner1, this.manager()));
    }

    public PagedIterable<Diagnostic> list(Context context) {
        PagedIterable<DiagnosticInner> inner = this.serviceClient().list(context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new DiagnosticImpl(inner1, this.manager()));
    }

    public Diagnostic getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String diagnosticName = ResourceManagerUtils.getValueFromIdByName(id, "diagnostics");
        if (diagnosticName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'diagnostics'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, diagnosticName, Context.NONE).getValue();
    }

    public Response<Diagnostic> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String diagnosticName = ResourceManagerUtils.getValueFromIdByName(id, "diagnostics");
        if (diagnosticName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'diagnostics'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, diagnosticName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String diagnosticName = ResourceManagerUtils.getValueFromIdByName(id, "diagnostics");
        if (diagnosticName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'diagnostics'.", id)));
        }
        this.delete(resourceGroupName, diagnosticName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String diagnosticName = ResourceManagerUtils.getValueFromIdByName(id, "diagnostics");
        if (diagnosticName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'diagnostics'.", id)));
        }
        this.delete(resourceGroupName, diagnosticName, context);
    }

    private DiagnosticsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public DiagnosticImpl define(String name) {
        return new DiagnosticImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/DynamicSchemaImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchema;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties;

public final class DynamicSchemaImpl implements DynamicSchema, DynamicSchema.Definition, DynamicSchema.Update {
    private DynamicSchemaInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public DynamicSchemaProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public DynamicSchemaInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String schemaName;

    private String dynamicSchemaName;

    public DynamicSchemaImpl withExistingSchema(String resourceGroupName, String schemaName) {
        this.resourceGroupName = resourceGroupName;
        this.schemaName = schemaName;
        return this;
    }

    public DynamicSchema create() {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemas()
            .createOrUpdate(resourceGroupName, schemaName, dynamicSchemaName, this.innerModel(), Context.NONE);
        return this;
    }

    public DynamicSchema create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemas()
            .createOrUpdate(resourceGroupName, schemaName, dynamicSchemaName, this.innerModel(), context);
        return this;
    }

    DynamicSchemaImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new DynamicSchemaInner();
        this.serviceManager = serviceManager;
        this.dynamicSchemaName = name;
    }

    public DynamicSchemaImpl update() {
        return this;
    }

    public DynamicSchema apply() {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemas()
            .updateWithResponse(resourceGroupName, schemaName, dynamicSchemaName, this.innerModel(), Context.NONE)
            .getValue();
        return this;
    }

    public DynamicSchema apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemas()
            .updateWithResponse(resourceGroupName, schemaName, dynamicSchemaName, this.innerModel(), context)
            .getValue();
        return this;
    }

    DynamicSchemaImpl(DynamicSchemaInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.schemaName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "schemas");
        this.dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "dynamicSchemas");
    }

    public DynamicSchema refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemas()
            .getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, Context.NONE)
            .getValue();
        return this;
    }

    public DynamicSchema refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemas()
            .getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, context)
            .getValue();
        return this;
    }

    public DynamicSchemaImpl withProperties(DynamicSchemaProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/DynamicSchemasClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.DynamicSchemaListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in DynamicSchemasClient.
 */
public final class DynamicSchemasClientImpl implements DynamicSchemasClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final DynamicSchemasService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of DynamicSchemasClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    DynamicSchemasClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(DynamicSchemasService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientDynamicSchemas to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientDynamicSchemas")
    public interface DynamicSchemasService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DynamicSchemaInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DynamicSchemaInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, @HeaderParam("Accept") String accept,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") DynamicSchemaInner resource,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") DynamicSchemaInner resource,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DynamicSchemaInner>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") DynamicSchemaInner properties,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DynamicSchemaInner> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") DynamicSchemaInner properties,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DynamicSchemaListResult>> listBySchema(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DynamicSchemaListResult> listBySchemaSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DynamicSchemaListResult>> listBySchemaNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DynamicSchemaListResult> listBySchemaNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<DynamicSchemaInner>> getWithResponseAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<DynamicSchemaInner> getAsync(String resourceGroupName, String schemaName, String dynamicSchemaName) {
        return getWithResponseAsync(resourceGroupName, schemaName, dynamicSchemaName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DynamicSchemaInner> getWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, schemaName, dynamicSchemaName, accept, context);
    }

    /**
     * Get a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DynamicSchemaInner get(String resourceGroupName, String schemaName, String dynamicSchemaName) {
        return getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, Context.NONE).getValue();
    }

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String schemaName, String dynamicSchemaName, DynamicSchemaInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, contentType, accept,
                resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, DynamicSchemaInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, contentType, accept,
            resource, Context.NONE);
    }

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, DynamicSchemaInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, contentType, accept,
            resource, context);
    }

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<DynamicSchemaInner>, DynamicSchemaInner> beginCreateOrUpdateAsync(
        String resourceGroupName, String schemaName, String dynamicSchemaName, DynamicSchemaInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, schemaName, dynamicSchemaName, resource);
        return this.client.<DynamicSchemaInner, DynamicSchemaInner>getLroResult(mono, this.client.getHttpPipeline(),
            DynamicSchemaInner.class, DynamicSchemaInner.class, this.client.getContext());
    }

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<DynamicSchemaInner>, DynamicSchemaInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, String dynamicSchemaName, DynamicSchemaInner resource) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, schemaName, dynamicSchemaName, resource);
        return this.client.<DynamicSchemaInner, DynamicSchemaInner>getLroResult(response, DynamicSchemaInner.class,
            DynamicSchemaInner.class, Context.NONE);
    }

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<DynamicSchemaInner>, DynamicSchemaInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, String dynamicSchemaName, DynamicSchemaInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, schemaName, dynamicSchemaName, resource, context);
        return this.client.<DynamicSchemaInner, DynamicSchemaInner>getLroResult(response, DynamicSchemaInner.class,
            DynamicSchemaInner.class, context);
    }

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<DynamicSchemaInner> createOrUpdateAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName, DynamicSchemaInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, schemaName, dynamicSchemaName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DynamicSchemaInner createOrUpdate(String resourceGroupName, String schemaName, String dynamicSchemaName,
        DynamicSchemaInner resource) {
        return beginCreateOrUpdate(resourceGroupName, schemaName, dynamicSchemaName, resource).getFinalResult();
    }

    /**
     * Create or update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DynamicSchemaInner createOrUpdate(String resourceGroupName, String schemaName, String dynamicSchemaName,
        DynamicSchemaInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, schemaName, dynamicSchemaName, resource, context)
            .getFinalResult();
    }

    /**
     * update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<DynamicSchemaInner>> updateWithResponseAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName, DynamicSchemaInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, contentType, accept,
                properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<DynamicSchemaInner> updateAsync(String resourceGroupName, String schemaName, String dynamicSchemaName,
        DynamicSchemaInner properties) {
        return updateWithResponseAsync(resourceGroupName, schemaName, dynamicSchemaName, properties)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DynamicSchemaInner> updateWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, DynamicSchemaInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, contentType, accept,
            properties, context);
    }

    /**
     * update a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamicSchema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DynamicSchemaInner update(String resourceGroupName, String schemaName, String dynamicSchemaName,
        DynamicSchemaInner properties) {
        return updateWithResponse(resourceGroupName, schemaName, dynamicSchemaName, properties, Context.NONE)
            .getValue();
    }

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, Context.NONE);
    }

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, context);
    }

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = deleteWithResponseAsync(resourceGroupName, schemaName, dynamicSchemaName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String dynamicSchemaName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, schemaName, dynamicSchemaName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String dynamicSchemaName, Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, schemaName, dynamicSchemaName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String schemaName, String dynamicSchemaName) {
        return beginDeleteAsync(resourceGroupName, schemaName, dynamicSchemaName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String schemaName, String dynamicSchemaName) {
        beginDelete(resourceGroupName, schemaName, dynamicSchemaName).getFinalResult();
    }

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String schemaName, String dynamicSchemaName, Context context) {
        beginDelete(resourceGroupName, schemaName, dynamicSchemaName, context).getFinalResult();
    }

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DynamicSchemaInner>> listBySchemaSinglePageAsync(String resourceGroupName,
        String schemaName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listBySchema(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, accept, context))
            .<PagedResponse<DynamicSchemaInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<DynamicSchemaInner> listBySchemaAsync(String resourceGroupName, String schemaName) {
        return new PagedFlux<>(() -> listBySchemaSinglePageAsync(resourceGroupName, schemaName),
            nextLink -> listBySchemaNextSinglePageAsync(nextLink));
    }

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DynamicSchemaInner> listBySchemaSinglePage(String resourceGroupName, String schemaName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DynamicSchemaListResult> res
            = service.listBySchemaSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DynamicSchemaInner> listBySchemaSinglePage(String resourceGroupName, String schemaName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DynamicSchemaListResult> res
            = service.listBySchemaSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DynamicSchemaInner> listBySchema(String resourceGroupName, String schemaName) {
        return new PagedIterable<>(() -> listBySchemaSinglePage(resourceGroupName, schemaName),
            nextLink -> listBySchemaNextSinglePage(nextLink));
    }

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DynamicSchemaInner> listBySchema(String resourceGroupName, String schemaName,
        Context context) {
        return new PagedIterable<>(() -> listBySchemaSinglePage(resourceGroupName, schemaName, context),
            nextLink -> listBySchemaNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DynamicSchemaInner>> listBySchemaNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listBySchemaNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<DynamicSchemaInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DynamicSchemaInner> listBySchemaNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DynamicSchemaListResult> res
            = service.listBySchemaNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DynamicSchemaInner> listBySchemaNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DynamicSchemaListResult> res
            = service.listBySchemaNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(DynamicSchemasClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/DynamicSchemasImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchema;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemas;

public final class DynamicSchemasImpl implements DynamicSchemas {
    private static final ClientLogger LOGGER = new ClientLogger(DynamicSchemasImpl.class);

    private final DynamicSchemasClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public DynamicSchemasImpl(DynamicSchemasClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<DynamicSchema> getWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, Context context) {
        Response<DynamicSchemaInner> inner
            = this.serviceClient().getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new DynamicSchemaImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public DynamicSchema get(String resourceGroupName, String schemaName, String dynamicSchemaName) {
        DynamicSchemaInner inner = this.serviceClient().get(resourceGroupName, schemaName, dynamicSchemaName);
        if (inner != null) {
            return new DynamicSchemaImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String schemaName, String dynamicSchemaName) {
        this.serviceClient().delete(resourceGroupName, schemaName, dynamicSchemaName);
    }

    public void delete(String resourceGroupName, String schemaName, String dynamicSchemaName, Context context) {
        this.serviceClient().delete(resourceGroupName, schemaName, dynamicSchemaName, context);
    }

    public PagedIterable<DynamicSchema> listBySchema(String resourceGroupName, String schemaName) {
        PagedIterable<DynamicSchemaInner> inner = this.serviceClient().listBySchema(resourceGroupName, schemaName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new DynamicSchemaImpl(inner1, this.manager()));
    }

    public PagedIterable<DynamicSchema> listBySchema(String resourceGroupName, String schemaName, Context context) {
        PagedIterable<DynamicSchemaInner> inner
            = this.serviceClient().listBySchema(resourceGroupName, schemaName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new DynamicSchemaImpl(inner1, this.manager()));
    }

    public DynamicSchema getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(id, "dynamicSchemas");
        if (dynamicSchemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'dynamicSchemas'.", id)));
        }
        return this.getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, Context.NONE).getValue();
    }

    public Response<DynamicSchema> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(id, "dynamicSchemas");
        if (dynamicSchemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'dynamicSchemas'.", id)));
        }
        return this.getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(id, "dynamicSchemas");
        if (dynamicSchemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'dynamicSchemas'.", id)));
        }
        this.delete(resourceGroupName, schemaName, dynamicSchemaName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(id, "dynamicSchemas");
        if (dynamicSchemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'dynamicSchemas'.", id)));
        }
        this.delete(resourceGroupName, schemaName, dynamicSchemaName, context);
    }

    private DynamicSchemasClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public DynamicSchemaImpl define(String name) {
        return new DynamicSchemaImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/DynamicSchemaVersionImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

public final class DynamicSchemaVersionImpl
    implements DynamicSchemaVersion, DynamicSchemaVersion.Definition, DynamicSchemaVersion.Update {
    private DynamicSchemaVersionInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public SchemaVersionProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public DynamicSchemaVersionInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String schemaName;

    private String dynamicSchemaName;

    private String dynamicSchemaVersionName;

    public DynamicSchemaVersionImpl withExistingDynamicSchema(String resourceGroupName, String schemaName,
        String dynamicSchemaName) {
        this.resourceGroupName = resourceGroupName;
        this.schemaName = schemaName;
        this.dynamicSchemaName = dynamicSchemaName;
        return this;
    }

    public DynamicSchemaVersion create() {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemaVersions()
            .createOrUpdate(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
                this.innerModel(), Context.NONE);
        return this;
    }

    public DynamicSchemaVersion create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemaVersions()
            .createOrUpdate(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
                this.innerModel(), context);
        return this;
    }

    DynamicSchemaVersionImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new DynamicSchemaVersionInner();
        this.serviceManager = serviceManager;
        this.dynamicSchemaVersionName = name;
    }

    public DynamicSchemaVersionImpl update() {
        return this;
    }

    public DynamicSchemaVersion apply() {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemaVersions()
            .updateWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
                this.innerModel(), Context.NONE)
            .getValue();
        return this;
    }

    public DynamicSchemaVersion apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemaVersions()
            .updateWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
                this.innerModel(), context)
            .getValue();
        return this;
    }

    DynamicSchemaVersionImpl(DynamicSchemaVersionInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.schemaName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "schemas");
        this.dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "dynamicSchemas");
        this.dynamicSchemaVersionName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "versions");
    }

    public DynamicSchemaVersion refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemaVersions()
            .getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, Context.NONE)
            .getValue();
        return this;
    }

    public DynamicSchemaVersion refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getDynamicSchemaVersions()
            .getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, context)
            .getValue();
        return this;
    }

    public DynamicSchemaVersionImpl withProperties(SchemaVersionProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/DynamicSchemaVersionsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.DynamicSchemaVersionListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in DynamicSchemaVersionsClient.
 */
public final class DynamicSchemaVersionsClientImpl implements DynamicSchemaVersionsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final DynamicSchemaVersionsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of DynamicSchemaVersionsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    DynamicSchemaVersionsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service = RestProxy.create(DynamicSchemaVersionsService.class, client.getHttpPipeline(),
            client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientDynamicSchemaVersions to be used
     * by the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientDynamicSchemaVersions")
    public interface DynamicSchemaVersionsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DynamicSchemaVersionInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName,
            @PathParam("dynamicSchemaVersionName") String dynamicSchemaVersionName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DynamicSchemaVersionInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName,
            @PathParam("dynamicSchemaVersionName") String dynamicSchemaVersionName,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName,
            @PathParam("dynamicSchemaVersionName") String dynamicSchemaVersionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") DynamicSchemaVersionInner resource, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName,
            @PathParam("dynamicSchemaVersionName") String dynamicSchemaVersionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") DynamicSchemaVersionInner resource, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DynamicSchemaVersionInner>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName,
            @PathParam("dynamicSchemaVersionName") String dynamicSchemaVersionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") DynamicSchemaVersionInner properties, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DynamicSchemaVersionInner> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName,
            @PathParam("dynamicSchemaVersionName") String dynamicSchemaVersionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") DynamicSchemaVersionInner properties, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName,
            @PathParam("dynamicSchemaVersionName") String dynamicSchemaVersionName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName,
            @PathParam("dynamicSchemaVersionName") String dynamicSchemaVersionName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DynamicSchemaVersionListResult>> listByDynamicSchema(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DynamicSchemaVersionListResult> listByDynamicSchemaSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("dynamicSchemaName") String dynamicSchemaName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<DynamicSchemaVersionListResult>> listByDynamicSchemaNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<DynamicSchemaVersionListResult> listByDynamicSchemaNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<DynamicSchemaVersionInner>> getWithResponseAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName,
                dynamicSchemaVersionName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<DynamicSchemaVersionInner> getAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName) {
        return getWithResponseAsync(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DynamicSchemaVersionInner> getWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, accept, context);
    }

    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DynamicSchemaVersionInner get(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName) {
        return getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, Context.NONE)
            .getValue();
    }

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName,
        DynamicSchemaVersionInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName,
                dynamicSchemaVersionName, contentType, accept, resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, DynamicSchemaVersionInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
            contentType, accept, resource, Context.NONE);
    }

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, DynamicSchemaVersionInner resource,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
            contentType, accept, resource, context);
    }

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<DynamicSchemaVersionInner>, DynamicSchemaVersionInner> beginCreateOrUpdateAsync(
        String resourceGroupName, String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName,
        DynamicSchemaVersionInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono = createOrUpdateWithResponseAsync(resourceGroupName, schemaName,
            dynamicSchemaName, dynamicSchemaVersionName, resource);
        return this.client.<DynamicSchemaVersionInner, DynamicSchemaVersionInner>getLroResult(mono,
            this.client.getHttpPipeline(), DynamicSchemaVersionInner.class, DynamicSchemaVersionInner.class,
            this.client.getContext());
    }

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<DynamicSchemaVersionInner>, DynamicSchemaVersionInner> beginCreateOrUpdate(
        String resourceGroupName, String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName,
        DynamicSchemaVersionInner resource) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, schemaName, dynamicSchemaName,
            dynamicSchemaVersionName, resource);
        return this.client.<DynamicSchemaVersionInner, DynamicSchemaVersionInner>getLroResult(response,
            DynamicSchemaVersionInner.class, DynamicSchemaVersionInner.class, Context.NONE);
    }

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<DynamicSchemaVersionInner>, DynamicSchemaVersionInner> beginCreateOrUpdate(
        String resourceGroupName, String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName,
        DynamicSchemaVersionInner resource, Context context) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, schemaName, dynamicSchemaName,
            dynamicSchemaVersionName, resource, context);
        return this.client.<DynamicSchemaVersionInner, DynamicSchemaVersionInner>getLroResult(response,
            DynamicSchemaVersionInner.class, DynamicSchemaVersionInner.class, context);
    }

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<DynamicSchemaVersionInner> createOrUpdateAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, DynamicSchemaVersionInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
            resource).last().flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DynamicSchemaVersionInner createOrUpdate(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, DynamicSchemaVersionInner resource) {
        return beginCreateOrUpdate(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, resource)
            .getFinalResult();
    }

    /**
     * Create or update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DynamicSchemaVersionInner createOrUpdate(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, DynamicSchemaVersionInner resource,
        Context context) {
        return beginCreateOrUpdate(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, resource,
            context).getFinalResult();
    }

    /**
     * update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<DynamicSchemaVersionInner>> updateWithResponseAsync(String resourceGroupName,
        String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName,
        DynamicSchemaVersionInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName,
                dynamicSchemaVersionName, contentType, accept, properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<DynamicSchemaVersionInner> updateAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, DynamicSchemaVersionInner properties) {
        return updateWithResponseAsync(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
            properties).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<DynamicSchemaVersionInner> updateWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, DynamicSchemaVersionInner properties,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
            contentType, accept, properties, context);
    }

    /**
     * update a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return dynamic Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DynamicSchemaVersionInner update(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName, DynamicSchemaVersionInner properties) {
        return updateWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
            properties, Context.NONE).getValue();
    }

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName,
                dynamicSchemaVersionName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
            Context.NONE);
    }

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Parameter dynamicSchemaVersionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
            context);
    }

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = deleteWithResponseAsync(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName) {
        Response<BinaryData> response
            = deleteWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, Context context) {
        Response<BinaryData> response
            = deleteWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName) {
        return beginDeleteAsync(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName) {
        beginDelete(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName).getFinalResult();
    }

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName, Context context) {
        beginDelete(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, context)
            .getFinalResult();
    }

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DynamicSchemaVersionInner>> listByDynamicSchemaSinglePageAsync(String resourceGroupName,
        String schemaName, String dynamicSchemaName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByDynamicSchema(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, accept, context))
            .<PagedResponse<DynamicSchemaVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<DynamicSchemaVersionInner> listByDynamicSchemaAsync(String resourceGroupName, String schemaName,
        String dynamicSchemaName) {
        return new PagedFlux<>(
            () -> listByDynamicSchemaSinglePageAsync(resourceGroupName, schemaName, dynamicSchemaName),
            nextLink -> listByDynamicSchemaNextSinglePageAsync(nextLink));
    }

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DynamicSchemaVersionInner> listByDynamicSchemaSinglePage(String resourceGroupName,
        String schemaName, String dynamicSchemaName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DynamicSchemaVersionListResult> res = service.listByDynamicSchemaSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, schemaName,
            dynamicSchemaName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DynamicSchemaVersionInner> listByDynamicSchemaSinglePage(String resourceGroupName,
        String schemaName, String dynamicSchemaName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (dynamicSchemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter dynamicSchemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DynamicSchemaVersionListResult> res
            = service.listByDynamicSchemaSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, dynamicSchemaName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DynamicSchemaVersionInner> listByDynamicSchema(String resourceGroupName, String schemaName,
        String dynamicSchemaName) {
        return new PagedIterable<>(
            () -> listByDynamicSchemaSinglePage(resourceGroupName, schemaName, dynamicSchemaName),
            nextLink -> listByDynamicSchemaNextSinglePage(nextLink));
    }

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DynamicSchemaVersionInner> listByDynamicSchema(String resourceGroupName, String schemaName,
        String dynamicSchemaName, Context context) {
        return new PagedIterable<>(
            () -> listByDynamicSchemaSinglePage(resourceGroupName, schemaName, dynamicSchemaName, context),
            nextLink -> listByDynamicSchemaNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<DynamicSchemaVersionInner>> listByDynamicSchemaNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByDynamicSchemaNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<DynamicSchemaVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DynamicSchemaVersionInner> listByDynamicSchemaNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DynamicSchemaVersionListResult> res
            = service.listByDynamicSchemaNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<DynamicSchemaVersionInner> listByDynamicSchemaNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<DynamicSchemaVersionListResult> res
            = service.listByDynamicSchemaNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(DynamicSchemaVersionsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/DynamicSchemaVersionsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaVersions;

public final class DynamicSchemaVersionsImpl implements DynamicSchemaVersions {
    private static final ClientLogger LOGGER = new ClientLogger(DynamicSchemaVersionsImpl.class);

    private final DynamicSchemaVersionsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public DynamicSchemaVersionsImpl(DynamicSchemaVersionsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<DynamicSchemaVersion> getWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, Context context) {
        Response<DynamicSchemaVersionInner> inner = this.serviceClient()
            .getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new DynamicSchemaVersionImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public DynamicSchemaVersion get(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName) {
        DynamicSchemaVersionInner inner
            = this.serviceClient().get(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName);
        if (inner != null) {
            return new DynamicSchemaVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName) {
        this.serviceClient().delete(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName);
    }

    public void delete(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName, Context context) {
        this.serviceClient()
            .delete(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, context);
    }

    public PagedIterable<DynamicSchemaVersion> listByDynamicSchema(String resourceGroupName, String schemaName,
        String dynamicSchemaName) {
        PagedIterable<DynamicSchemaVersionInner> inner
            = this.serviceClient().listByDynamicSchema(resourceGroupName, schemaName, dynamicSchemaName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new DynamicSchemaVersionImpl(inner1, this.manager()));
    }

    public PagedIterable<DynamicSchemaVersion> listByDynamicSchema(String resourceGroupName, String schemaName,
        String dynamicSchemaName, Context context) {
        PagedIterable<DynamicSchemaVersionInner> inner
            = this.serviceClient().listByDynamicSchema(resourceGroupName, schemaName, dynamicSchemaName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new DynamicSchemaVersionImpl(inner1, this.manager()));
    }

    public DynamicSchemaVersion getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(id, "dynamicSchemas");
        if (dynamicSchemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'dynamicSchemas'.", id)));
        }
        String dynamicSchemaVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        return this
            .getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, Context.NONE)
            .getValue();
    }

    public Response<DynamicSchemaVersion> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(id, "dynamicSchemas");
        if (dynamicSchemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'dynamicSchemas'.", id)));
        }
        String dynamicSchemaVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName,
            context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(id, "dynamicSchemas");
        if (dynamicSchemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'dynamicSchemas'.", id)));
        }
        String dynamicSchemaVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        this.delete(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String dynamicSchemaName = ResourceManagerUtils.getValueFromIdByName(id, "dynamicSchemas");
        if (dynamicSchemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'dynamicSchemas'.", id)));
        }
        String dynamicSchemaVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (dynamicSchemaVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        this.delete(resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, context);
    }

    private DynamicSchemaVersionsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public DynamicSchemaVersionImpl define(String name) {
        return new DynamicSchemaVersionImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ExecutionImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner;
import com.azure.resourcemanager.workloadorchestration.models.Execution;
import com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;

public final class ExecutionImpl implements Execution, Execution.Definition, Execution.Update {
    private ExecutionInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public ExecutionProperties properties() {
        return this.innerModel().properties();
    }

    public ExtendedLocation extendedLocation() {
        return this.innerModel().extendedLocation();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public ExecutionInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String contextName;

    private String workflowName;

    private String versionName;

    private String executionName;

    public ExecutionImpl withExistingVersion(String resourceGroupName, String contextName, String workflowName,
        String versionName) {
        this.resourceGroupName = resourceGroupName;
        this.contextName = contextName;
        this.workflowName = workflowName;
        this.versionName = versionName;
        return this;
    }

    public Execution create() {
        this.innerObject = serviceManager.serviceClient()
            .getExecutions()
            .createOrUpdate(resourceGroupName, contextName, workflowName, versionName, executionName, this.innerModel(),
                Context.NONE);
        return this;
    }

    public Execution create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getExecutions()
            .createOrUpdate(resourceGroupName, contextName, workflowName, versionName, executionName, this.innerModel(),
                context);
        return this;
    }

    ExecutionImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new ExecutionInner();
        this.serviceManager = serviceManager;
        this.executionName = name;
    }

    public ExecutionImpl update() {
        return this;
    }

    public Execution apply() {
        this.innerObject = serviceManager.serviceClient()
            .getExecutions()
            .update(resourceGroupName, contextName, workflowName, versionName, executionName, this.innerModel(),
                Context.NONE);
        return this;
    }

    public Execution apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getExecutions()
            .update(resourceGroupName, contextName, workflowName, versionName, executionName, this.innerModel(),
                context);
        return this;
    }

    ExecutionImpl(ExecutionInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.contextName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "contexts");
        this.workflowName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "workflows");
        this.versionName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "versions");
        this.executionName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "executions");
    }

    public Execution refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getExecutions()
            .getWithResponse(resourceGroupName, contextName, workflowName, versionName, executionName, Context.NONE)
            .getValue();
        return this;
    }

    public Execution refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getExecutions()
            .getWithResponse(resourceGroupName, contextName, workflowName, versionName, executionName, context)
            .getValue();
        return this;
    }

    public ExecutionImpl withProperties(ExecutionProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }

    public ExecutionImpl withExtendedLocation(ExtendedLocation extendedLocation) {
        this.innerModel().withExtendedLocation(extendedLocation);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ExecutionsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.ExecutionListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in ExecutionsClient.
 */
public final class ExecutionsClientImpl implements ExecutionsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final ExecutionsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of ExecutionsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    ExecutionsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(ExecutionsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientExecutions to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientExecutions")
    public interface ExecutionsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ExecutionInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @PathParam("executionName") String executionName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ExecutionInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @PathParam("executionName") String executionName, @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @PathParam("executionName") String executionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") ExecutionInner resource,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @PathParam("executionName") String executionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") ExecutionInner resource,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @PathParam("executionName") String executionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") ExecutionInner properties,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @PathParam("executionName") String executionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") ExecutionInner properties,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @PathParam("executionName") String executionName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @PathParam("executionName") String executionName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ExecutionListResult>> listByWorkflowVersion(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ExecutionListResult> listByWorkflowVersionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<ExecutionListResult>> listByWorkflowVersionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<ExecutionListResult> listByWorkflowVersionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<ExecutionInner>> getWithResponseAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName,
                executionName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ExecutionInner> getAsync(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName) {
        return getWithResponseAsync(resourceGroupName, contextName, workflowName, versionName, executionName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<ExecutionInner> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, contextName, workflowName, versionName, executionName, accept, context);
    }

    /**
     * Get Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExecutionInner get(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName) {
        return getWithResponse(resourceGroupName, contextName, workflowName, versionName, executionName, Context.NONE)
            .getValue();
    }

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String contextName, String workflowName, String versionName, String executionName, ExecutionInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName,
                executionName, contentType, accept, resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName, ExecutionInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, executionName,
            contentType, accept, resource, Context.NONE);
    }

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName, ExecutionInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, executionName,
            contentType, accept, resource, context);
    }

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<ExecutionInner>, ExecutionInner> beginCreateOrUpdateAsync(String resourceGroupName,
        String contextName, String workflowName, String versionName, String executionName, ExecutionInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono = createOrUpdateWithResponseAsync(resourceGroupName, contextName,
            workflowName, versionName, executionName, resource);
        return this.client.<ExecutionInner, ExecutionInner>getLroResult(mono, this.client.getHttpPipeline(),
            ExecutionInner.class, ExecutionInner.class, this.client.getContext());
    }

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ExecutionInner>, ExecutionInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, String executionName, ExecutionInner resource) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, contextName, workflowName,
            versionName, executionName, resource);
        return this.client.<ExecutionInner, ExecutionInner>getLroResult(response, ExecutionInner.class,
            ExecutionInner.class, Context.NONE);
    }

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ExecutionInner>, ExecutionInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, String executionName, ExecutionInner resource,
        Context context) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, contextName, workflowName,
            versionName, executionName, resource, context);
        return this.client.<ExecutionInner, ExecutionInner>getLroResult(response, ExecutionInner.class,
            ExecutionInner.class, context);
    }

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ExecutionInner> createOrUpdateAsync(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, ExecutionInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, contextName, workflowName, versionName, executionName,
            resource).last().flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExecutionInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, ExecutionInner resource) {
        return beginCreateOrUpdate(resourceGroupName, contextName, workflowName, versionName, executionName, resource)
            .getFinalResult();
    }

    /**
     * Create or update Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExecutionInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, ExecutionInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, contextName, workflowName, versionName, executionName, resource,
            context).getFinalResult();
    }

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName, ExecutionInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName,
                executionName, contentType, accept, properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, ExecutionInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, executionName,
            contentType, accept, properties, Context.NONE);
    }

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, ExecutionInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, executionName,
            contentType, accept, properties, context);
    }

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<ExecutionInner>, ExecutionInner> beginUpdateAsync(String resourceGroupName,
        String contextName, String workflowName, String versionName, String executionName, ExecutionInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono = updateWithResponseAsync(resourceGroupName, contextName, workflowName,
            versionName, executionName, properties);
        return this.client.<ExecutionInner, ExecutionInner>getLroResult(mono, this.client.getHttpPipeline(),
            ExecutionInner.class, ExecutionInner.class, this.client.getContext());
    }

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ExecutionInner>, ExecutionInner> beginUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, String executionName, ExecutionInner properties) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, contextName, workflowName, versionName, executionName, properties);
        return this.client.<ExecutionInner, ExecutionInner>getLroResult(response, ExecutionInner.class,
            ExecutionInner.class, Context.NONE);
    }

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of execution Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ExecutionInner>, ExecutionInner> beginUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, String executionName, ExecutionInner properties,
        Context context) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, contextName, workflowName, versionName,
            executionName, properties, context);
        return this.client.<ExecutionInner, ExecutionInner>getLroResult(response, ExecutionInner.class,
            ExecutionInner.class, context);
    }

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ExecutionInner> updateAsync(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, ExecutionInner properties) {
        return beginUpdateAsync(resourceGroupName, contextName, workflowName, versionName, executionName, properties)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExecutionInner update(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, ExecutionInner properties) {
        return beginUpdate(resourceGroupName, contextName, workflowName, versionName, executionName, properties)
            .getFinalResult();
    }

    /**
     * update an Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ExecutionInner update(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, ExecutionInner properties, Context context) {
        return beginUpdate(resourceGroupName, contextName, workflowName, versionName, executionName, properties,
            context).getFinalResult();
    }

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName,
                executionName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, executionName,
            Context.NONE);
    }

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (executionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter executionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, executionName,
            context);
    }

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = deleteWithResponseAsync(resourceGroupName, contextName, workflowName, versionName, executionName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName) {
        Response<BinaryData> response
            = deleteWithResponse(resourceGroupName, contextName, workflowName, versionName, executionName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String workflowName, String versionName, String executionName, Context context) {
        Response<BinaryData> response
            = deleteWithResponse(resourceGroupName, contextName, workflowName, versionName, executionName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName) {
        return beginDeleteAsync(resourceGroupName, contextName, workflowName, versionName, executionName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName) {
        beginDelete(resourceGroupName, contextName, workflowName, versionName, executionName).getFinalResult();
    }

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, Context context) {
        beginDelete(resourceGroupName, contextName, workflowName, versionName, executionName, context).getFinalResult();
    }

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ExecutionInner>> listByWorkflowVersionSinglePageAsync(String resourceGroupName,
        String contextName, String workflowName, String versionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByWorkflowVersion(this.client.getEndpoint(),
                this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, contextName,
                workflowName, versionName, accept, context))
            .<PagedResponse<ExecutionInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<ExecutionInner> listByWorkflowVersionAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName) {
        return new PagedFlux<>(
            () -> listByWorkflowVersionSinglePageAsync(resourceGroupName, contextName, workflowName, versionName),
            nextLink -> listByWorkflowVersionNextSinglePageAsync(nextLink));
    }

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ExecutionInner> listByWorkflowVersionSinglePage(String resourceGroupName, String contextName,
        String workflowName, String versionName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ExecutionListResult> res = service.listByWorkflowVersionSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName,
            versionName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ExecutionInner> listByWorkflowVersionSinglePage(String resourceGroupName, String contextName,
        String workflowName, String versionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ExecutionListResult> res = service.listByWorkflowVersionSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName,
            versionName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ExecutionInner> listByWorkflowVersion(String resourceGroupName, String contextName,
        String workflowName, String versionName) {
        return new PagedIterable<>(
            () -> listByWorkflowVersionSinglePage(resourceGroupName, contextName, workflowName, versionName),
            nextLink -> listByWorkflowVersionNextSinglePage(nextLink));
    }

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<ExecutionInner> listByWorkflowVersion(String resourceGroupName, String contextName,
        String workflowName, String versionName, Context context) {
        return new PagedIterable<>(
            () -> listByWorkflowVersionSinglePage(resourceGroupName, contextName, workflowName, versionName, context),
            nextLink -> listByWorkflowVersionNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<ExecutionInner>> listByWorkflowVersionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByWorkflowVersionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<ExecutionInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ExecutionInner> listByWorkflowVersionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ExecutionListResult> res
            = service.listByWorkflowVersionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<ExecutionInner> listByWorkflowVersionNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<ExecutionListResult> res
            = service.listByWorkflowVersionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(ExecutionsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ExecutionsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner;
import com.azure.resourcemanager.workloadorchestration.models.Execution;
import com.azure.resourcemanager.workloadorchestration.models.Executions;

public final class ExecutionsImpl implements Executions {
    private static final ClientLogger LOGGER = new ClientLogger(ExecutionsImpl.class);

    private final ExecutionsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public ExecutionsImpl(ExecutionsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<Execution> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, Context context) {
        Response<ExecutionInner> inner = this.serviceClient()
            .getWithResponse(resourceGroupName, contextName, workflowName, versionName, executionName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new ExecutionImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public Execution get(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName) {
        ExecutionInner inner
            = this.serviceClient().get(resourceGroupName, contextName, workflowName, versionName, executionName);
        if (inner != null) {
            return new ExecutionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName) {
        this.serviceClient().delete(resourceGroupName, contextName, workflowName, versionName, executionName);
    }

    public void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, Context context) {
        this.serviceClient().delete(resourceGroupName, contextName, workflowName, versionName, executionName, context);
    }

    public PagedIterable<Execution> listByWorkflowVersion(String resourceGroupName, String contextName,
        String workflowName, String versionName) {
        PagedIterable<ExecutionInner> inner
            = this.serviceClient().listByWorkflowVersion(resourceGroupName, contextName, workflowName, versionName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ExecutionImpl(inner1, this.manager()));
    }

    public PagedIterable<Execution> listByWorkflowVersion(String resourceGroupName, String contextName,
        String workflowName, String versionName, Context context) {
        PagedIterable<ExecutionInner> inner = this.serviceClient()
            .listByWorkflowVersion(resourceGroupName, contextName, workflowName, versionName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new ExecutionImpl(inner1, this.manager()));
    }

    public Execution getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        String versionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (versionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        String executionName = ResourceManagerUtils.getValueFromIdByName(id, "executions");
        if (executionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'executions'.", id)));
        }
        return this
            .getWithResponse(resourceGroupName, contextName, workflowName, versionName, executionName, Context.NONE)
            .getValue();
    }

    public Response<Execution> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        String versionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (versionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        String executionName = ResourceManagerUtils.getValueFromIdByName(id, "executions");
        if (executionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'executions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, contextName, workflowName, versionName, executionName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        String versionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (versionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        String executionName = ResourceManagerUtils.getValueFromIdByName(id, "executions");
        if (executionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'executions'.", id)));
        }
        this.delete(resourceGroupName, contextName, workflowName, versionName, executionName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        String versionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (versionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        String executionName = ResourceManagerUtils.getValueFromIdByName(id, "executions");
        if (executionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'executions'.", id)));
        }
        this.delete(resourceGroupName, contextName, workflowName, versionName, executionName, context);
    }

    private ExecutionsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public ExecutionImpl define(String name) {
        return new ExecutionImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/InstanceHistoriesClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.InstanceHistoryListResult;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in InstanceHistoriesClient.
 */
public final class InstanceHistoriesClientImpl implements InstanceHistoriesClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final InstanceHistoriesService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of InstanceHistoriesClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    InstanceHistoriesClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(InstanceHistoriesService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientInstanceHistories to be used by
     * the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientInstanceHistories")
    public interface InstanceHistoriesService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<InstanceHistoryInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @PathParam("instanceHistoryName") String instanceHistoryName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<InstanceHistoryInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @PathParam("instanceHistoryName") String instanceHistoryName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<InstanceHistoryListResult>> listByInstance(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<InstanceHistoryListResult> listByInstanceSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<InstanceHistoryListResult>> listByInstanceNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<InstanceHistoryListResult> listByInstanceNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get InstanceHistory Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param instanceHistoryName Name of the instance history.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instanceHistory Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<InstanceHistoryInner>> getWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName, String instanceName, String instanceHistoryName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            return Mono.error(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        if (instanceHistoryName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter instanceHistoryName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName,
                instanceHistoryName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get InstanceHistory Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param instanceHistoryName Name of the instance history.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instanceHistory Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<InstanceHistoryInner> getAsync(String resourceGroupName, String targetName, String solutionName,
        String instanceName, String instanceHistoryName) {
        return getWithResponseAsync(resourceGroupName, targetName, solutionName, instanceName, instanceHistoryName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get InstanceHistory Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param instanceHistoryName Name of the instance history.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instanceHistory Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<InstanceHistoryInner> getWithResponse(String resourceGroupName, String targetName,
        String solutionName, String instanceName, String instanceHistoryName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        if (instanceHistoryName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceHistoryName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, targetName, solutionName, instanceName, instanceHistoryName, accept, context);
    }

    /**
     * Get InstanceHistory Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param instanceHistoryName Name of the instance history.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instanceHistory Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public InstanceHistoryInner get(String resourceGroupName, String targetName, String solutionName,
        String instanceName, String instanceHistoryName) {
        return getWithResponse(resourceGroupName, targetName, solutionName, instanceName, instanceHistoryName,
            Context.NONE).getValue();
    }

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<InstanceHistoryInner>> listByInstanceSinglePageAsync(String resourceGroupName,
        String targetName, String solutionName, String instanceName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            return Mono.error(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByInstance(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, accept,
                context))
            .<PagedResponse<InstanceHistoryInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<InstanceHistoryInner> listByInstanceAsync(String resourceGroupName, String targetName,
        String solutionName, String instanceName) {
        return new PagedFlux<>(
            () -> listByInstanceSinglePageAsync(resourceGroupName, targetName, solutionName, instanceName),
            nextLink -> listByInstanceNextSinglePageAsync(nextLink));
    }

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<InstanceHistoryInner> listByInstanceSinglePage(String resourceGroupName, String targetName,
        String solutionName, String instanceName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<InstanceHistoryListResult> res = service.listByInstanceSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName,
            instanceName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<InstanceHistoryInner> listByInstanceSinglePage(String resourceGroupName, String targetName,
        String solutionName, String instanceName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<InstanceHistoryListResult> res = service.listByInstanceSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName,
            instanceName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<InstanceHistoryInner> listByInstance(String resourceGroupName, String targetName,
        String solutionName, String instanceName) {
        return new PagedIterable<>(
            () -> listByInstanceSinglePage(resourceGroupName, targetName, solutionName, instanceName),
            nextLink -> listByInstanceNextSinglePage(nextLink));
    }

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<InstanceHistoryInner> listByInstance(String resourceGroupName, String targetName,
        String solutionName, String instanceName, Context context) {
        return new PagedIterable<>(
            () -> listByInstanceSinglePage(resourceGroupName, targetName, solutionName, instanceName, context),
            nextLink -> listByInstanceNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<InstanceHistoryInner>> listByInstanceNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByInstanceNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<InstanceHistoryInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<InstanceHistoryInner> listByInstanceNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<InstanceHistoryListResult> res
            = service.listByInstanceNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<InstanceHistoryInner> listByInstanceNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<InstanceHistoryListResult> res
            = service.listByInstanceNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(InstanceHistoriesClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/InstanceHistoriesImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner;
import com.azure.resourcemanager.workloadorchestration.models.InstanceHistories;
import com.azure.resourcemanager.workloadorchestration.models.InstanceHistory;

public final class InstanceHistoriesImpl implements InstanceHistories {
    private static final ClientLogger LOGGER = new ClientLogger(InstanceHistoriesImpl.class);

    private final InstanceHistoriesClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public InstanceHistoriesImpl(InstanceHistoriesClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<InstanceHistory> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, String instanceHistoryName, Context context) {
        Response<InstanceHistoryInner> inner = this.serviceClient()
            .getWithResponse(resourceGroupName, targetName, solutionName, instanceName, instanceHistoryName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new InstanceHistoryImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public InstanceHistory get(String resourceGroupName, String targetName, String solutionName, String instanceName,
        String instanceHistoryName) {
        InstanceHistoryInner inner
            = this.serviceClient().get(resourceGroupName, targetName, solutionName, instanceName, instanceHistoryName);
        if (inner != null) {
            return new InstanceHistoryImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public PagedIterable<InstanceHistory> listByInstance(String resourceGroupName, String targetName,
        String solutionName, String instanceName) {
        PagedIterable<InstanceHistoryInner> inner
            = this.serviceClient().listByInstance(resourceGroupName, targetName, solutionName, instanceName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new InstanceHistoryImpl(inner1, this.manager()));
    }

    public PagedIterable<InstanceHistory> listByInstance(String resourceGroupName, String targetName,
        String solutionName, String instanceName, Context context) {
        PagedIterable<InstanceHistoryInner> inner
            = this.serviceClient().listByInstance(resourceGroupName, targetName, solutionName, instanceName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new InstanceHistoryImpl(inner1, this.manager()));
    }

    private InstanceHistoriesClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/InstanceHistoryImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.InstanceHistory;
import com.azure.resourcemanager.workloadorchestration.models.InstanceHistoryProperties;

public final class InstanceHistoryImpl implements InstanceHistory {
    private InstanceHistoryInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    InstanceHistoryImpl(InstanceHistoryInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public InstanceHistoryProperties properties() {
        return this.innerModel().properties();
    }

    public ExtendedLocation extendedLocation() {
        return this.innerModel().extendedLocation();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public InstanceHistoryInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/InstanceImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.Instance;
import com.azure.resourcemanager.workloadorchestration.models.InstanceProperties;

public final class InstanceImpl implements Instance, Instance.Definition, Instance.Update {
    private InstanceInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public InstanceProperties properties() {
        return this.innerModel().properties();
    }

    public ExtendedLocation extendedLocation() {
        return this.innerModel().extendedLocation();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public InstanceInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String targetName;

    private String solutionName;

    private String instanceName;

    public InstanceImpl withExistingSolution(String resourceGroupName, String targetName, String solutionName) {
        this.resourceGroupName = resourceGroupName;
        this.targetName = targetName;
        this.solutionName = solutionName;
        return this;
    }

    public Instance create() {
        this.innerObject = serviceManager.serviceClient()
            .getInstances()
            .createOrUpdate(resourceGroupName, targetName, solutionName, instanceName, this.innerModel(), Context.NONE);
        return this;
    }

    public Instance create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getInstances()
            .createOrUpdate(resourceGroupName, targetName, solutionName, instanceName, this.innerModel(), context);
        return this;
    }

    InstanceImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new InstanceInner();
        this.serviceManager = serviceManager;
        this.instanceName = name;
    }

    public InstanceImpl update() {
        return this;
    }

    public Instance apply() {
        this.innerObject = serviceManager.serviceClient()
            .getInstances()
            .update(resourceGroupName, targetName, solutionName, instanceName, this.innerModel(), Context.NONE);
        return this;
    }

    public Instance apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getInstances()
            .update(resourceGroupName, targetName, solutionName, instanceName, this.innerModel(), context);
        return this;
    }

    InstanceImpl(InstanceInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.targetName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "targets");
        this.solutionName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "solutions");
        this.instanceName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "instances");
    }

    public Instance refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getInstances()
            .getWithResponse(resourceGroupName, targetName, solutionName, instanceName, Context.NONE)
            .getValue();
        return this;
    }

    public Instance refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getInstances()
            .getWithResponse(resourceGroupName, targetName, solutionName, instanceName, context)
            .getValue();
        return this;
    }

    public InstanceImpl withProperties(InstanceProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }

    public InstanceImpl withExtendedLocation(ExtendedLocation extendedLocation) {
        this.innerModel().withExtendedLocation(extendedLocation);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/InstancesClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.InstanceListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in InstancesClient.
 */
public final class InstancesClientImpl implements InstancesClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final InstancesService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of InstancesClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    InstancesClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(InstancesService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientInstances to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientInstances")
    public interface InstancesService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<InstanceInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<InstanceInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") InstanceInner resource, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") InstanceInner resource, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") InstanceInner properties, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") InstanceInner properties, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @PathParam("instanceName") String instanceName,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<InstanceListResult>> listBySolution(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<InstanceListResult> listBySolutionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<InstanceListResult>> listBySolutionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<InstanceListResult> listBySolutionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<InstanceInner>> getWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName, String instanceName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            return Mono.error(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, accept,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<InstanceInner> getAsync(String resourceGroupName, String targetName, String solutionName,
        String instanceName) {
        return getWithResponseAsync(resourceGroupName, targetName, solutionName, instanceName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<InstanceInner> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, targetName, solutionName, instanceName, accept, context);
    }

    /**
     * Get Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public InstanceInner get(String resourceGroupName, String targetName, String solutionName, String instanceName) {
        return getWithResponse(resourceGroupName, targetName, solutionName, instanceName, Context.NONE).getValue();
    }

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String targetName, String solutionName, String instanceName, InstanceInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            return Mono.error(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, contentType,
                accept, resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String targetName,
        String solutionName, String instanceName, InstanceInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, contentType,
            accept, resource, Context.NONE);
    }

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String targetName,
        String solutionName, String instanceName, InstanceInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, contentType,
            accept, resource, context);
    }

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<InstanceInner>, InstanceInner> beginCreateOrUpdateAsync(String resourceGroupName,
        String targetName, String solutionName, String instanceName, InstanceInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, targetName, solutionName, instanceName, resource);
        return this.client.<InstanceInner, InstanceInner>getLroResult(mono, this.client.getHttpPipeline(),
            InstanceInner.class, InstanceInner.class, this.client.getContext());
    }

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<InstanceInner>, InstanceInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, String instanceName, InstanceInner resource) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, targetName, solutionName, instanceName, resource);
        return this.client.<InstanceInner, InstanceInner>getLroResult(response, InstanceInner.class,
            InstanceInner.class, Context.NONE);
    }

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<InstanceInner>, InstanceInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, String instanceName, InstanceInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, targetName, solutionName, instanceName, resource, context);
        return this.client.<InstanceInner, InstanceInner>getLroResult(response, InstanceInner.class,
            InstanceInner.class, context);
    }

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<InstanceInner> createOrUpdateAsync(String resourceGroupName, String targetName, String solutionName,
        String instanceName, InstanceInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, targetName, solutionName, instanceName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public InstanceInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        String instanceName, InstanceInner resource) {
        return beginCreateOrUpdate(resourceGroupName, targetName, solutionName, instanceName, resource)
            .getFinalResult();
    }

    /**
     * Create or update Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public InstanceInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        String instanceName, InstanceInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, targetName, solutionName, instanceName, resource, context)
            .getFinalResult();
    }

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName, String instanceName, InstanceInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            return Mono.error(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, contentType,
                accept, properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, InstanceInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, contentType,
            accept, properties, Context.NONE);
    }

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, InstanceInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, contentType,
            accept, properties, context);
    }

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<InstanceInner>, InstanceInner> beginUpdateAsync(String resourceGroupName,
        String targetName, String solutionName, String instanceName, InstanceInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = updateWithResponseAsync(resourceGroupName, targetName, solutionName, instanceName, properties);
        return this.client.<InstanceInner, InstanceInner>getLroResult(mono, this.client.getHttpPipeline(),
            InstanceInner.class, InstanceInner.class, this.client.getContext());
    }

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<InstanceInner>, InstanceInner> beginUpdate(String resourceGroupName, String targetName,
        String solutionName, String instanceName, InstanceInner properties) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, targetName, solutionName, instanceName, properties);
        return this.client.<InstanceInner, InstanceInner>getLroResult(response, InstanceInner.class,
            InstanceInner.class, Context.NONE);
    }

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of instance Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<InstanceInner>, InstanceInner> beginUpdate(String resourceGroupName, String targetName,
        String solutionName, String instanceName, InstanceInner properties, Context context) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, targetName, solutionName, instanceName, properties, context);
        return this.client.<InstanceInner, InstanceInner>getLroResult(response, InstanceInner.class,
            InstanceInner.class, context);
    }

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<InstanceInner> updateAsync(String resourceGroupName, String targetName, String solutionName,
        String instanceName, InstanceInner properties) {
        return beginUpdateAsync(resourceGroupName, targetName, solutionName, instanceName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public InstanceInner update(String resourceGroupName, String targetName, String solutionName, String instanceName,
        InstanceInner properties) {
        return beginUpdate(resourceGroupName, targetName, solutionName, instanceName, properties).getFinalResult();
    }

    /**
     * Update an Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public InstanceInner update(String resourceGroupName, String targetName, String solutionName, String instanceName,
        InstanceInner properties, Context context) {
        return beginUpdate(resourceGroupName, targetName, solutionName, instanceName, properties, context)
            .getFinalResult();
    }

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName, String instanceName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            return Mono.error(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, Context.NONE);
    }

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (instanceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter instanceName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, instanceName, context);
    }

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String targetName,
        String solutionName, String instanceName) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = deleteWithResponseAsync(resourceGroupName, targetName, solutionName, instanceName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName,
        String solutionName, String instanceName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, targetName, solutionName, instanceName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName,
        String solutionName, String instanceName, Context context) {
        Response<BinaryData> response
            = deleteWithResponse(resourceGroupName, targetName, solutionName, instanceName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String targetName, String solutionName,
        String instanceName) {
        return beginDeleteAsync(resourceGroupName, targetName, solutionName, instanceName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String targetName, String solutionName, String instanceName) {
        beginDelete(resourceGroupName, targetName, solutionName, instanceName).getFinalResult();
    }

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String targetName, String solutionName, String instanceName,
        Context context) {
        beginDelete(resourceGroupName, targetName, solutionName, instanceName, context).getFinalResult();
    }

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<InstanceInner>> listBySolutionSinglePageAsync(String resourceGroupName,
        String targetName, String solutionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listBySolution(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, accept, context))
            .<PagedResponse<InstanceInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<InstanceInner> listBySolutionAsync(String resourceGroupName, String targetName,
        String solutionName) {
        return new PagedFlux<>(() -> listBySolutionSinglePageAsync(resourceGroupName, targetName, solutionName),
            nextLink -> listBySolutionNextSinglePageAsync(nextLink));
    }

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<InstanceInner> listBySolutionSinglePage(String resourceGroupName, String targetName,
        String solutionName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<InstanceListResult> res
            = service.listBySolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<InstanceInner> listBySolutionSinglePage(String resourceGroupName, String targetName,
        String solutionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<InstanceListResult> res
            = service.listBySolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<InstanceInner> listBySolution(String resourceGroupName, String targetName,
        String solutionName) {
        return new PagedIterable<>(() -> listBySolutionSinglePage(resourceGroupName, targetName, solutionName),
            nextLink -> listBySolutionNextSinglePage(nextLink));
    }

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<InstanceInner> listBySolution(String resourceGroupName, String targetName, String solutionName,
        Context context) {
        return new PagedIterable<>(() -> listBySolutionSinglePage(resourceGroupName, targetName, solutionName, context),
            nextLink -> listBySolutionNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<InstanceInner>> listBySolutionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listBySolutionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<InstanceInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<InstanceInner> listBySolutionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<InstanceListResult> res
            = service.listBySolutionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<InstanceInner> listBySolutionNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<InstanceListResult> res
            = service.listBySolutionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(InstancesClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/InstancesImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner;
import com.azure.resourcemanager.workloadorchestration.models.Instance;
import com.azure.resourcemanager.workloadorchestration.models.Instances;

public final class InstancesImpl implements Instances {
    private static final ClientLogger LOGGER = new ClientLogger(InstancesImpl.class);

    private final InstancesClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public InstancesImpl(InstancesClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<Instance> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, Context context) {
        Response<InstanceInner> inner
            = this.serviceClient().getWithResponse(resourceGroupName, targetName, solutionName, instanceName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new InstanceImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public Instance get(String resourceGroupName, String targetName, String solutionName, String instanceName) {
        InstanceInner inner = this.serviceClient().get(resourceGroupName, targetName, solutionName, instanceName);
        if (inner != null) {
            return new InstanceImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String targetName, String solutionName, String instanceName) {
        this.serviceClient().delete(resourceGroupName, targetName, solutionName, instanceName);
    }

    public void delete(String resourceGroupName, String targetName, String solutionName, String instanceName,
        Context context) {
        this.serviceClient().delete(resourceGroupName, targetName, solutionName, instanceName, context);
    }

    public PagedIterable<Instance> listBySolution(String resourceGroupName, String targetName, String solutionName) {
        PagedIterable<InstanceInner> inner
            = this.serviceClient().listBySolution(resourceGroupName, targetName, solutionName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new InstanceImpl(inner1, this.manager()));
    }

    public PagedIterable<Instance> listBySolution(String resourceGroupName, String targetName, String solutionName,
        Context context) {
        PagedIterable<InstanceInner> inner
            = this.serviceClient().listBySolution(resourceGroupName, targetName, solutionName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new InstanceImpl(inner1, this.manager()));
    }

    public Instance getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        String instanceName = ResourceManagerUtils.getValueFromIdByName(id, "instances");
        if (instanceName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'instances'.", id)));
        }
        return this.getWithResponse(resourceGroupName, targetName, solutionName, instanceName, Context.NONE).getValue();
    }

    public Response<Instance> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        String instanceName = ResourceManagerUtils.getValueFromIdByName(id, "instances");
        if (instanceName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'instances'.", id)));
        }
        return this.getWithResponse(resourceGroupName, targetName, solutionName, instanceName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        String instanceName = ResourceManagerUtils.getValueFromIdByName(id, "instances");
        if (instanceName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'instances'.", id)));
        }
        this.delete(resourceGroupName, targetName, solutionName, instanceName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        String instanceName = ResourceManagerUtils.getValueFromIdByName(id, "instances");
        if (instanceName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'instances'.", id)));
        }
        this.delete(resourceGroupName, targetName, solutionName, instanceName, context);
    }

    private InstancesClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public InstanceImpl define(String name) {
        return new InstanceImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/JobImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.JobInner;
import com.azure.resourcemanager.workloadorchestration.models.Job;
import com.azure.resourcemanager.workloadorchestration.models.JobProperties;

public final class JobImpl implements Job {
    private JobInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    JobImpl(JobInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public JobProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public JobInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/JobsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.JobsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.JobInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.JobListResult;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in JobsClient.
 */
public final class JobsClientImpl implements JobsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final JobsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of JobsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    JobsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service = RestProxy.create(JobsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientJobs to be used by the proxy
     * service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientJobs")
    public interface JobsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<JobInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion,
            @PathParam(value = "resourceUri", encoded = true) String resourceUri, @PathParam("jobName") String jobName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<JobInner> getSync(@HostParam("endpoint") String endpoint, @QueryParam("api-version") String apiVersion,
            @PathParam(value = "resourceUri", encoded = true) String resourceUri, @PathParam("jobName") String jobName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/{resourceUri}/providers/Microsoft.Edge/jobs")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<JobListResult>> listByTarget(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion,
            @PathParam(value = "resourceUri", encoded = true) String resourceUri, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/{resourceUri}/providers/Microsoft.Edge/jobs")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<JobListResult> listByTargetSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion,
            @PathParam(value = "resourceUri", encoded = true) String resourceUri, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<JobListResult>> listByTargetNext(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<JobListResult> listByTargetNextSync(@PathParam(value = "nextLink", encoded = true) String nextLink,
            @HostParam("endpoint") String endpoint, @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Job resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param jobName The name of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Job resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<JobInner>> getWithResponseAsync(String resourceUri, String jobName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            return Mono.error(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        if (jobName == null) {
            return Mono.error(new IllegalArgumentException("Parameter jobName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(), resourceUri,
                jobName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Job resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param jobName The name of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Job resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<JobInner> getAsync(String resourceUri, String jobName) {
        return getWithResponseAsync(resourceUri, jobName).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Job resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param jobName The name of the Job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Job resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<JobInner> getWithResponse(String resourceUri, String jobName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        if (jobName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter jobName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), resourceUri, jobName, accept,
            context);
    }

    /**
     * Get a Job resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param jobName The name of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Job resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public JobInner get(String resourceUri, String jobName) {
        return getWithResponse(resourceUri, jobName, Context.NONE).getValue();
    }

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<JobInner>> listByTargetSinglePageAsync(String resourceUri) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            return Mono.error(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByTarget(this.client.getEndpoint(), this.client.getApiVersion(),
                resourceUri, accept, context))
            .<PagedResponse<JobInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<JobInner> listByTargetAsync(String resourceUri) {
        return new PagedFlux<>(() -> listByTargetSinglePageAsync(resourceUri),
            nextLink -> listByTargetNextSinglePageAsync(nextLink));
    }

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<JobInner> listByTargetSinglePage(String resourceUri) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<JobListResult> res = service.listByTargetSync(this.client.getEndpoint(), this.client.getApiVersion(),
            resourceUri, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<JobInner> listByTargetSinglePage(String resourceUri, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<JobListResult> res = service.listByTargetSync(this.client.getEndpoint(), this.client.getApiVersion(),
            resourceUri, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<JobInner> listByTarget(String resourceUri) {
        return new PagedIterable<>(() -> listByTargetSinglePage(resourceUri),
            nextLink -> listByTargetNextSinglePage(nextLink));
    }

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<JobInner> listByTarget(String resourceUri, Context context) {
        return new PagedIterable<>(() -> listByTargetSinglePage(resourceUri, context),
            nextLink -> listByTargetNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<JobInner>> listByTargetNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByTargetNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<JobInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<JobInner> listByTargetNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<JobListResult> res
            = service.listByTargetNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<JobInner> listByTargetNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<JobListResult> res
            = service.listByTargetNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(JobsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/JobsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.JobsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.JobInner;
import com.azure.resourcemanager.workloadorchestration.models.Job;
import com.azure.resourcemanager.workloadorchestration.models.Jobs;

public final class JobsImpl implements Jobs {
    private static final ClientLogger LOGGER = new ClientLogger(JobsImpl.class);

    private final JobsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public JobsImpl(JobsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<Job> getWithResponse(String resourceUri, String jobName, Context context) {
        Response<JobInner> inner = this.serviceClient().getWithResponse(resourceUri, jobName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new JobImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public Job get(String resourceUri, String jobName) {
        JobInner inner = this.serviceClient().get(resourceUri, jobName);
        if (inner != null) {
            return new JobImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public PagedIterable<Job> listByTarget(String resourceUri) {
        PagedIterable<JobInner> inner = this.serviceClient().listByTarget(resourceUri);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new JobImpl(inner1, this.manager()));
    }

    public PagedIterable<Job> listByTarget(String resourceUri, Context context) {
        PagedIterable<JobInner> inner = this.serviceClient().listByTarget(resourceUri, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new JobImpl(inner1, this.manager()));
    }

    private JobsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/package-info.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

/**
 * Package containing the implementations for WorkloadOrchestration.
 * Microsoft.Edge Resource Provider management API.
 */
package com.azure.resourcemanager.workloadorchestration.implementation;



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/RemoveVersionResponseImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner;
import com.azure.resourcemanager.workloadorchestration.models.RemoveVersionResponse;

public final class RemoveVersionResponseImpl implements RemoveVersionResponse {
    private RemoveVersionResponseInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    RemoveVersionResponseImpl(RemoveVersionResponseInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public String status() {
        return this.innerModel().status();
    }

    public RemoveVersionResponseInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ResolvedConfigurationImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.resourcemanager.workloadorchestration.fluent.models.ResolvedConfigurationInner;
import com.azure.resourcemanager.workloadorchestration.models.ResolvedConfiguration;

public final class ResolvedConfigurationImpl implements ResolvedConfiguration {
    private ResolvedConfigurationInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    ResolvedConfigurationImpl(ResolvedConfigurationInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public String configuration() {
        return this.innerModel().configuration();
    }

    public ResolvedConfigurationInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/ResourceManagerUtils.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.util.CoreUtils;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import reactor.core.publisher.Flux;

final class ResourceManagerUtils {
    private ResourceManagerUtils() {
    }

    static String getValueFromIdByName(String id, String name) {
        if (id == null) {
            return null;
        }
        Iterator<String> itr = Arrays.stream(id.split("/")).iterator();
        while (itr.hasNext()) {
            String part = itr.next();
            if (part != null && !part.trim().isEmpty()) {
                if (part.equalsIgnoreCase(name)) {
                    if (itr.hasNext()) {
                        return itr.next();
                    } else {
                        return null;
                    }
                }
            }
        }
        return null;
    }

    static String getValueFromIdByParameterName(String id, String pathTemplate, String parameterName) {
        if (id == null || pathTemplate == null) {
            return null;
        }
        String parameterNameParentheses = "{" + parameterName + "}";
        List<String> idSegmentsReverted = Arrays.asList(id.split("/"));
        List<String> pathSegments = Arrays.asList(pathTemplate.split("/"));
        Collections.reverse(idSegmentsReverted);
        Iterator<String> idItrReverted = idSegmentsReverted.iterator();
        int pathIndex = pathSegments.size();
        while (idItrReverted.hasNext() && pathIndex > 0) {
            String idSegment = idItrReverted.next();
            String pathSegment = pathSegments.get(--pathIndex);
            if (!CoreUtils.isNullOrEmpty(idSegment) && !CoreUtils.isNullOrEmpty(pathSegment)) {
                if (pathSegment.equalsIgnoreCase(parameterNameParentheses)) {
                    if (pathIndex == 0 || (pathIndex == 1 && pathSegments.get(0).isEmpty())) {
                        List<String> segments = new ArrayList<>();
                        segments.add(idSegment);
                        idItrReverted.forEachRemaining(segments::add);
                        Collections.reverse(segments);
                        if (!segments.isEmpty() && segments.get(0).isEmpty()) {
                            segments.remove(0);
                        }
                        return String.join("/", segments);
                    } else {
                        return idSegment;
                    }
                }
            }
        }
        return null;
    }

    static <T, S> PagedIterable<S> mapPage(PagedIterable<T> pageIterable, Function<T, S> mapper) {
        return new PagedIterableImpl<>(pageIterable, mapper);
    }

    private static final class PagedIterableImpl<T, S> extends PagedIterable<S> {

        private final PagedIterable<T> pagedIterable;
        private final Function<T, S> mapper;
        private final Function<PagedResponse<T>, PagedResponse<S>> pageMapper;

        private PagedIterableImpl(PagedIterable<T> pagedIterable, Function<T, S> mapper) {
            super(PagedFlux.create(() -> (continuationToken, pageSize) -> Flux
                .fromStream(pagedIterable.streamByPage().map(getPageMapper(mapper)))));
            this.pagedIterable = pagedIterable;
            this.mapper = mapper;
            this.pageMapper = getPageMapper(mapper);
        }

        private static <T, S> Function<PagedResponse<T>, PagedResponse<S>> getPageMapper(Function<T, S> mapper) {
            return page -> new PagedResponseBase<Void, S>(page.getRequest(), page.getStatusCode(), page.getHeaders(),
                page.getElements().stream().map(mapper).collect(Collectors.toList()), page.getContinuationToken(),
                null);
        }

        @Override
        public Stream<S> stream() {
            return pagedIterable.stream().map(mapper);
        }

        @Override
        public Stream<PagedResponse<S>> streamByPage() {
            return pagedIterable.streamByPage().map(pageMapper);
        }

        @Override
        public Stream<PagedResponse<S>> streamByPage(String continuationToken) {
            return pagedIterable.streamByPage(continuationToken).map(pageMapper);
        }

        @Override
        public Stream<PagedResponse<S>> streamByPage(int preferredPageSize) {
            return pagedIterable.streamByPage(preferredPageSize).map(pageMapper);
        }

        @Override
        public Stream<PagedResponse<S>> streamByPage(String continuationToken, int preferredPageSize) {
            return pagedIterable.streamByPage(continuationToken, preferredPageSize).map(pageMapper);
        }

        @Override
        public Iterator<S> iterator() {
            return new IteratorImpl<>(pagedIterable.iterator(), mapper);
        }

        @Override
        public Iterable<PagedResponse<S>> iterableByPage() {
            return new IterableImpl<>(pagedIterable.iterableByPage(), pageMapper);
        }

        @Override
        public Iterable<PagedResponse<S>> iterableByPage(String continuationToken) {
            return new IterableImpl<>(pagedIterable.iterableByPage(continuationToken), pageMapper);
        }

        @Override
        public Iterable<PagedResponse<S>> iterableByPage(int preferredPageSize) {
            return new IterableImpl<>(pagedIterable.iterableByPage(preferredPageSize), pageMapper);
        }

        @Override
        public Iterable<PagedResponse<S>> iterableByPage(String continuationToken, int preferredPageSize) {
            return new IterableImpl<>(pagedIterable.iterableByPage(continuationToken, preferredPageSize), pageMapper);
        }
    }

    private static final class IteratorImpl<T, S> implements Iterator<S> {

        private final Iterator<T> iterator;
        private final Function<T, S> mapper;

        private IteratorImpl(Iterator<T> iterator, Function<T, S> mapper) {
            this.iterator = iterator;
            this.mapper = mapper;
        }

        @Override
        public boolean hasNext() {
            return iterator.hasNext();
        }

        @Override
        public S next() {
            return mapper.apply(iterator.next());
        }

        @Override
        public void remove() {
            iterator.remove();
        }
    }

    private static final class IterableImpl<T, S> implements Iterable<S> {

        private final Iterable<T> iterable;
        private final Function<T, S> mapper;

        private IterableImpl(Iterable<T> iterable, Function<T, S> mapper) {
            this.iterable = iterable;
            this.mapper = mapper;
        }

        @Override
        public Iterator<S> iterator() {
            return new IteratorImpl<>(iterable.iterator(), mapper);
        }
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemaImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.Response;
import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.RemoveVersionResponse;
import com.azure.resourcemanager.workloadorchestration.models.Schema;
import com.azure.resourcemanager.workloadorchestration.models.SchemaProperties;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;
import java.util.Collections;
import java.util.Map;

public final class SchemaImpl implements Schema, Schema.Definition, Schema.Update {
    private SchemaInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public String location() {
        return this.innerModel().location();
    }

    public Map<String, String> tags() {
        Map<String, String> inner = this.innerModel().tags();
        if (inner != null) {
            return Collections.unmodifiableMap(inner);
        } else {
            return Collections.emptyMap();
        }
    }

    public SchemaProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public Region region() {
        return Region.fromName(this.regionName());
    }

    public String regionName() {
        return this.location();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public SchemaInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String schemaName;

    public SchemaImpl withExistingResourceGroup(String resourceGroupName) {
        this.resourceGroupName = resourceGroupName;
        return this;
    }

    public Schema create() {
        this.innerObject = serviceManager.serviceClient()
            .getSchemas()
            .createOrUpdate(resourceGroupName, schemaName, this.innerModel(), Context.NONE);
        return this;
    }

    public Schema create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSchemas()
            .createOrUpdate(resourceGroupName, schemaName, this.innerModel(), context);
        return this;
    }

    SchemaImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new SchemaInner();
        this.serviceManager = serviceManager;
        this.schemaName = name;
    }

    public SchemaImpl update() {
        return this;
    }

    public Schema apply() {
        this.innerObject = serviceManager.serviceClient()
            .getSchemas()
            .updateWithResponse(resourceGroupName, schemaName, this.innerModel(), Context.NONE)
            .getValue();
        return this;
    }

    public Schema apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSchemas()
            .updateWithResponse(resourceGroupName, schemaName, this.innerModel(), context)
            .getValue();
        return this;
    }

    SchemaImpl(SchemaInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.schemaName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "schemas");
    }

    public Schema refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getSchemas()
            .getByResourceGroupWithResponse(resourceGroupName, schemaName, Context.NONE)
            .getValue();
        return this;
    }

    public Schema refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSchemas()
            .getByResourceGroupWithResponse(resourceGroupName, schemaName, context)
            .getValue();
        return this;
    }

    public SchemaVersion createVersion(SchemaVersionWithUpdateTypeInner body) {
        return serviceManager.schemas().createVersion(resourceGroupName, schemaName, body);
    }

    public SchemaVersion createVersion(SchemaVersionWithUpdateTypeInner body, Context context) {
        return serviceManager.schemas().createVersion(resourceGroupName, schemaName, body, context);
    }

    public Response<RemoveVersionResponse> removeVersionWithResponse(VersionParameter body, Context context) {
        return serviceManager.schemas().removeVersionWithResponse(resourceGroupName, schemaName, body, context);
    }

    public RemoveVersionResponse removeVersion(VersionParameter body) {
        return serviceManager.schemas().removeVersion(resourceGroupName, schemaName, body);
    }

    public SchemaImpl withRegion(Region location) {
        this.innerModel().withLocation(location.toString());
        return this;
    }

    public SchemaImpl withRegion(String location) {
        this.innerModel().withLocation(location);
        return this;
    }

    public SchemaImpl withTags(Map<String, String> tags) {
        this.innerModel().withTags(tags);
        return this;
    }

    public SchemaImpl withProperties(SchemaProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemaReferenceImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaReference;
import com.azure.resourcemanager.workloadorchestration.models.SchemaReferenceProperties;

public final class SchemaReferenceImpl implements SchemaReference {
    private SchemaReferenceInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    SchemaReferenceImpl(SchemaReferenceInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public SchemaReferenceProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public SchemaReferenceInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemaReferencesClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaReferenceListResult;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in SchemaReferencesClient.
 */
public final class SchemaReferencesClientImpl implements SchemaReferencesClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SchemaReferencesService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of SchemaReferencesClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    SchemaReferencesClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(SchemaReferencesService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientSchemaReferences to be used by
     * the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientSchemaReferences")
    public interface SchemaReferencesService {
        @Headers({ "Content-Type: application/json" })
        @Get("/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaReferenceInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion,
            @PathParam(value = "resourceUri", encoded = true) String resourceUri,
            @PathParam("schemaReferenceName") String schemaReferenceName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaReferenceInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion,
            @PathParam(value = "resourceUri", encoded = true) String resourceUri,
            @PathParam("schemaReferenceName") String schemaReferenceName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/{resourceUri}/providers/Microsoft.Edge/schemaReferences")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaReferenceListResult>> listByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion,
            @PathParam(value = "resourceUri", encoded = true) String resourceUri, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/{resourceUri}/providers/Microsoft.Edge/schemaReferences")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaReferenceListResult> listByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion,
            @PathParam(value = "resourceUri", encoded = true) String resourceUri, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaReferenceListResult>> listByResourceGroupNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaReferenceListResult> listByResourceGroupNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Schema Reference Resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param schemaReferenceName The name of the SchemaReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Reference Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SchemaReferenceInner>> getWithResponseAsync(String resourceUri, String schemaReferenceName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            return Mono.error(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        if (schemaReferenceName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter schemaReferenceName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(), resourceUri,
                schemaReferenceName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Schema Reference Resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param schemaReferenceName The name of the SchemaReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Reference Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SchemaReferenceInner> getAsync(String resourceUri, String schemaReferenceName) {
        return getWithResponseAsync(resourceUri, schemaReferenceName).flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Schema Reference Resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param schemaReferenceName The name of the SchemaReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SchemaReferenceInner> getWithResponse(String resourceUri, String schemaReferenceName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        if (schemaReferenceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaReferenceName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), resourceUri, schemaReferenceName,
            accept, context);
    }

    /**
     * Get a Schema Reference Resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param schemaReferenceName The name of the SchemaReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaReferenceInner get(String resourceUri, String schemaReferenceName) {
        return getWithResponse(resourceUri, schemaReferenceName, Context.NONE).getValue();
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SchemaReferenceInner>> listByResourceGroupSinglePageAsync(String resourceUri) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            return Mono.error(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                resourceUri, accept, context))
            .<PagedResponse<SchemaReferenceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SchemaReferenceInner> listByResourceGroupAsync(String resourceUri) {
        return new PagedFlux<>(() -> listByResourceGroupSinglePageAsync(resourceUri),
            nextLink -> listByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaReferenceInner> listByResourceGroupSinglePage(String resourceUri) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaReferenceListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), resourceUri, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaReferenceInner> listByResourceGroupSinglePage(String resourceUri, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (resourceUri == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceUri is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaReferenceListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), resourceUri, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SchemaReferenceInner> listByResourceGroup(String resourceUri) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceUri),
            nextLink -> listByResourceGroupNextSinglePage(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SchemaReferenceInner> listByResourceGroup(String resourceUri, Context context) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceUri, context),
            nextLink -> listByResourceGroupNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SchemaReferenceInner>> listByResourceGroupNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SchemaReferenceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaReferenceInner> listByResourceGroupNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaReferenceListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaReferenceInner> listByResourceGroupNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaReferenceListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemaReferencesClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemaReferencesImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaReference;
import com.azure.resourcemanager.workloadorchestration.models.SchemaReferences;

public final class SchemaReferencesImpl implements SchemaReferences {
    private static final ClientLogger LOGGER = new ClientLogger(SchemaReferencesImpl.class);

    private final SchemaReferencesClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public SchemaReferencesImpl(SchemaReferencesClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<SchemaReference> getWithResponse(String resourceUri, String schemaReferenceName, Context context) {
        Response<SchemaReferenceInner> inner
            = this.serviceClient().getWithResponse(resourceUri, schemaReferenceName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new SchemaReferenceImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public SchemaReference get(String resourceUri, String schemaReferenceName) {
        SchemaReferenceInner inner = this.serviceClient().get(resourceUri, schemaReferenceName);
        if (inner != null) {
            return new SchemaReferenceImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public PagedIterable<SchemaReference> listByResourceGroup(String resourceUri) {
        PagedIterable<SchemaReferenceInner> inner = this.serviceClient().listByResourceGroup(resourceUri);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SchemaReferenceImpl(inner1, this.manager()));
    }

    public PagedIterable<SchemaReference> listByResourceGroup(String resourceUri, Context context) {
        PagedIterable<SchemaReferenceInner> inner = this.serviceClient().listByResourceGroup(resourceUri, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SchemaReferenceImpl(inner1, this.manager()));
    }

    private SchemaReferencesClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemasClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaListResult;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in SchemasClient.
 */
public final class SchemasClientImpl implements SchemasClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SchemasService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of SchemasClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    SchemasClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service = RestProxy.create(SchemasService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientSchemas to be used by the proxy
     * service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientSchemas")
    public interface SchemasService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaInner>> getByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaInner> getByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SchemaInner resource, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SchemaInner resource, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaInner>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SchemaInner properties, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaInner> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SchemaInner properties, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/createVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createVersion(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SchemaVersionWithUpdateTypeInner body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/createVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createVersionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SchemaVersionWithUpdateTypeInner body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/removeVersion")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<RemoveVersionResponseInner>> removeVersion(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") VersionParameter body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/removeVersion")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<RemoveVersionResponseInner> removeVersionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") VersionParameter body, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaListResult>> listByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaListResult> listByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/schemas")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaListResult>> list(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/schemas")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaListResult> listSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaListResult>> listByResourceGroupNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaListResult> listByResourceGroupNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaListResult>> listBySubscriptionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaListResult> listBySubscriptionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SchemaInner>> getByResourceGroupWithResponseAsync(String resourceGroupName,
        String schemaName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SchemaInner> getByResourceGroupAsync(String resourceGroupName, String schemaName) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, schemaName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SchemaInner> getByResourceGroupWithResponse(String resourceGroupName, String schemaName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getByResourceGroupSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, accept, context);
    }

    /**
     * Get a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaInner getByResourceGroup(String resourceGroupName, String schemaName) {
        return getByResourceGroupWithResponse(resourceGroupName, schemaName, Context.NONE).getValue();
    }

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String schemaName, SchemaInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String schemaName,
        SchemaInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, resource,
            Context.NONE);
    }

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String schemaName,
        SchemaInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, resource, context);
    }

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of schema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SchemaInner>, SchemaInner> beginCreateOrUpdateAsync(String resourceGroupName,
        String schemaName, SchemaInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, schemaName, resource);
        return this.client.<SchemaInner, SchemaInner>getLroResult(mono, this.client.getHttpPipeline(),
            SchemaInner.class, SchemaInner.class, this.client.getContext());
    }

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of schema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SchemaInner>, SchemaInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, SchemaInner resource) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, schemaName, resource);
        return this.client.<SchemaInner, SchemaInner>getLroResult(response, SchemaInner.class, SchemaInner.class,
            Context.NONE);
    }

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of schema Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SchemaInner>, SchemaInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, SchemaInner resource, Context context) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, schemaName, resource, context);
        return this.client.<SchemaInner, SchemaInner>getLroResult(response, SchemaInner.class, SchemaInner.class,
            context);
    }

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SchemaInner> createOrUpdateAsync(String resourceGroupName, String schemaName, SchemaInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, schemaName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaInner createOrUpdate(String resourceGroupName, String schemaName, SchemaInner resource) {
        return beginCreateOrUpdate(resourceGroupName, schemaName, resource).getFinalResult();
    }

    /**
     * Create or update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaInner createOrUpdate(String resourceGroupName, String schemaName, SchemaInner resource,
        Context context) {
        return beginCreateOrUpdate(resourceGroupName, schemaName, resource, context).getFinalResult();
    }

    /**
     * update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SchemaInner>> updateWithResponseAsync(String resourceGroupName, String schemaName,
        SchemaInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SchemaInner> updateAsync(String resourceGroupName, String schemaName, SchemaInner properties) {
        return updateWithResponseAsync(resourceGroupName, schemaName, properties)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SchemaInner> updateWithResponse(String resourceGroupName, String schemaName, SchemaInner properties,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, properties, context);
    }

    /**
     * update a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaInner update(String resourceGroupName, String schemaName, SchemaInner properties) {
        return updateWithResponse(resourceGroupName, schemaName, properties, Context.NONE).getValue();
    }

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String schemaName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String schemaName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, Context.NONE);
    }

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String schemaName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, context);
    }

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String schemaName) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, schemaName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, schemaName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, schemaName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String schemaName) {
        return beginDeleteAsync(resourceGroupName, schemaName).last().flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String schemaName) {
        beginDelete(resourceGroupName, schemaName).getFinalResult();
    }

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String schemaName, Context context) {
        beginDelete(resourceGroupName, schemaName, context).getFinalResult();
    }

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createVersionWithResponseAsync(String resourceGroupName, String schemaName,
        SchemaVersionWithUpdateTypeInner body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createVersion(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createVersionWithResponse(String resourceGroupName, String schemaName,
        SchemaVersionWithUpdateTypeInner body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, body, Context.NONE);
    }

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createVersionWithResponse(String resourceGroupName, String schemaName,
        SchemaVersionWithUpdateTypeInner body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, body, context);
    }

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SchemaVersionInner>, SchemaVersionInner>
        beginCreateVersionAsync(String resourceGroupName, String schemaName, SchemaVersionWithUpdateTypeInner body) {
        Mono<Response<Flux<ByteBuffer>>> mono = createVersionWithResponseAsync(resourceGroupName, schemaName, body);
        return this.client.<SchemaVersionInner, SchemaVersionInner>getLroResult(mono, this.client.getHttpPipeline(),
            SchemaVersionInner.class, SchemaVersionInner.class, this.client.getContext());
    }

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SchemaVersionInner>, SchemaVersionInner> beginCreateVersion(String resourceGroupName,
        String schemaName, SchemaVersionWithUpdateTypeInner body) {
        Response<BinaryData> response = createVersionWithResponse(resourceGroupName, schemaName, body);
        return this.client.<SchemaVersionInner, SchemaVersionInner>getLroResult(response, SchemaVersionInner.class,
            SchemaVersionInner.class, Context.NONE);
    }

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SchemaVersionInner>, SchemaVersionInner> beginCreateVersion(String resourceGroupName,
        String schemaName, SchemaVersionWithUpdateTypeInner body, Context context) {
        Response<BinaryData> response = createVersionWithResponse(resourceGroupName, schemaName, body, context);
        return this.client.<SchemaVersionInner, SchemaVersionInner>getLroResult(response, SchemaVersionInner.class,
            SchemaVersionInner.class, context);
    }

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SchemaVersionInner> createVersionAsync(String resourceGroupName, String schemaName,
        SchemaVersionWithUpdateTypeInner body) {
        return beginCreateVersionAsync(resourceGroupName, schemaName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaVersionInner createVersion(String resourceGroupName, String schemaName,
        SchemaVersionWithUpdateTypeInner body) {
        return beginCreateVersion(resourceGroupName, schemaName, body).getFinalResult();
    }

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaVersionInner createVersion(String resourceGroupName, String schemaName,
        SchemaVersionWithUpdateTypeInner body, Context context) {
        return beginCreateVersion(resourceGroupName, schemaName, body, context).getFinalResult();
    }

    /**
     * Remove Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<RemoveVersionResponseInner>> removeVersionWithResponseAsync(String resourceGroupName,
        String schemaName, VersionParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.removeVersion(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Remove Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<RemoveVersionResponseInner> removeVersionAsync(String resourceGroupName, String schemaName,
        VersionParameter body) {
        return removeVersionWithResponseAsync(resourceGroupName, schemaName, body)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Remove Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<RemoveVersionResponseInner> removeVersionWithResponse(String resourceGroupName, String schemaName,
        VersionParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.removeVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, contentType, accept, body, context);
    }

    /**
     * Remove Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public RemoveVersionResponseInner removeVersion(String resourceGroupName, String schemaName,
        VersionParameter body) {
        return removeVersionWithResponse(resourceGroupName, schemaName, body, Context.NONE).getValue();
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SchemaInner>> listByResourceGroupSinglePageAsync(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, accept, context))
            .<PagedResponse<SchemaInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SchemaInner> listByResourceGroupAsync(String resourceGroupName) {
        return new PagedFlux<>(() -> listByResourceGroupSinglePageAsync(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaInner> listByResourceGroupSinglePage(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaInner> listByResourceGroupSinglePage(String resourceGroupName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SchemaInner> listByResourceGroup(String resourceGroupName) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePage(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SchemaInner> listByResourceGroup(String resourceGroupName, Context context) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName, context),
            nextLink -> listByResourceGroupNextSinglePage(nextLink, context));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SchemaInner>> listSinglePageAsync() {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.list(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), accept, context))
            .<PagedResponse<SchemaInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SchemaInner> listAsync() {
        return new PagedFlux<>(() -> listSinglePageAsync(),
            nextLink -> listBySubscriptionNextSinglePageAsync(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaInner> listSinglePage() {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaListResult> res = service.listSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaInner> listSinglePage(Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaListResult> res = service.listSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SchemaInner> list() {
        return new PagedIterable<>(() -> listSinglePage(), nextLink -> listBySubscriptionNextSinglePage(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SchemaInner> list(Context context) {
        return new PagedIterable<>(() -> listSinglePage(context),
            nextLink -> listBySubscriptionNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SchemaInner>> listByResourceGroupNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SchemaInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaInner> listByResourceGroupNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaInner> listByResourceGroupNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SchemaInner>> listBySubscriptionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listBySubscriptionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SchemaInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaInner> listBySubscriptionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaInner> listBySubscriptionNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemasClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemasImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.RemoveVersionResponse;
import com.azure.resourcemanager.workloadorchestration.models.Schema;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.Schemas;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

public final class SchemasImpl implements Schemas {
    private static final ClientLogger LOGGER = new ClientLogger(SchemasImpl.class);

    private final SchemasClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public SchemasImpl(SchemasClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<Schema> getByResourceGroupWithResponse(String resourceGroupName, String schemaName,
        Context context) {
        Response<SchemaInner> inner
            = this.serviceClient().getByResourceGroupWithResponse(resourceGroupName, schemaName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new SchemaImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public Schema getByResourceGroup(String resourceGroupName, String schemaName) {
        SchemaInner inner = this.serviceClient().getByResourceGroup(resourceGroupName, schemaName);
        if (inner != null) {
            return new SchemaImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void deleteByResourceGroup(String resourceGroupName, String schemaName) {
        this.serviceClient().delete(resourceGroupName, schemaName);
    }

    public void delete(String resourceGroupName, String schemaName, Context context) {
        this.serviceClient().delete(resourceGroupName, schemaName, context);
    }

    public SchemaVersion createVersion(String resourceGroupName, String schemaName,
        SchemaVersionWithUpdateTypeInner body) {
        SchemaVersionInner inner = this.serviceClient().createVersion(resourceGroupName, schemaName, body);
        if (inner != null) {
            return new SchemaVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SchemaVersion createVersion(String resourceGroupName, String schemaName,
        SchemaVersionWithUpdateTypeInner body, Context context) {
        SchemaVersionInner inner = this.serviceClient().createVersion(resourceGroupName, schemaName, body, context);
        if (inner != null) {
            return new SchemaVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public Response<RemoveVersionResponse> removeVersionWithResponse(String resourceGroupName, String schemaName,
        VersionParameter body, Context context) {
        Response<RemoveVersionResponseInner> inner
            = this.serviceClient().removeVersionWithResponse(resourceGroupName, schemaName, body, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new RemoveVersionResponseImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public RemoveVersionResponse removeVersion(String resourceGroupName, String schemaName, VersionParameter body) {
        RemoveVersionResponseInner inner = this.serviceClient().removeVersion(resourceGroupName, schemaName, body);
        if (inner != null) {
            return new RemoveVersionResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public PagedIterable<Schema> listByResourceGroup(String resourceGroupName) {
        PagedIterable<SchemaInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SchemaImpl(inner1, this.manager()));
    }

    public PagedIterable<Schema> listByResourceGroup(String resourceGroupName, Context context) {
        PagedIterable<SchemaInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SchemaImpl(inner1, this.manager()));
    }

    public PagedIterable<Schema> list() {
        PagedIterable<SchemaInner> inner = this.serviceClient().list();
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SchemaImpl(inner1, this.manager()));
    }

    public PagedIterable<Schema> list(Context context) {
        PagedIterable<SchemaInner> inner = this.serviceClient().list(context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SchemaImpl(inner1, this.manager()));
    }

    public Schema getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, schemaName, Context.NONE).getValue();
    }

    public Response<Schema> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, schemaName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        this.delete(resourceGroupName, schemaName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        this.delete(resourceGroupName, schemaName, context);
    }

    private SchemasClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public SchemaImpl define(String name) {
        return new SchemaImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemaVersionImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

public final class SchemaVersionImpl implements SchemaVersion, SchemaVersion.Definition, SchemaVersion.Update {
    private SchemaVersionInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public SchemaVersionProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public SchemaVersionInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String schemaName;

    private String schemaVersionName;

    public SchemaVersionImpl withExistingSchema(String resourceGroupName, String schemaName) {
        this.resourceGroupName = resourceGroupName;
        this.schemaName = schemaName;
        return this;
    }

    public SchemaVersion create() {
        this.innerObject = serviceManager.serviceClient()
            .getSchemaVersions()
            .createOrUpdate(resourceGroupName, schemaName, schemaVersionName, this.innerModel(), Context.NONE);
        return this;
    }

    public SchemaVersion create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSchemaVersions()
            .createOrUpdate(resourceGroupName, schemaName, schemaVersionName, this.innerModel(), context);
        return this;
    }

    SchemaVersionImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new SchemaVersionInner();
        this.serviceManager = serviceManager;
        this.schemaVersionName = name;
    }

    public SchemaVersionImpl update() {
        return this;
    }

    public SchemaVersion apply() {
        this.innerObject = serviceManager.serviceClient()
            .getSchemaVersions()
            .updateWithResponse(resourceGroupName, schemaName, schemaVersionName, this.innerModel(), Context.NONE)
            .getValue();
        return this;
    }

    public SchemaVersion apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSchemaVersions()
            .updateWithResponse(resourceGroupName, schemaName, schemaVersionName, this.innerModel(), context)
            .getValue();
        return this;
    }

    SchemaVersionImpl(SchemaVersionInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.schemaName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "schemas");
        this.schemaVersionName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "versions");
    }

    public SchemaVersion refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getSchemaVersions()
            .getWithResponse(resourceGroupName, schemaName, schemaVersionName, Context.NONE)
            .getValue();
        return this;
    }

    public SchemaVersion refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSchemaVersions()
            .getWithResponse(resourceGroupName, schemaName, schemaVersionName, context)
            .getValue();
        return this;
    }

    public SchemaVersionImpl withProperties(SchemaVersionProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemaVersionsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaVersionListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in SchemaVersionsClient.
 */
public final class SchemaVersionsClientImpl implements SchemaVersionsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SchemaVersionsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of SchemaVersionsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    SchemaVersionsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(SchemaVersionsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientSchemaVersions to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientSchemaVersions")
    public interface SchemaVersionsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaVersionInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("schemaVersionName") String schemaVersionName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaVersionInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("schemaVersionName") String schemaVersionName, @HeaderParam("Accept") String accept,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("schemaVersionName") String schemaVersionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SchemaVersionInner resource,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("schemaVersionName") String schemaVersionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SchemaVersionInner resource,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaVersionInner>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("schemaVersionName") String schemaVersionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SchemaVersionInner properties,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaVersionInner> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("schemaVersionName") String schemaVersionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SchemaVersionInner properties,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("schemaVersionName") String schemaVersionName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @PathParam("schemaVersionName") String schemaVersionName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaVersionListResult>> listBySchema(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaVersionListResult> listBySchemaSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("schemaName") String schemaName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SchemaVersionListResult>> listBySchemaNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SchemaVersionListResult> listBySchemaNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SchemaVersionInner>> getWithResponseAsync(String resourceGroupName, String schemaName,
        String schemaVersionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, schemaVersionName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SchemaVersionInner> getAsync(String resourceGroupName, String schemaName, String schemaVersionName) {
        return getWithResponseAsync(resourceGroupName, schemaName, schemaVersionName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SchemaVersionInner> getWithResponse(String resourceGroupName, String schemaName,
        String schemaVersionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, schemaName, schemaVersionName, accept, context);
    }

    /**
     * Get a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaVersionInner get(String resourceGroupName, String schemaName, String schemaVersionName) {
        return getWithResponse(resourceGroupName, schemaName, schemaVersionName, Context.NONE).getValue();
    }

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String schemaName, String schemaVersionName, SchemaVersionInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, schemaVersionName, contentType, accept,
                resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String schemaName,
        String schemaVersionName, SchemaVersionInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, schemaVersionName, contentType, accept,
            resource, Context.NONE);
    }

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String schemaName,
        String schemaVersionName, SchemaVersionInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, schemaVersionName, contentType, accept,
            resource, context);
    }

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SchemaVersionInner>, SchemaVersionInner> beginCreateOrUpdateAsync(
        String resourceGroupName, String schemaName, String schemaVersionName, SchemaVersionInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, schemaName, schemaVersionName, resource);
        return this.client.<SchemaVersionInner, SchemaVersionInner>getLroResult(mono, this.client.getHttpPipeline(),
            SchemaVersionInner.class, SchemaVersionInner.class, this.client.getContext());
    }

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SchemaVersionInner>, SchemaVersionInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, String schemaVersionName, SchemaVersionInner resource) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, schemaName, schemaVersionName, resource);
        return this.client.<SchemaVersionInner, SchemaVersionInner>getLroResult(response, SchemaVersionInner.class,
            SchemaVersionInner.class, Context.NONE);
    }

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SchemaVersionInner>, SchemaVersionInner> beginCreateOrUpdate(String resourceGroupName,
        String schemaName, String schemaVersionName, SchemaVersionInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, schemaName, schemaVersionName, resource, context);
        return this.client.<SchemaVersionInner, SchemaVersionInner>getLroResult(response, SchemaVersionInner.class,
            SchemaVersionInner.class, context);
    }

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SchemaVersionInner> createOrUpdateAsync(String resourceGroupName, String schemaName,
        String schemaVersionName, SchemaVersionInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, schemaName, schemaVersionName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaVersionInner createOrUpdate(String resourceGroupName, String schemaName, String schemaVersionName,
        SchemaVersionInner resource) {
        return beginCreateOrUpdate(resourceGroupName, schemaName, schemaVersionName, resource).getFinalResult();
    }

    /**
     * Create or update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaVersionInner createOrUpdate(String resourceGroupName, String schemaName, String schemaVersionName,
        SchemaVersionInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, schemaName, schemaVersionName, resource, context)
            .getFinalResult();
    }

    /**
     * update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SchemaVersionInner>> updateWithResponseAsync(String resourceGroupName, String schemaName,
        String schemaVersionName, SchemaVersionInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, schemaVersionName, contentType, accept,
                properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SchemaVersionInner> updateAsync(String resourceGroupName, String schemaName, String schemaVersionName,
        SchemaVersionInner properties) {
        return updateWithResponseAsync(resourceGroupName, schemaName, schemaVersionName, properties)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SchemaVersionInner> updateWithResponse(String resourceGroupName, String schemaName,
        String schemaVersionName, SchemaVersionInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, schemaVersionName, contentType, accept,
            properties, context);
    }

    /**
     * update a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return schema Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SchemaVersionInner update(String resourceGroupName, String schemaName, String schemaVersionName,
        SchemaVersionInner properties) {
        return updateWithResponse(resourceGroupName, schemaName, schemaVersionName, properties, Context.NONE)
            .getValue();
    }

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String schemaName,
        String schemaVersionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, schemaVersionName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String schemaName,
        String schemaVersionName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, schemaVersionName, Context.NONE);
    }

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String schemaName,
        String schemaVersionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        if (schemaVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaVersionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, schemaName, schemaVersionName, context);
    }

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String schemaName,
        String schemaVersionName) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = deleteWithResponseAsync(resourceGroupName, schemaName, schemaVersionName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String schemaVersionName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, schemaName, schemaVersionName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String schemaName,
        String schemaVersionName, Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, schemaName, schemaVersionName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String schemaName, String schemaVersionName) {
        return beginDeleteAsync(resourceGroupName, schemaName, schemaVersionName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String schemaName, String schemaVersionName) {
        beginDelete(resourceGroupName, schemaName, schemaVersionName).getFinalResult();
    }

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String schemaName, String schemaVersionName, Context context) {
        beginDelete(resourceGroupName, schemaName, schemaVersionName, context).getFinalResult();
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SchemaVersionInner>> listBySchemaSinglePageAsync(String resourceGroupName,
        String schemaName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            return Mono.error(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listBySchema(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, accept, context))
            .<PagedResponse<SchemaVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SchemaVersionInner> listBySchemaAsync(String resourceGroupName, String schemaName) {
        return new PagedFlux<>(() -> listBySchemaSinglePageAsync(resourceGroupName, schemaName),
            nextLink -> listBySchemaNextSinglePageAsync(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaVersionInner> listBySchemaSinglePage(String resourceGroupName, String schemaName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaVersionListResult> res
            = service.listBySchemaSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaVersionInner> listBySchemaSinglePage(String resourceGroupName, String schemaName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (schemaName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter schemaName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaVersionListResult> res
            = service.listBySchemaSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, schemaName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SchemaVersionInner> listBySchema(String resourceGroupName, String schemaName) {
        return new PagedIterable<>(() -> listBySchemaSinglePage(resourceGroupName, schemaName),
            nextLink -> listBySchemaNextSinglePage(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SchemaVersionInner> listBySchema(String resourceGroupName, String schemaName,
        Context context) {
        return new PagedIterable<>(() -> listBySchemaSinglePage(resourceGroupName, schemaName, context),
            nextLink -> listBySchemaNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SchemaVersionInner>> listBySchemaNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listBySchemaNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SchemaVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaVersionInner> listBySchemaNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaVersionListResult> res
            = service.listBySchemaNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SchemaVersionInner> listBySchemaNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SchemaVersionListResult> res
            = service.listBySchemaNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemaVersionsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemaVersionsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersions;

public final class SchemaVersionsImpl implements SchemaVersions {
    private static final ClientLogger LOGGER = new ClientLogger(SchemaVersionsImpl.class);

    private final SchemaVersionsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public SchemaVersionsImpl(SchemaVersionsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<SchemaVersion> getWithResponse(String resourceGroupName, String schemaName,
        String schemaVersionName, Context context) {
        Response<SchemaVersionInner> inner
            = this.serviceClient().getWithResponse(resourceGroupName, schemaName, schemaVersionName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new SchemaVersionImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public SchemaVersion get(String resourceGroupName, String schemaName, String schemaVersionName) {
        SchemaVersionInner inner = this.serviceClient().get(resourceGroupName, schemaName, schemaVersionName);
        if (inner != null) {
            return new SchemaVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String schemaName, String schemaVersionName) {
        this.serviceClient().delete(resourceGroupName, schemaName, schemaVersionName);
    }

    public void delete(String resourceGroupName, String schemaName, String schemaVersionName, Context context) {
        this.serviceClient().delete(resourceGroupName, schemaName, schemaVersionName, context);
    }

    public PagedIterable<SchemaVersion> listBySchema(String resourceGroupName, String schemaName) {
        PagedIterable<SchemaVersionInner> inner = this.serviceClient().listBySchema(resourceGroupName, schemaName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SchemaVersionImpl(inner1, this.manager()));
    }

    public PagedIterable<SchemaVersion> listBySchema(String resourceGroupName, String schemaName, Context context) {
        PagedIterable<SchemaVersionInner> inner
            = this.serviceClient().listBySchema(resourceGroupName, schemaName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SchemaVersionImpl(inner1, this.manager()));
    }

    public SchemaVersion getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String schemaVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (schemaVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, schemaName, schemaVersionName, Context.NONE).getValue();
    }

    public Response<SchemaVersion> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String schemaVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (schemaVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, schemaName, schemaVersionName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String schemaVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (schemaVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        this.delete(resourceGroupName, schemaName, schemaVersionName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String schemaName = ResourceManagerUtils.getValueFromIdByName(id, "schemas");
        if (schemaName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'schemas'.", id)));
        }
        String schemaVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (schemaVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        this.delete(resourceGroupName, schemaName, schemaVersionName, context);
    }

    private SchemaVersionsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public SchemaVersionImpl define(String name) {
        return new SchemaVersionImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SchemaVersionWithUpdateTypeImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionWithUpdateType;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;

public final class SchemaVersionWithUpdateTypeImpl implements SchemaVersionWithUpdateType {
    private SchemaVersionWithUpdateTypeInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    SchemaVersionWithUpdateTypeImpl(SchemaVersionWithUpdateTypeInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public UpdateType updateType() {
        return this.innerModel().updateType();
    }

    public String version() {
        return this.innerModel().version();
    }

    public SchemaVersion schemaVersion() {
        SchemaVersionInner inner = this.innerModel().schemaVersion();
        if (inner != null) {
            return new SchemaVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SchemaVersionWithUpdateTypeInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SiteReferenceImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner;
import com.azure.resourcemanager.workloadorchestration.models.SiteReference;
import com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties;

public final class SiteReferenceImpl implements SiteReference, SiteReference.Definition, SiteReference.Update {
    private SiteReferenceInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public SiteReferenceProperties properties() {
        return this.innerModel().properties();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public SiteReferenceInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String contextName;

    private String siteReferenceName;

    public SiteReferenceImpl withExistingContext(String resourceGroupName, String contextName) {
        this.resourceGroupName = resourceGroupName;
        this.contextName = contextName;
        return this;
    }

    public SiteReference create() {
        this.innerObject = serviceManager.serviceClient()
            .getSiteReferences()
            .createOrUpdate(resourceGroupName, contextName, siteReferenceName, this.innerModel(), Context.NONE);
        return this;
    }

    public SiteReference create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSiteReferences()
            .createOrUpdate(resourceGroupName, contextName, siteReferenceName, this.innerModel(), context);
        return this;
    }

    SiteReferenceImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new SiteReferenceInner();
        this.serviceManager = serviceManager;
        this.siteReferenceName = name;
    }

    public SiteReferenceImpl update() {
        return this;
    }

    public SiteReference apply() {
        this.innerObject = serviceManager.serviceClient()
            .getSiteReferences()
            .update(resourceGroupName, contextName, siteReferenceName, this.innerModel(), Context.NONE);
        return this;
    }

    public SiteReference apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSiteReferences()
            .update(resourceGroupName, contextName, siteReferenceName, this.innerModel(), context);
        return this;
    }

    SiteReferenceImpl(SiteReferenceInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.contextName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "contexts");
        this.siteReferenceName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "siteReferences");
    }

    public SiteReference refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getSiteReferences()
            .getWithResponse(resourceGroupName, contextName, siteReferenceName, Context.NONE)
            .getValue();
        return this;
    }

    public SiteReference refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSiteReferences()
            .getWithResponse(resourceGroupName, contextName, siteReferenceName, context)
            .getValue();
        return this;
    }

    public SiteReferenceImpl withProperties(SiteReferenceProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SiteReferencesClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SiteReferenceListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in SiteReferencesClient.
 */
public final class SiteReferencesClientImpl implements SiteReferencesClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SiteReferencesService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of SiteReferencesClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    SiteReferencesClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(SiteReferencesService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientSiteReferences to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientSiteReferences")
    public interface SiteReferencesService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SiteReferenceInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("siteReferenceName") String siteReferenceName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SiteReferenceInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("siteReferenceName") String siteReferenceName, @HeaderParam("Accept") String accept,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("siteReferenceName") String siteReferenceName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SiteReferenceInner resource,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("siteReferenceName") String siteReferenceName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SiteReferenceInner resource,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("siteReferenceName") String siteReferenceName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SiteReferenceInner properties,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("siteReferenceName") String siteReferenceName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SiteReferenceInner properties,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("siteReferenceName") String siteReferenceName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("siteReferenceName") String siteReferenceName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SiteReferenceListResult>> listByContext(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SiteReferenceListResult> listByContextSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SiteReferenceListResult>> listByContextNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SiteReferenceListResult> listByContextNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SiteReferenceInner>> getWithResponseAsync(String resourceGroupName, String contextName,
        String siteReferenceName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SiteReferenceInner> getAsync(String resourceGroupName, String contextName, String siteReferenceName) {
        return getWithResponseAsync(resourceGroupName, contextName, siteReferenceName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SiteReferenceInner> getWithResponse(String resourceGroupName, String contextName,
        String siteReferenceName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, contextName, siteReferenceName, accept, context);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SiteReferenceInner get(String resourceGroupName, String contextName, String siteReferenceName) {
        return getWithResponse(resourceGroupName, contextName, siteReferenceName, Context.NONE).getValue();
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, contentType, accept,
                resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        String siteReferenceName, SiteReferenceInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, contentType, accept,
            resource, Context.NONE);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        String siteReferenceName, SiteReferenceInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, contentType, accept,
            resource, context);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SiteReferenceInner>, SiteReferenceInner> beginCreateOrUpdateAsync(
        String resourceGroupName, String contextName, String siteReferenceName, SiteReferenceInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, contextName, siteReferenceName, resource);
        return this.client.<SiteReferenceInner, SiteReferenceInner>getLroResult(mono, this.client.getHttpPipeline(),
            SiteReferenceInner.class, SiteReferenceInner.class, this.client.getContext());
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SiteReferenceInner>, SiteReferenceInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner resource) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, contextName, siteReferenceName, resource);
        return this.client.<SiteReferenceInner, SiteReferenceInner>getLroResult(response, SiteReferenceInner.class,
            SiteReferenceInner.class, Context.NONE);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SiteReferenceInner>, SiteReferenceInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, contextName, siteReferenceName, resource, context);
        return this.client.<SiteReferenceInner, SiteReferenceInner>getLroResult(response, SiteReferenceInner.class,
            SiteReferenceInner.class, context);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SiteReferenceInner> createOrUpdateAsync(String resourceGroupName, String contextName,
        String siteReferenceName, SiteReferenceInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, contextName, siteReferenceName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SiteReferenceInner createOrUpdate(String resourceGroupName, String contextName, String siteReferenceName,
        SiteReferenceInner resource) {
        return beginCreateOrUpdate(resourceGroupName, contextName, siteReferenceName, resource).getFinalResult();
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SiteReferenceInner createOrUpdate(String resourceGroupName, String contextName, String siteReferenceName,
        SiteReferenceInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, contextName, siteReferenceName, resource, context)
            .getFinalResult();
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String contextName,
        String siteReferenceName, SiteReferenceInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, contentType, accept,
                properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName,
        String siteReferenceName, SiteReferenceInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, contentType, accept,
            properties, Context.NONE);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName,
        String siteReferenceName, SiteReferenceInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, contentType, accept,
            properties, context);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SiteReferenceInner>, SiteReferenceInner> beginUpdateAsync(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = updateWithResponseAsync(resourceGroupName, contextName, siteReferenceName, properties);
        return this.client.<SiteReferenceInner, SiteReferenceInner>getLroResult(mono, this.client.getHttpPipeline(),
            SiteReferenceInner.class, SiteReferenceInner.class, this.client.getContext());
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SiteReferenceInner>, SiteReferenceInner> beginUpdate(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner properties) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, contextName, siteReferenceName, properties);
        return this.client.<SiteReferenceInner, SiteReferenceInner>getLroResult(response, SiteReferenceInner.class,
            SiteReferenceInner.class, Context.NONE);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SiteReferenceInner>, SiteReferenceInner> beginUpdate(String resourceGroupName,
        String contextName, String siteReferenceName, SiteReferenceInner properties, Context context) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, contextName, siteReferenceName, properties, context);
        return this.client.<SiteReferenceInner, SiteReferenceInner>getLroResult(response, SiteReferenceInner.class,
            SiteReferenceInner.class, context);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SiteReferenceInner> updateAsync(String resourceGroupName, String contextName, String siteReferenceName,
        SiteReferenceInner properties) {
        return beginUpdateAsync(resourceGroupName, contextName, siteReferenceName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SiteReferenceInner update(String resourceGroupName, String contextName, String siteReferenceName,
        SiteReferenceInner properties) {
        return beginUpdate(resourceGroupName, contextName, siteReferenceName, properties).getFinalResult();
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SiteReferenceInner update(String resourceGroupName, String contextName, String siteReferenceName,
        SiteReferenceInner properties, Context context) {
        return beginUpdate(resourceGroupName, contextName, siteReferenceName, properties, context).getFinalResult();
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String contextName,
        String siteReferenceName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName,
        String siteReferenceName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, Context.NONE);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName,
        String siteReferenceName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (siteReferenceName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter siteReferenceName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, siteReferenceName, context);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String contextName,
        String siteReferenceName) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = deleteWithResponseAsync(resourceGroupName, contextName, siteReferenceName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String siteReferenceName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, contextName, siteReferenceName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of site Reference Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String siteReferenceName, Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, contextName, siteReferenceName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String contextName, String siteReferenceName) {
        return beginDeleteAsync(resourceGroupName, contextName, siteReferenceName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName, String siteReferenceName) {
        beginDelete(resourceGroupName, contextName, siteReferenceName).getFinalResult();
    }

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName, String siteReferenceName, Context context) {
        beginDelete(resourceGroupName, contextName, siteReferenceName, context).getFinalResult();
    }

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SiteReferenceInner>> listByContextSinglePageAsync(String resourceGroupName,
        String contextName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByContext(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, accept, context))
            .<PagedResponse<SiteReferenceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SiteReferenceInner> listByContextAsync(String resourceGroupName, String contextName) {
        return new PagedFlux<>(() -> listByContextSinglePageAsync(resourceGroupName, contextName),
            nextLink -> listByContextNextSinglePageAsync(nextLink));
    }

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SiteReferenceInner> listByContextSinglePage(String resourceGroupName, String contextName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SiteReferenceListResult> res
            = service.listByContextSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SiteReferenceInner> listByContextSinglePage(String resourceGroupName, String contextName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SiteReferenceListResult> res
            = service.listByContextSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SiteReferenceInner> listByContext(String resourceGroupName, String contextName) {
        return new PagedIterable<>(() -> listByContextSinglePage(resourceGroupName, contextName),
            nextLink -> listByContextNextSinglePage(nextLink));
    }

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SiteReferenceInner> listByContext(String resourceGroupName, String contextName,
        Context context) {
        return new PagedIterable<>(() -> listByContextSinglePage(resourceGroupName, contextName, context),
            nextLink -> listByContextNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation along with {@link PagedResponse} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SiteReferenceInner>> listByContextNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByContextNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SiteReferenceInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SiteReferenceInner> listByContextNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SiteReferenceListResult> res
            = service.listByContextNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SiteReferenceInner> listByContextNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SiteReferenceListResult> res
            = service.listByContextNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(SiteReferencesClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SiteReferencesImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner;
import com.azure.resourcemanager.workloadorchestration.models.SiteReference;
import com.azure.resourcemanager.workloadorchestration.models.SiteReferences;

public final class SiteReferencesImpl implements SiteReferences {
    private static final ClientLogger LOGGER = new ClientLogger(SiteReferencesImpl.class);

    private final SiteReferencesClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public SiteReferencesImpl(SiteReferencesClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<SiteReference> getWithResponse(String resourceGroupName, String contextName,
        String siteReferenceName, Context context) {
        Response<SiteReferenceInner> inner
            = this.serviceClient().getWithResponse(resourceGroupName, contextName, siteReferenceName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new SiteReferenceImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public SiteReference get(String resourceGroupName, String contextName, String siteReferenceName) {
        SiteReferenceInner inner = this.serviceClient().get(resourceGroupName, contextName, siteReferenceName);
        if (inner != null) {
            return new SiteReferenceImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String contextName, String siteReferenceName) {
        this.serviceClient().delete(resourceGroupName, contextName, siteReferenceName);
    }

    public void delete(String resourceGroupName, String contextName, String siteReferenceName, Context context) {
        this.serviceClient().delete(resourceGroupName, contextName, siteReferenceName, context);
    }

    public PagedIterable<SiteReference> listByContext(String resourceGroupName, String contextName) {
        PagedIterable<SiteReferenceInner> inner = this.serviceClient().listByContext(resourceGroupName, contextName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SiteReferenceImpl(inner1, this.manager()));
    }

    public PagedIterable<SiteReference> listByContext(String resourceGroupName, String contextName, Context context) {
        PagedIterable<SiteReferenceInner> inner
            = this.serviceClient().listByContext(resourceGroupName, contextName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SiteReferenceImpl(inner1, this.manager()));
    }

    public SiteReference getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String siteReferenceName = ResourceManagerUtils.getValueFromIdByName(id, "siteReferences");
        if (siteReferenceName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'siteReferences'.", id)));
        }
        return this.getWithResponse(resourceGroupName, contextName, siteReferenceName, Context.NONE).getValue();
    }

    public Response<SiteReference> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String siteReferenceName = ResourceManagerUtils.getValueFromIdByName(id, "siteReferences");
        if (siteReferenceName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'siteReferences'.", id)));
        }
        return this.getWithResponse(resourceGroupName, contextName, siteReferenceName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String siteReferenceName = ResourceManagerUtils.getValueFromIdByName(id, "siteReferences");
        if (siteReferenceName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'siteReferences'.", id)));
        }
        this.delete(resourceGroupName, contextName, siteReferenceName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String siteReferenceName = ResourceManagerUtils.getValueFromIdByName(id, "siteReferences");
        if (siteReferenceName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'siteReferences'.", id)));
        }
        this.delete(resourceGroupName, contextName, siteReferenceName, context);
    }

    private SiteReferencesClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public SiteReferenceImpl define(String name) {
        return new SiteReferenceImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.Solution;
import com.azure.resourcemanager.workloadorchestration.models.SolutionProperties;

public final class SolutionImpl implements Solution, Solution.Definition, Solution.Update {
    private SolutionInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public SolutionProperties properties() {
        return this.innerModel().properties();
    }

    public ExtendedLocation extendedLocation() {
        return this.innerModel().extendedLocation();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public SolutionInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String targetName;

    private String solutionName;

    public SolutionImpl withExistingTarget(String resourceGroupName, String targetName) {
        this.resourceGroupName = resourceGroupName;
        this.targetName = targetName;
        return this;
    }

    public Solution create() {
        this.innerObject = serviceManager.serviceClient()
            .getSolutions()
            .createOrUpdate(resourceGroupName, targetName, solutionName, this.innerModel(), Context.NONE);
        return this;
    }

    public Solution create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSolutions()
            .createOrUpdate(resourceGroupName, targetName, solutionName, this.innerModel(), context);
        return this;
    }

    SolutionImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new SolutionInner();
        this.serviceManager = serviceManager;
        this.solutionName = name;
    }

    public SolutionImpl update() {
        return this;
    }

    public Solution apply() {
        this.innerObject = serviceManager.serviceClient()
            .getSolutions()
            .update(resourceGroupName, targetName, solutionName, this.innerModel(), Context.NONE);
        return this;
    }

    public Solution apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSolutions()
            .update(resourceGroupName, targetName, solutionName, this.innerModel(), context);
        return this;
    }

    SolutionImpl(SolutionInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.targetName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "targets");
        this.solutionName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "solutions");
    }

    public Solution refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getSolutions()
            .getWithResponse(resourceGroupName, targetName, solutionName, Context.NONE)
            .getValue();
        return this;
    }

    public Solution refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSolutions()
            .getWithResponse(resourceGroupName, targetName, solutionName, context)
            .getValue();
        return this;
    }

    public SolutionImpl withProperties(SolutionProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }

    public SolutionImpl withExtendedLocation(ExtendedLocation extendedLocation) {
        this.innerModel().withExtendedLocation(extendedLocation);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in SolutionsClient.
 */
public final class SolutionsClientImpl implements SolutionsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SolutionsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of SolutionsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    SolutionsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(SolutionsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientSolutions to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientSolutions")
    public interface SolutionsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SolutionInner resource,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SolutionInner resource,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SolutionInner properties,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") SolutionInner properties,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionListResult>> listByTarget(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionListResult> listByTargetSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionListResult>> listByTargetNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionListResult> listByTargetNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Solution resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SolutionInner>> getWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Solution resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionInner> getAsync(String resourceGroupName, String targetName, String solutionName) {
        return getWithResponseAsync(resourceGroupName, targetName, solutionName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Solution resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SolutionInner> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, targetName, solutionName, accept, context);
    }

    /**
     * Get a Solution resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionInner get(String resourceGroupName, String targetName, String solutionName) {
        return getWithResponse(resourceGroupName, targetName, solutionName, Context.NONE).getValue();
    }

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String targetName, String solutionName, SolutionInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, contentType, accept,
                resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String targetName,
        String solutionName, SolutionInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, contentType, accept, resource,
            Context.NONE);
    }

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String targetName,
        String solutionName, SolutionInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, contentType, accept, resource,
            context);
    }

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SolutionInner>, SolutionInner> beginCreateOrUpdateAsync(String resourceGroupName,
        String targetName, String solutionName, SolutionInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, targetName, solutionName, resource);
        return this.client.<SolutionInner, SolutionInner>getLroResult(mono, this.client.getHttpPipeline(),
            SolutionInner.class, SolutionInner.class, this.client.getContext());
    }

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionInner>, SolutionInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, SolutionInner resource) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, targetName, solutionName, resource);
        return this.client.<SolutionInner, SolutionInner>getLroResult(response, SolutionInner.class,
            SolutionInner.class, Context.NONE);
    }

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionInner>, SolutionInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, String solutionName, SolutionInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, targetName, solutionName, resource, context);
        return this.client.<SolutionInner, SolutionInner>getLroResult(response, SolutionInner.class,
            SolutionInner.class, context);
    }

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionInner> createOrUpdateAsync(String resourceGroupName, String targetName, String solutionName,
        SolutionInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, targetName, solutionName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        SolutionInner resource) {
        return beginCreateOrUpdate(resourceGroupName, targetName, solutionName, resource).getFinalResult();
    }

    /**
     * Create or update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        SolutionInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, targetName, solutionName, resource, context).getFinalResult();
    }

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName, SolutionInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, contentType, accept,
                properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String targetName, String solutionName,
        SolutionInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, contentType, accept,
            properties, Context.NONE);
    }

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String targetName, String solutionName,
        SolutionInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, contentType, accept,
            properties, context);
    }

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SolutionInner>, SolutionInner> beginUpdateAsync(String resourceGroupName,
        String targetName, String solutionName, SolutionInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = updateWithResponseAsync(resourceGroupName, targetName, solutionName, properties);
        return this.client.<SolutionInner, SolutionInner>getLroResult(mono, this.client.getHttpPipeline(),
            SolutionInner.class, SolutionInner.class, this.client.getContext());
    }

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionInner>, SolutionInner> beginUpdate(String resourceGroupName, String targetName,
        String solutionName, SolutionInner properties) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, targetName, solutionName, properties);
        return this.client.<SolutionInner, SolutionInner>getLroResult(response, SolutionInner.class,
            SolutionInner.class, Context.NONE);
    }

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionInner>, SolutionInner> beginUpdate(String resourceGroupName, String targetName,
        String solutionName, SolutionInner properties, Context context) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, targetName, solutionName, properties, context);
        return this.client.<SolutionInner, SolutionInner>getLroResult(response, SolutionInner.class,
            SolutionInner.class, context);
    }

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionInner> updateAsync(String resourceGroupName, String targetName, String solutionName,
        SolutionInner properties) {
        return beginUpdateAsync(resourceGroupName, targetName, solutionName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionInner update(String resourceGroupName, String targetName, String solutionName,
        SolutionInner properties) {
        return beginUpdate(resourceGroupName, targetName, solutionName, properties).getFinalResult();
    }

    /**
     * Update a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Resource attached to a Target.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionInner update(String resourceGroupName, String targetName, String solutionName,
        SolutionInner properties, Context context) {
        return beginUpdate(resourceGroupName, targetName, solutionName, properties, context).getFinalResult();
    }

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String targetName, String solutionName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, Context.NONE);
    }

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String targetName, String solutionName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, context);
    }

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String targetName,
        String solutionName) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, targetName, solutionName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName,
        String solutionName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, targetName, solutionName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName,
        String solutionName, Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, targetName, solutionName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String targetName, String solutionName) {
        return beginDeleteAsync(resourceGroupName, targetName, solutionName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String targetName, String solutionName) {
        beginDelete(resourceGroupName, targetName, solutionName).getFinalResult();
    }

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String targetName, String solutionName, Context context) {
        beginDelete(resourceGroupName, targetName, solutionName, context).getFinalResult();
    }

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionInner>> listByTargetSinglePageAsync(String resourceGroupName,
        String targetName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByTarget(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, accept, context))
            .<PagedResponse<SolutionInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SolutionInner> listByTargetAsync(String resourceGroupName, String targetName) {
        return new PagedFlux<>(() -> listByTargetSinglePageAsync(resourceGroupName, targetName),
            nextLink -> listByTargetNextSinglePageAsync(nextLink));
    }

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionInner> listByTargetSinglePage(String resourceGroupName, String targetName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionListResult> res
            = service.listByTargetSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionInner> listByTargetSinglePage(String resourceGroupName, String targetName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionListResult> res
            = service.listByTargetSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionInner> listByTarget(String resourceGroupName, String targetName) {
        return new PagedIterable<>(() -> listByTargetSinglePage(resourceGroupName, targetName),
            nextLink -> listByTargetNextSinglePage(nextLink));
    }

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionInner> listByTarget(String resourceGroupName, String targetName, Context context) {
        return new PagedIterable<>(() -> listByTargetSinglePage(resourceGroupName, targetName, context),
            nextLink -> listByTargetNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionInner>> listByTargetNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByTargetNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SolutionInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionInner> listByTargetNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionListResult> res
            = service.listByTargetNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionInner> listByTargetNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionListResult> res
            = service.listByTargetNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner;
import com.azure.resourcemanager.workloadorchestration.models.Solution;
import com.azure.resourcemanager.workloadorchestration.models.Solutions;

public final class SolutionsImpl implements Solutions {
    private static final ClientLogger LOGGER = new ClientLogger(SolutionsImpl.class);

    private final SolutionsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public SolutionsImpl(SolutionsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<Solution> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        Context context) {
        Response<SolutionInner> inner
            = this.serviceClient().getWithResponse(resourceGroupName, targetName, solutionName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new SolutionImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public Solution get(String resourceGroupName, String targetName, String solutionName) {
        SolutionInner inner = this.serviceClient().get(resourceGroupName, targetName, solutionName);
        if (inner != null) {
            return new SolutionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String targetName, String solutionName) {
        this.serviceClient().delete(resourceGroupName, targetName, solutionName);
    }

    public void delete(String resourceGroupName, String targetName, String solutionName, Context context) {
        this.serviceClient().delete(resourceGroupName, targetName, solutionName, context);
    }

    public PagedIterable<Solution> listByTarget(String resourceGroupName, String targetName) {
        PagedIterable<SolutionInner> inner = this.serviceClient().listByTarget(resourceGroupName, targetName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionImpl(inner1, this.manager()));
    }

    public PagedIterable<Solution> listByTarget(String resourceGroupName, String targetName, Context context) {
        PagedIterable<SolutionInner> inner = this.serviceClient().listByTarget(resourceGroupName, targetName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionImpl(inner1, this.manager()));
    }

    public Solution getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, targetName, solutionName, Context.NONE).getValue();
    }

    public Response<Solution> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, targetName, solutionName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        this.delete(resourceGroupName, targetName, solutionName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        this.delete(resourceGroupName, targetName, solutionName, context);
    }

    private SolutionsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public SolutionImpl define(String name) {
        return new SolutionImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionTemplateImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplate;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;
import java.util.Collections;
import java.util.Map;

public final class SolutionTemplateImpl
    implements SolutionTemplate, SolutionTemplate.Definition, SolutionTemplate.Update {
    private SolutionTemplateInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public String location() {
        return this.innerModel().location();
    }

    public Map<String, String> tags() {
        Map<String, String> inner = this.innerModel().tags();
        if (inner != null) {
            return Collections.unmodifiableMap(inner);
        } else {
            return Collections.emptyMap();
        }
    }

    public SolutionTemplateProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public Region region() {
        return Region.fromName(this.regionName());
    }

    public String regionName() {
        return this.location();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public SolutionTemplateInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String solutionTemplateName;

    public SolutionTemplateImpl withExistingResourceGroup(String resourceGroupName) {
        this.resourceGroupName = resourceGroupName;
        return this;
    }

    public SolutionTemplate create() {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionTemplates()
            .createOrUpdate(resourceGroupName, solutionTemplateName, this.innerModel(), Context.NONE);
        return this;
    }

    public SolutionTemplate create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionTemplates()
            .createOrUpdate(resourceGroupName, solutionTemplateName, this.innerModel(), context);
        return this;
    }

    SolutionTemplateImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new SolutionTemplateInner();
        this.serviceManager = serviceManager;
        this.solutionTemplateName = name;
    }

    public SolutionTemplateImpl update() {
        return this;
    }

    public SolutionTemplate apply() {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionTemplates()
            .updateWithResponse(resourceGroupName, solutionTemplateName, this.innerModel(), Context.NONE)
            .getValue();
        return this;
    }

    public SolutionTemplate apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionTemplates()
            .updateWithResponse(resourceGroupName, solutionTemplateName, this.innerModel(), context)
            .getValue();
        return this;
    }

    SolutionTemplateImpl(SolutionTemplateInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.solutionTemplateName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "solutionTemplates");
    }

    public SolutionTemplate refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionTemplates()
            .getByResourceGroupWithResponse(resourceGroupName, solutionTemplateName, Context.NONE)
            .getValue();
        return this;
    }

    public SolutionTemplate refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionTemplates()
            .getByResourceGroupWithResponse(resourceGroupName, solutionTemplateName, context)
            .getValue();
        return this;
    }

    public SolutionTemplateVersion createVersion(SolutionTemplateVersionWithUpdateTypeInner body) {
        return serviceManager.solutionTemplates().createVersion(resourceGroupName, solutionTemplateName, body);
    }

    public SolutionTemplateVersion createVersion(SolutionTemplateVersionWithUpdateTypeInner body, Context context) {
        return serviceManager.solutionTemplates().createVersion(resourceGroupName, solutionTemplateName, body, context);
    }

    public void removeVersion(VersionParameter body) {
        serviceManager.solutionTemplates().removeVersion(resourceGroupName, solutionTemplateName, body);
    }

    public void removeVersion(VersionParameter body, Context context) {
        serviceManager.solutionTemplates().removeVersion(resourceGroupName, solutionTemplateName, body, context);
    }

    public SolutionTemplateImpl withRegion(Region location) {
        this.innerModel().withLocation(location.toString());
        return this;
    }

    public SolutionTemplateImpl withRegion(String location) {
        this.innerModel().withLocation(location);
        return this;
    }

    public SolutionTemplateImpl withTags(Map<String, String> tags) {
        this.innerModel().withTags(tags);
        return this;
    }

    public SolutionTemplateImpl withProperties(SolutionTemplateProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionTemplatesClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionTemplateListResult;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in SolutionTemplatesClient.
 */
public final class SolutionTemplatesClientImpl implements SolutionTemplatesClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SolutionTemplatesService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of SolutionTemplatesClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    SolutionTemplatesClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(SolutionTemplatesService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientSolutionTemplates to be used by
     * the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientSolutionTemplates")
    public interface SolutionTemplatesService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionTemplateInner>> getByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionTemplateInner> getByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName, @HeaderParam("Accept") String accept,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateInner resource, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateInner resource, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionTemplateInner>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateInner properties, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionTemplateInner> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateInner properties, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/createVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createVersion(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateVersionWithUpdateTypeInner body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/createVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createVersionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateVersionWithUpdateTypeInner body, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/removeVersion")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> removeVersion(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @HeaderParam("Content-Type") String contentType, @BodyParam("application/json") VersionParameter body,
            Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/removeVersion")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> removeVersionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @HeaderParam("Content-Type") String contentType, @BodyParam("application/json") VersionParameter body,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionTemplateListResult>> listByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionTemplateListResult> listByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/solutionTemplates")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionTemplateListResult>> list(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/solutionTemplates")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionTemplateListResult> listSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionTemplateListResult>> listByResourceGroupNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionTemplateListResult> listByResourceGroupNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionTemplateListResult>> listBySubscriptionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionTemplateListResult> listBySubscriptionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SolutionTemplateInner>> getByResourceGroupWithResponseAsync(String resourceGroupName,
        String solutionTemplateName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionTemplateInner> getByResourceGroupAsync(String resourceGroupName, String solutionTemplateName) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, solutionTemplateName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SolutionTemplateInner> getByResourceGroupWithResponse(String resourceGroupName,
        String solutionTemplateName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getByResourceGroupSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, accept, context);
    }

    /**
     * Get a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionTemplateInner getByResourceGroup(String resourceGroupName, String solutionTemplateName) {
        return getByResourceGroupWithResponse(resourceGroupName, solutionTemplateName, Context.NONE).getValue();
    }

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String solutionTemplateName, SolutionTemplateInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, accept, resource,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, accept, resource,
            Context.NONE);
    }

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, accept, resource,
            context);
    }

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SolutionTemplateInner>, SolutionTemplateInner> beginCreateOrUpdateAsync(
        String resourceGroupName, String solutionTemplateName, SolutionTemplateInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, solutionTemplateName, resource);
        return this.client.<SolutionTemplateInner, SolutionTemplateInner>getLroResult(mono,
            this.client.getHttpPipeline(), SolutionTemplateInner.class, SolutionTemplateInner.class,
            this.client.getContext());
    }

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionTemplateInner>, SolutionTemplateInner>
        beginCreateOrUpdate(String resourceGroupName, String solutionTemplateName, SolutionTemplateInner resource) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, solutionTemplateName, resource);
        return this.client.<SolutionTemplateInner, SolutionTemplateInner>getLroResult(response,
            SolutionTemplateInner.class, SolutionTemplateInner.class, Context.NONE);
    }

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionTemplateInner>, SolutionTemplateInner> beginCreateOrUpdate(
        String resourceGroupName, String solutionTemplateName, SolutionTemplateInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, solutionTemplateName, resource, context);
        return this.client.<SolutionTemplateInner, SolutionTemplateInner>getLroResult(response,
            SolutionTemplateInner.class, SolutionTemplateInner.class, context);
    }

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionTemplateInner> createOrUpdateAsync(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, solutionTemplateName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionTemplateInner createOrUpdate(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner resource) {
        return beginCreateOrUpdate(resourceGroupName, solutionTemplateName, resource).getFinalResult();
    }

    /**
     * Create or update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionTemplateInner createOrUpdate(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, solutionTemplateName, resource, context).getFinalResult();
    }

    /**
     * update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SolutionTemplateInner>> updateWithResponseAsync(String resourceGroupName,
        String solutionTemplateName, SolutionTemplateInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, accept,
                properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionTemplateInner> updateAsync(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner properties) {
        return updateWithResponseAsync(resourceGroupName, solutionTemplateName, properties)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SolutionTemplateInner> updateWithResponse(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, accept, properties,
            context);
    }

    /**
     * update a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Template Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionTemplateInner update(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateInner properties) {
        return updateWithResponse(resourceGroupName, solutionTemplateName, properties, Context.NONE).getValue();
    }

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createVersionWithResponseAsync(String resourceGroupName,
        String solutionTemplateName, SolutionTemplateVersionWithUpdateTypeInner body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createVersion(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, accept, body,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createVersionWithResponse(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, accept, body,
            Context.NONE);
    }

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createVersionWithResponse(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, accept, body,
            context);
    }

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SolutionTemplateVersionInner>, SolutionTemplateVersionInner> beginCreateVersionAsync(
        String resourceGroupName, String solutionTemplateName, SolutionTemplateVersionWithUpdateTypeInner body) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createVersionWithResponseAsync(resourceGroupName, solutionTemplateName, body);
        return this.client.<SolutionTemplateVersionInner, SolutionTemplateVersionInner>getLroResult(mono,
            this.client.getHttpPipeline(), SolutionTemplateVersionInner.class, SolutionTemplateVersionInner.class,
            this.client.getContext());
    }

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionTemplateVersionInner>, SolutionTemplateVersionInner> beginCreateVersion(
        String resourceGroupName, String solutionTemplateName, SolutionTemplateVersionWithUpdateTypeInner body) {
        Response<BinaryData> response = createVersionWithResponse(resourceGroupName, solutionTemplateName, body);
        return this.client.<SolutionTemplateVersionInner, SolutionTemplateVersionInner>getLroResult(response,
            SolutionTemplateVersionInner.class, SolutionTemplateVersionInner.class, Context.NONE);
    }

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionTemplateVersionInner>, SolutionTemplateVersionInner> beginCreateVersion(
        String resourceGroupName, String solutionTemplateName, SolutionTemplateVersionWithUpdateTypeInner body,
        Context context) {
        Response<BinaryData> response
            = createVersionWithResponse(resourceGroupName, solutionTemplateName, body, context);
        return this.client.<SolutionTemplateVersionInner, SolutionTemplateVersionInner>getLroResult(response,
            SolutionTemplateVersionInner.class, SolutionTemplateVersionInner.class, context);
    }

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionTemplateVersionInner> createVersionAsync(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body) {
        return beginCreateVersionAsync(resourceGroupName, solutionTemplateName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionTemplateVersionInner createVersion(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body) {
        return beginCreateVersion(resourceGroupName, solutionTemplateName, body).getFinalResult();
    }

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionTemplateVersionInner createVersion(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body, Context context) {
        return beginCreateVersion(resourceGroupName, solutionTemplateName, body, context).getFinalResult();
    }

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> removeVersionWithResponseAsync(String resourceGroupName,
        String solutionTemplateName, VersionParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return FluxUtil
            .withContext(context -> service.removeVersion(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> removeVersionWithResponse(String resourceGroupName, String solutionTemplateName,
        VersionParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.removeVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, body, Context.NONE);
    }

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> removeVersionWithResponse(String resourceGroupName, String solutionTemplateName,
        VersionParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.removeVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, contentType, body, context);
    }

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginRemoveVersionAsync(String resourceGroupName,
        String solutionTemplateName, VersionParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = removeVersionWithResponseAsync(resourceGroupName, solutionTemplateName, body);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginRemoveVersion(String resourceGroupName, String solutionTemplateName,
        VersionParameter body) {
        Response<BinaryData> response = removeVersionWithResponse(resourceGroupName, solutionTemplateName, body);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginRemoveVersion(String resourceGroupName, String solutionTemplateName,
        VersionParameter body, Context context) {
        Response<BinaryData> response
            = removeVersionWithResponse(resourceGroupName, solutionTemplateName, body, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> removeVersionAsync(String resourceGroupName, String solutionTemplateName,
        VersionParameter body) {
        return beginRemoveVersionAsync(resourceGroupName, solutionTemplateName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void removeVersion(String resourceGroupName, String solutionTemplateName, VersionParameter body) {
        beginRemoveVersion(resourceGroupName, solutionTemplateName, body).getFinalResult();
    }

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void removeVersion(String resourceGroupName, String solutionTemplateName, VersionParameter body,
        Context context) {
        beginRemoveVersion(resourceGroupName, solutionTemplateName, body, context).getFinalResult();
    }

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName,
        String solutionTemplateName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String solutionTemplateName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, Context.NONE);
    }

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String solutionTemplateName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, context);
    }

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String solutionTemplateName) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, solutionTemplateName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String solutionTemplateName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, solutionTemplateName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String solutionTemplateName,
        Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, solutionTemplateName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String solutionTemplateName) {
        return beginDeleteAsync(resourceGroupName, solutionTemplateName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String solutionTemplateName) {
        beginDelete(resourceGroupName, solutionTemplateName).getFinalResult();
    }

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String solutionTemplateName, Context context) {
        beginDelete(resourceGroupName, solutionTemplateName, context).getFinalResult();
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionTemplateInner>> listByResourceGroupSinglePageAsync(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, accept, context))
            .<PagedResponse<SolutionTemplateInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SolutionTemplateInner> listByResourceGroupAsync(String resourceGroupName) {
        return new PagedFlux<>(() -> listByResourceGroupSinglePageAsync(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateInner> listByResourceGroupSinglePage(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateInner> listByResourceGroupSinglePage(String resourceGroupName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionTemplateInner> listByResourceGroup(String resourceGroupName) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePage(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionTemplateInner> listByResourceGroup(String resourceGroupName, Context context) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName, context),
            nextLink -> listByResourceGroupNextSinglePage(nextLink, context));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionTemplateInner>> listSinglePageAsync() {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.list(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), accept, context))
            .<PagedResponse<SolutionTemplateInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SolutionTemplateInner> listAsync() {
        return new PagedFlux<>(() -> listSinglePageAsync(),
            nextLink -> listBySubscriptionNextSinglePageAsync(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateInner> listSinglePage() {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateListResult> res = service.listSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateInner> listSinglePage(Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateListResult> res = service.listSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionTemplateInner> list() {
        return new PagedIterable<>(() -> listSinglePage(), nextLink -> listBySubscriptionNextSinglePage(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionTemplateInner> list(Context context) {
        return new PagedIterable<>(() -> listSinglePage(context),
            nextLink -> listBySubscriptionNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionTemplateInner>> listByResourceGroupNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SolutionTemplateInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateInner> listByResourceGroupNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateInner> listByResourceGroupNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionTemplateInner>> listBySubscriptionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listBySubscriptionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SolutionTemplateInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateInner> listBySubscriptionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateInner> listBySubscriptionNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplatesClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionTemplatesImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplate;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplates;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

public final class SolutionTemplatesImpl implements SolutionTemplates {
    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplatesImpl.class);

    private final SolutionTemplatesClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public SolutionTemplatesImpl(SolutionTemplatesClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<SolutionTemplate> getByResourceGroupWithResponse(String resourceGroupName,
        String solutionTemplateName, Context context) {
        Response<SolutionTemplateInner> inner
            = this.serviceClient().getByResourceGroupWithResponse(resourceGroupName, solutionTemplateName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new SolutionTemplateImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public SolutionTemplate getByResourceGroup(String resourceGroupName, String solutionTemplateName) {
        SolutionTemplateInner inner = this.serviceClient().getByResourceGroup(resourceGroupName, solutionTemplateName);
        if (inner != null) {
            return new SolutionTemplateImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SolutionTemplateVersion createVersion(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body) {
        SolutionTemplateVersionInner inner
            = this.serviceClient().createVersion(resourceGroupName, solutionTemplateName, body);
        if (inner != null) {
            return new SolutionTemplateVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SolutionTemplateVersion createVersion(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body, Context context) {
        SolutionTemplateVersionInner inner
            = this.serviceClient().createVersion(resourceGroupName, solutionTemplateName, body, context);
        if (inner != null) {
            return new SolutionTemplateVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void removeVersion(String resourceGroupName, String solutionTemplateName, VersionParameter body) {
        this.serviceClient().removeVersion(resourceGroupName, solutionTemplateName, body);
    }

    public void removeVersion(String resourceGroupName, String solutionTemplateName, VersionParameter body,
        Context context) {
        this.serviceClient().removeVersion(resourceGroupName, solutionTemplateName, body, context);
    }

    public void deleteByResourceGroup(String resourceGroupName, String solutionTemplateName) {
        this.serviceClient().delete(resourceGroupName, solutionTemplateName);
    }

    public void delete(String resourceGroupName, String solutionTemplateName, Context context) {
        this.serviceClient().delete(resourceGroupName, solutionTemplateName, context);
    }

    public PagedIterable<SolutionTemplate> listByResourceGroup(String resourceGroupName) {
        PagedIterable<SolutionTemplateInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionTemplateImpl(inner1, this.manager()));
    }

    public PagedIterable<SolutionTemplate> listByResourceGroup(String resourceGroupName, Context context) {
        PagedIterable<SolutionTemplateInner> inner
            = this.serviceClient().listByResourceGroup(resourceGroupName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionTemplateImpl(inner1, this.manager()));
    }

    public PagedIterable<SolutionTemplate> list() {
        PagedIterable<SolutionTemplateInner> inner = this.serviceClient().list();
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionTemplateImpl(inner1, this.manager()));
    }

    public PagedIterable<SolutionTemplate> list(Context context) {
        PagedIterable<SolutionTemplateInner> inner = this.serviceClient().list(context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionTemplateImpl(inner1, this.manager()));
    }

    public SolutionTemplate getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String solutionTemplateName = ResourceManagerUtils.getValueFromIdByName(id, "solutionTemplates");
        if (solutionTemplateName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutionTemplates'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, solutionTemplateName, Context.NONE).getValue();
    }

    public Response<SolutionTemplate> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String solutionTemplateName = ResourceManagerUtils.getValueFromIdByName(id, "solutionTemplates");
        if (solutionTemplateName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutionTemplates'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, solutionTemplateName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String solutionTemplateName = ResourceManagerUtils.getValueFromIdByName(id, "solutionTemplates");
        if (solutionTemplateName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutionTemplates'.", id)));
        }
        this.delete(resourceGroupName, solutionTemplateName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String solutionTemplateName = ResourceManagerUtils.getValueFromIdByName(id, "solutionTemplates");
        if (solutionTemplateName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutionTemplates'.", id)));
        }
        this.delete(resourceGroupName, solutionTemplateName, context);
    }

    private SolutionTemplatesClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public SolutionTemplateImpl define(String name) {
        return new SolutionTemplateImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionTemplateVersionImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties;

public final class SolutionTemplateVersionImpl implements SolutionTemplateVersion {
    private SolutionTemplateVersionInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    SolutionTemplateVersionImpl(SolutionTemplateVersionInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public SolutionTemplateVersionProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public SolutionTemplateVersionInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionTemplateVersionsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionTemplateVersionListResult;
import com.azure.resourcemanager.workloadorchestration.models.BulkDeploySolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.BulkPublishSolutionParameter;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in SolutionTemplateVersionsClient.
 */
public final class SolutionTemplateVersionsClientImpl implements SolutionTemplateVersionsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SolutionTemplateVersionsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of SolutionTemplateVersionsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    SolutionTemplateVersionsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service = RestProxy.create(SolutionTemplateVersionsService.class, client.getHttpPipeline(),
            client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientSolutionTemplateVersions to be
     * used by the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientSolutionTemplateVersions")
    public interface SolutionTemplateVersionsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionTemplateVersionInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @PathParam("solutionTemplateVersionName") String solutionTemplateVersionName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionTemplateVersionInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @PathParam("solutionTemplateVersionName") String solutionTemplateVersionName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionTemplateVersionListResult>> listBySolutionTemplate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionTemplateVersionListResult> listBySolutionTemplateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkDeploySolution")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> bulkDeploySolution(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @PathParam("solutionTemplateVersionName") String solutionTemplateVersionName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BulkDeploySolutionParameter body, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkDeploySolution")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> bulkDeploySolutionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @PathParam("solutionTemplateVersionName") String solutionTemplateVersionName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BulkDeploySolutionParameter body, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkPublishSolution")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> bulkPublishSolution(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @PathParam("solutionTemplateVersionName") String solutionTemplateVersionName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BulkPublishSolutionParameter body, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkPublishSolution")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> bulkPublishSolutionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName,
            @PathParam("solutionTemplateName") String solutionTemplateName,
            @PathParam("solutionTemplateVersionName") String solutionTemplateVersionName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") BulkPublishSolutionParameter body, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionTemplateVersionListResult>> listBySolutionTemplateNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionTemplateVersionListResult> listBySolutionTemplateNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Version Resource along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SolutionTemplateVersionInner>> getWithResponseAsync(String resourceGroupName,
        String solutionTemplateName, String solutionTemplateVersionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (solutionTemplateVersionName == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter solutionTemplateVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, solutionTemplateVersionName,
                accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionTemplateVersionInner> getAsync(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName) {
        return getWithResponseAsync(resourceGroupName, solutionTemplateName, solutionTemplateVersionName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SolutionTemplateVersionInner> getWithResponse(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (solutionTemplateVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter solutionTemplateVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, solutionTemplateName, solutionTemplateVersionName, accept, context);
    }

    /**
     * Get a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionTemplateVersionInner get(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName) {
        return getWithResponse(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, Context.NONE)
            .getValue();
    }

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionTemplateVersionInner>>
        listBySolutionTemplateSinglePageAsync(String resourceGroupName, String solutionTemplateName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listBySolutionTemplate(this.client.getEndpoint(), this.client.getApiVersion(),
                    this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, accept, context))
            .<PagedResponse<SolutionTemplateVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SolutionTemplateVersionInner> listBySolutionTemplateAsync(String resourceGroupName,
        String solutionTemplateName) {
        return new PagedFlux<>(() -> listBySolutionTemplateSinglePageAsync(resourceGroupName, solutionTemplateName),
            nextLink -> listBySolutionTemplateNextSinglePageAsync(nextLink));
    }

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateVersionInner> listBySolutionTemplateSinglePage(String resourceGroupName,
        String solutionTemplateName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateVersionListResult> res
            = service.listBySolutionTemplateSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateVersionInner> listBySolutionTemplateSinglePage(String resourceGroupName,
        String solutionTemplateName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateVersionListResult> res
            = service.listBySolutionTemplateSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionTemplateVersionInner> listBySolutionTemplate(String resourceGroupName,
        String solutionTemplateName) {
        return new PagedIterable<>(() -> listBySolutionTemplateSinglePage(resourceGroupName, solutionTemplateName),
            nextLink -> listBySolutionTemplateNextSinglePage(nextLink));
    }

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation as paginated response with
     * {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionTemplateVersionInner> listBySolutionTemplate(String resourceGroupName,
        String solutionTemplateName, Context context) {
        return new PagedIterable<>(
            () -> listBySolutionTemplateSinglePage(resourceGroupName, solutionTemplateName, context),
            nextLink -> listBySolutionTemplateNextSinglePage(nextLink, context));
    }

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> bulkDeploySolutionWithResponseAsync(String resourceGroupName,
        String solutionTemplateName, String solutionTemplateVersionName, BulkDeploySolutionParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (solutionTemplateVersionName == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter solutionTemplateVersionName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return FluxUtil
            .withContext(context -> service.bulkDeploySolution(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, solutionTemplateVersionName,
                contentType, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> bulkDeploySolutionWithResponse(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkDeploySolutionParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (solutionTemplateVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter solutionTemplateVersionName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.bulkDeploySolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, solutionTemplateVersionName,
            contentType, body, Context.NONE);
    }

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> bulkDeploySolutionWithResponse(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkDeploySolutionParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (solutionTemplateVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter solutionTemplateVersionName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.bulkDeploySolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, solutionTemplateVersionName,
            contentType, body, context);
    }

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginBulkDeploySolutionAsync(String resourceGroupName,
        String solutionTemplateName, String solutionTemplateVersionName, BulkDeploySolutionParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono = bulkDeploySolutionWithResponseAsync(resourceGroupName,
            solutionTemplateName, solutionTemplateVersionName, body);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginBulkDeploySolution(String resourceGroupName,
        String solutionTemplateName, String solutionTemplateVersionName, BulkDeploySolutionParameter body) {
        Response<BinaryData> response = bulkDeploySolutionWithResponse(resourceGroupName, solutionTemplateName,
            solutionTemplateVersionName, body);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginBulkDeploySolution(String resourceGroupName,
        String solutionTemplateName, String solutionTemplateVersionName, BulkDeploySolutionParameter body,
        Context context) {
        Response<BinaryData> response = bulkDeploySolutionWithResponse(resourceGroupName, solutionTemplateName,
            solutionTemplateVersionName, body, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> bulkDeploySolutionAsync(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkDeploySolutionParameter body) {
        return beginBulkDeploySolutionAsync(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void bulkDeploySolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkDeploySolutionParameter body) {
        beginBulkDeploySolution(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body)
            .getFinalResult();
    }

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void bulkDeploySolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkDeploySolutionParameter body, Context context) {
        beginBulkDeploySolution(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body, context)
            .getFinalResult();
    }

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> bulkPublishSolutionWithResponseAsync(String resourceGroupName,
        String solutionTemplateName, String solutionTemplateVersionName, BulkPublishSolutionParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (solutionTemplateVersionName == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter solutionTemplateVersionName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return FluxUtil
            .withContext(context -> service.bulkPublishSolution(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, solutionTemplateVersionName,
                contentType, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> bulkPublishSolutionWithResponse(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkPublishSolutionParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (solutionTemplateVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter solutionTemplateVersionName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.bulkPublishSolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, solutionTemplateVersionName,
            contentType, body, Context.NONE);
    }

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> bulkPublishSolutionWithResponse(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkPublishSolutionParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (solutionTemplateName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionTemplateName is required and cannot be null."));
        }
        if (solutionTemplateVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter solutionTemplateVersionName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.bulkPublishSolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, solutionTemplateName, solutionTemplateVersionName,
            contentType, body, context);
    }

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginBulkPublishSolutionAsync(String resourceGroupName,
        String solutionTemplateName, String solutionTemplateVersionName, BulkPublishSolutionParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono = bulkPublishSolutionWithResponseAsync(resourceGroupName,
            solutionTemplateName, solutionTemplateVersionName, body);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginBulkPublishSolution(String resourceGroupName,
        String solutionTemplateName, String solutionTemplateVersionName, BulkPublishSolutionParameter body) {
        Response<BinaryData> response = bulkPublishSolutionWithResponse(resourceGroupName, solutionTemplateName,
            solutionTemplateVersionName, body);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginBulkPublishSolution(String resourceGroupName,
        String solutionTemplateName, String solutionTemplateVersionName, BulkPublishSolutionParameter body,
        Context context) {
        Response<BinaryData> response = bulkPublishSolutionWithResponse(resourceGroupName, solutionTemplateName,
            solutionTemplateVersionName, body, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> bulkPublishSolutionAsync(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkPublishSolutionParameter body) {
        return beginBulkPublishSolutionAsync(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void bulkPublishSolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkPublishSolutionParameter body) {
        beginBulkPublishSolution(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body)
            .getFinalResult();
    }

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void bulkPublishSolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkPublishSolutionParameter body, Context context) {
        beginBulkPublishSolution(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body, context)
            .getFinalResult();
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionTemplateVersionInner>>
        listBySolutionTemplateNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listBySolutionTemplateNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SolutionTemplateVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateVersionInner> listBySolutionTemplateNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateVersionListResult> res
            = service.listBySolutionTemplateNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionTemplateVersionInner> listBySolutionTemplateNextSinglePage(String nextLink,
        Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionTemplateVersionListResult> res
            = service.listBySolutionTemplateNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplateVersionsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionTemplateVersionsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.BulkDeploySolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.BulkPublishSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersions;

public final class SolutionTemplateVersionsImpl implements SolutionTemplateVersions {
    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplateVersionsImpl.class);

    private final SolutionTemplateVersionsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public SolutionTemplateVersionsImpl(SolutionTemplateVersionsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<SolutionTemplateVersion> getWithResponse(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, Context context) {
        Response<SolutionTemplateVersionInner> inner = this.serviceClient()
            .getWithResponse(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new SolutionTemplateVersionImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public SolutionTemplateVersion get(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName) {
        SolutionTemplateVersionInner inner
            = this.serviceClient().get(resourceGroupName, solutionTemplateName, solutionTemplateVersionName);
        if (inner != null) {
            return new SolutionTemplateVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public PagedIterable<SolutionTemplateVersion> listBySolutionTemplate(String resourceGroupName,
        String solutionTemplateName) {
        PagedIterable<SolutionTemplateVersionInner> inner
            = this.serviceClient().listBySolutionTemplate(resourceGroupName, solutionTemplateName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionTemplateVersionImpl(inner1, this.manager()));
    }

    public PagedIterable<SolutionTemplateVersion> listBySolutionTemplate(String resourceGroupName,
        String solutionTemplateName, Context context) {
        PagedIterable<SolutionTemplateVersionInner> inner
            = this.serviceClient().listBySolutionTemplate(resourceGroupName, solutionTemplateName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionTemplateVersionImpl(inner1, this.manager()));
    }

    public void bulkDeploySolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkDeploySolutionParameter body) {
        this.serviceClient()
            .bulkDeploySolution(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body);
    }

    public void bulkDeploySolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkDeploySolutionParameter body, Context context) {
        this.serviceClient()
            .bulkDeploySolution(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body, context);
    }

    public void bulkPublishSolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkPublishSolutionParameter body) {
        this.serviceClient()
            .bulkPublishSolution(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body);
    }

    public void bulkPublishSolution(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, BulkPublishSolutionParameter body, Context context) {
        this.serviceClient()
            .bulkPublishSolution(resourceGroupName, solutionTemplateName, solutionTemplateVersionName, body, context);
    }

    private SolutionTemplateVersionsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionTemplateVersionWithUpdateTypeImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionWithUpdateType;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;

public final class SolutionTemplateVersionWithUpdateTypeImpl implements SolutionTemplateVersionWithUpdateType {
    private SolutionTemplateVersionWithUpdateTypeInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    SolutionTemplateVersionWithUpdateTypeImpl(SolutionTemplateVersionWithUpdateTypeInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
    }

    public UpdateType updateType() {
        return this.innerModel().updateType();
    }

    public String version() {
        return this.innerModel().version();
    }

    public SolutionTemplateVersion solutionTemplateVersion() {
        SolutionTemplateVersionInner inner = this.innerModel().solutionTemplateVersion();
        if (inner != null) {
            return new SolutionTemplateVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SolutionTemplateVersionWithUpdateTypeInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionVersionImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionProperties;

public final class SolutionVersionImpl implements SolutionVersion, SolutionVersion.Definition, SolutionVersion.Update {
    private SolutionVersionInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public SolutionVersionProperties properties() {
        return this.innerModel().properties();
    }

    public ExtendedLocation extendedLocation() {
        return this.innerModel().extendedLocation();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public SolutionVersionInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String targetName;

    private String solutionName;

    private String solutionVersionName;

    public SolutionVersionImpl withExistingSolution(String resourceGroupName, String targetName, String solutionName) {
        this.resourceGroupName = resourceGroupName;
        this.targetName = targetName;
        this.solutionName = solutionName;
        return this;
    }

    public SolutionVersion create() {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionVersions()
            .createOrUpdate(resourceGroupName, targetName, solutionName, solutionVersionName, this.innerModel(),
                Context.NONE);
        return this;
    }

    public SolutionVersion create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionVersions()
            .createOrUpdate(resourceGroupName, targetName, solutionName, solutionVersionName, this.innerModel(),
                context);
        return this;
    }

    SolutionVersionImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new SolutionVersionInner();
        this.serviceManager = serviceManager;
        this.solutionVersionName = name;
    }

    public SolutionVersionImpl update() {
        return this;
    }

    public SolutionVersion apply() {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionVersions()
            .update(resourceGroupName, targetName, solutionName, solutionVersionName, this.innerModel(), Context.NONE);
        return this;
    }

    public SolutionVersion apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionVersions()
            .update(resourceGroupName, targetName, solutionName, solutionVersionName, this.innerModel(), context);
        return this;
    }

    SolutionVersionImpl(SolutionVersionInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.targetName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "targets");
        this.solutionName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "solutions");
        this.solutionVersionName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "versions");
    }

    public SolutionVersion refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionVersions()
            .getWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, Context.NONE)
            .getValue();
        return this;
    }

    public SolutionVersion refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getSolutionVersions()
            .getWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, context)
            .getValue();
        return this;
    }

    public SolutionVersionImpl withProperties(SolutionVersionProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }

    public SolutionVersionImpl withExtendedLocation(ExtendedLocation extendedLocation) {
        this.innerModel().withExtendedLocation(extendedLocation);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionVersionsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionVersionListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in SolutionVersionsClient.
 */
public final class SolutionVersionsClientImpl implements SolutionVersionsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final SolutionVersionsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of SolutionVersionsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    SolutionVersionsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(SolutionVersionsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientSolutionVersions to be used by
     * the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientSolutionVersions")
    public interface SolutionVersionsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionVersionInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName,
            @PathParam("solutionVersionName") String solutionVersionName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionVersionInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName,
            @PathParam("solutionVersionName") String solutionVersionName, @HeaderParam("Accept") String accept,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName,
            @PathParam("solutionVersionName") String solutionVersionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionVersionInner resource, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName,
            @PathParam("solutionVersionName") String solutionVersionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionVersionInner resource, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName,
            @PathParam("solutionVersionName") String solutionVersionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionVersionInner properties, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName,
            @PathParam("solutionVersionName") String solutionVersionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionVersionInner properties, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName,
            @PathParam("solutionVersionName") String solutionVersionName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName,
            @PathParam("solutionVersionName") String solutionVersionName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionVersionListResult>> listBySolution(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionVersionListResult> listBySolutionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @PathParam("solutionName") String solutionName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<SolutionVersionListResult>> listBySolutionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<SolutionVersionListResult> listBySolutionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<SolutionVersionInner>> getWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName,
                accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionVersionInner> getAsync(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName) {
        return getWithResponseAsync(resourceGroupName, targetName, solutionName, solutionVersionName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<SolutionVersionInner> getWithResponse(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, targetName, solutionName, solutionVersionName, accept, context);
    }

    /**
     * Get a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner get(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName) {
        return getWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, Context.NONE)
            .getValue();
    }

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String targetName, String solutionName, String solutionVersionName, SolutionVersionInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName,
                contentType, accept, resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName, SolutionVersionInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName,
            contentType, accept, resource, Context.NONE);
    }

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName, SolutionVersionInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName,
            contentType, accept, resource, context);
    }

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SolutionVersionInner>, SolutionVersionInner> beginCreateOrUpdateAsync(
        String resourceGroupName, String targetName, String solutionName, String solutionVersionName,
        SolutionVersionInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono = createOrUpdateWithResponseAsync(resourceGroupName, targetName,
            solutionName, solutionVersionName, resource);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(mono, this.client.getHttpPipeline(),
            SolutionVersionInner.class, SolutionVersionInner.class, this.client.getContext());
    }

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginCreateOrUpdate(
        String resourceGroupName, String targetName, String solutionName, String solutionVersionName,
        SolutionVersionInner resource) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, resource);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, Context.NONE);
    }

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginCreateOrUpdate(
        String resourceGroupName, String targetName, String solutionName, String solutionVersionName,
        SolutionVersionInner resource, Context context) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, targetName, solutionName,
            solutionVersionName, resource, context);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, context);
    }

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionVersionInner> createOrUpdateAsync(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName, SolutionVersionInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, targetName, solutionName, solutionVersionName, resource)
            .last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner resource) {
        return beginCreateOrUpdate(resourceGroupName, targetName, solutionName, solutionVersionName, resource)
            .getFinalResult();
    }

    /**
     * Create or update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner createOrUpdate(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, targetName, solutionName, solutionVersionName, resource, context)
            .getFinalResult();
    }

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName, SolutionVersionInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName,
                contentType, accept, properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName,
            contentType, accept, properties, Context.NONE);
    }

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName,
            contentType, accept, properties, context);
    }

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdateAsync(
        String resourceGroupName, String targetName, String solutionName, String solutionVersionName,
        SolutionVersionInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = updateWithResponseAsync(resourceGroupName, targetName, solutionName, solutionVersionName, properties);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(mono, this.client.getHttpPipeline(),
            SolutionVersionInner.class, SolutionVersionInner.class, this.client.getContext());
    }

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdate(String resourceGroupName,
        String targetName, String solutionName, String solutionVersionName, SolutionVersionInner properties) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, properties);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, Context.NONE);
    }

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdate(String resourceGroupName,
        String targetName, String solutionName, String solutionVersionName, SolutionVersionInner properties,
        Context context) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, properties, context);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, context);
    }

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionVersionInner> updateAsync(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner properties) {
        return beginUpdateAsync(resourceGroupName, targetName, solutionName, solutionVersionName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner update(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner properties) {
        return beginUpdate(resourceGroupName, targetName, solutionName, solutionVersionName, properties)
            .getFinalResult();
    }

    /**
     * Update a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return solution Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner update(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, SolutionVersionInner properties, Context context) {
        return beginUpdate(resourceGroupName, targetName, solutionName, solutionVersionName, properties, context)
            .getFinalResult();
    }

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        return FluxUtil.withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName,
            Context.NONE);
    }

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        if (solutionVersionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionVersionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, solutionVersionName, context);
    }

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = deleteWithResponseAsync(resourceGroupName, targetName, solutionName, solutionVersionName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName) {
        Response<BinaryData> response
            = deleteWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName,
        String solutionName, String solutionVersionName, Context context) {
        Response<BinaryData> response
            = deleteWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName) {
        return beginDeleteAsync(resourceGroupName, targetName, solutionName, solutionVersionName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String targetName, String solutionName, String solutionVersionName) {
        beginDelete(resourceGroupName, targetName, solutionName, solutionVersionName).getFinalResult();
    }

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String targetName, String solutionName, String solutionVersionName,
        Context context) {
        beginDelete(resourceGroupName, targetName, solutionName, solutionVersionName, context).getFinalResult();
    }

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionVersionInner>> listBySolutionSinglePageAsync(String resourceGroupName,
        String targetName, String solutionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listBySolution(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, accept, context))
            .<PagedResponse<SolutionVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<SolutionVersionInner> listBySolutionAsync(String resourceGroupName, String targetName,
        String solutionName) {
        return new PagedFlux<>(() -> listBySolutionSinglePageAsync(resourceGroupName, targetName, solutionName),
            nextLink -> listBySolutionNextSinglePageAsync(nextLink));
    }

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionVersionInner> listBySolutionSinglePage(String resourceGroupName, String targetName,
        String solutionName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionVersionListResult> res
            = service.listBySolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionVersionInner> listBySolutionSinglePage(String resourceGroupName, String targetName,
        String solutionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (solutionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter solutionName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionVersionListResult> res
            = service.listBySolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, solutionName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionVersionInner> listBySolution(String resourceGroupName, String targetName,
        String solutionName) {
        return new PagedIterable<>(() -> listBySolutionSinglePage(resourceGroupName, targetName, solutionName),
            nextLink -> listBySolutionNextSinglePage(nextLink));
    }

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<SolutionVersionInner> listBySolution(String resourceGroupName, String targetName,
        String solutionName, Context context) {
        return new PagedIterable<>(() -> listBySolutionSinglePage(resourceGroupName, targetName, solutionName, context),
            nextLink -> listBySolutionNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<SolutionVersionInner>> listBySolutionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listBySolutionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<SolutionVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionVersionInner> listBySolutionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionVersionListResult> res
            = service.listBySolutionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<SolutionVersionInner> listBySolutionNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<SolutionVersionListResult> res
            = service.listBySolutionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionVersionsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/SolutionVersionsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersions;

public final class SolutionVersionsImpl implements SolutionVersions {
    private static final ClientLogger LOGGER = new ClientLogger(SolutionVersionsImpl.class);

    private final SolutionVersionsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public SolutionVersionsImpl(SolutionVersionsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<SolutionVersion> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, Context context) {
        Response<SolutionVersionInner> inner = this.serviceClient()
            .getWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new SolutionVersionImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public SolutionVersion get(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName) {
        SolutionVersionInner inner
            = this.serviceClient().get(resourceGroupName, targetName, solutionName, solutionVersionName);
        if (inner != null) {
            return new SolutionVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String targetName, String solutionName, String solutionVersionName) {
        this.serviceClient().delete(resourceGroupName, targetName, solutionName, solutionVersionName);
    }

    public void delete(String resourceGroupName, String targetName, String solutionName, String solutionVersionName,
        Context context) {
        this.serviceClient().delete(resourceGroupName, targetName, solutionName, solutionVersionName, context);
    }

    public PagedIterable<SolutionVersion> listBySolution(String resourceGroupName, String targetName,
        String solutionName) {
        PagedIterable<SolutionVersionInner> inner
            = this.serviceClient().listBySolution(resourceGroupName, targetName, solutionName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionVersionImpl(inner1, this.manager()));
    }

    public PagedIterable<SolutionVersion> listBySolution(String resourceGroupName, String targetName,
        String solutionName, Context context) {
        PagedIterable<SolutionVersionInner> inner
            = this.serviceClient().listBySolution(resourceGroupName, targetName, solutionName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new SolutionVersionImpl(inner1, this.manager()));
    }

    public SolutionVersion getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        String solutionVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (solutionVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, Context.NONE)
            .getValue();
    }

    public Response<SolutionVersion> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        String solutionVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (solutionVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, targetName, solutionName, solutionVersionName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        String solutionVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (solutionVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        this.delete(resourceGroupName, targetName, solutionName, solutionVersionName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        String solutionName = ResourceManagerUtils.getValueFromIdByName(id, "solutions");
        if (solutionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'solutions'.", id)));
        }
        String solutionVersionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (solutionVersionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        this.delete(resourceGroupName, targetName, solutionName, solutionVersionName, context);
    }

    private SolutionVersionsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public SolutionVersionImpl define(String name) {
        return new SolutionVersionImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/TargetImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.InstallSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.RemoveRevisionParameter;
import com.azure.resourcemanager.workloadorchestration.models.ResolvedConfiguration;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionParameter;
import com.azure.resourcemanager.workloadorchestration.models.Target;
import com.azure.resourcemanager.workloadorchestration.models.TargetProperties;
import com.azure.resourcemanager.workloadorchestration.models.UninstallSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.UpdateExternalValidationStatusParameter;
import java.util.Collections;
import java.util.Map;

public final class TargetImpl implements Target, Target.Definition, Target.Update {
    private TargetInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public String location() {
        return this.innerModel().location();
    }

    public Map<String, String> tags() {
        Map<String, String> inner = this.innerModel().tags();
        if (inner != null) {
            return Collections.unmodifiableMap(inner);
        } else {
            return Collections.emptyMap();
        }
    }

    public TargetProperties properties() {
        return this.innerModel().properties();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public ExtendedLocation extendedLocation() {
        return this.innerModel().extendedLocation();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public Region region() {
        return Region.fromName(this.regionName());
    }

    public String regionName() {
        return this.location();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public TargetInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String targetName;

    public TargetImpl withExistingResourceGroup(String resourceGroupName) {
        this.resourceGroupName = resourceGroupName;
        return this;
    }

    public Target create() {
        this.innerObject = serviceManager.serviceClient()
            .getTargets()
            .createOrUpdate(resourceGroupName, targetName, this.innerModel(), Context.NONE);
        return this;
    }

    public Target create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getTargets()
            .createOrUpdate(resourceGroupName, targetName, this.innerModel(), context);
        return this;
    }

    TargetImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new TargetInner();
        this.serviceManager = serviceManager;
        this.targetName = name;
    }

    public TargetImpl update() {
        return this;
    }

    public Target apply() {
        this.innerObject = serviceManager.serviceClient()
            .getTargets()
            .update(resourceGroupName, targetName, this.innerModel(), Context.NONE);
        return this;
    }

    public Target apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getTargets()
            .update(resourceGroupName, targetName, this.innerModel(), context);
        return this;
    }

    TargetImpl(TargetInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.targetName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "targets");
    }

    public Target refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getTargets()
            .getByResourceGroupWithResponse(resourceGroupName, targetName, Context.NONE)
            .getValue();
        return this;
    }

    public Target refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getTargets()
            .getByResourceGroupWithResponse(resourceGroupName, targetName, context)
            .getValue();
        return this;
    }

    public void installSolution(InstallSolutionParameter body) {
        serviceManager.targets().installSolution(resourceGroupName, targetName, body);
    }

    public void installSolution(InstallSolutionParameter body, Context context) {
        serviceManager.targets().installSolution(resourceGroupName, targetName, body, context);
    }

    public void uninstallSolution(UninstallSolutionParameter body) {
        serviceManager.targets().uninstallSolution(resourceGroupName, targetName, body);
    }

    public void uninstallSolution(UninstallSolutionParameter body, Context context) {
        serviceManager.targets().uninstallSolution(resourceGroupName, targetName, body, context);
    }

    public void removeRevision(RemoveRevisionParameter body) {
        serviceManager.targets().removeRevision(resourceGroupName, targetName, body);
    }

    public void removeRevision(RemoveRevisionParameter body, Context context) {
        serviceManager.targets().removeRevision(resourceGroupName, targetName, body, context);
    }

    public ResolvedConfiguration resolveConfiguration(SolutionTemplateParameter body) {
        return serviceManager.targets().resolveConfiguration(resourceGroupName, targetName, body);
    }

    public ResolvedConfiguration resolveConfiguration(SolutionTemplateParameter body, Context context) {
        return serviceManager.targets().resolveConfiguration(resourceGroupName, targetName, body, context);
    }

    public SolutionVersion reviewSolutionVersion(SolutionTemplateParameter body) {
        return serviceManager.targets().reviewSolutionVersion(resourceGroupName, targetName, body);
    }

    public SolutionVersion reviewSolutionVersion(SolutionTemplateParameter body, Context context) {
        return serviceManager.targets().reviewSolutionVersion(resourceGroupName, targetName, body, context);
    }

    public SolutionVersion publishSolutionVersion(SolutionVersionParameter body) {
        return serviceManager.targets().publishSolutionVersion(resourceGroupName, targetName, body);
    }

    public SolutionVersion publishSolutionVersion(SolutionVersionParameter body, Context context) {
        return serviceManager.targets().publishSolutionVersion(resourceGroupName, targetName, body, context);
    }

    public SolutionVersion updateExternalValidationStatus(UpdateExternalValidationStatusParameter body) {
        return serviceManager.targets().updateExternalValidationStatus(resourceGroupName, targetName, body);
    }

    public SolutionVersion updateExternalValidationStatus(UpdateExternalValidationStatusParameter body,
        Context context) {
        return serviceManager.targets().updateExternalValidationStatus(resourceGroupName, targetName, body, context);
    }

    public TargetImpl withRegion(Region location) {
        this.innerModel().withLocation(location.toString());
        return this;
    }

    public TargetImpl withRegion(String location) {
        this.innerModel().withLocation(location);
        return this;
    }

    public TargetImpl withTags(Map<String, String> tags) {
        this.innerModel().withTags(tags);
        return this;
    }

    public TargetImpl withProperties(TargetProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }

    public TargetImpl withExtendedLocation(ExtendedLocation extendedLocation) {
        this.innerModel().withExtendedLocation(extendedLocation);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/TargetsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ResolvedConfigurationInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.TargetListResult;
import com.azure.resourcemanager.workloadorchestration.models.InstallSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.RemoveRevisionParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionParameter;
import com.azure.resourcemanager.workloadorchestration.models.UninstallSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.UpdateExternalValidationStatusParameter;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in TargetsClient.
 */
public final class TargetsClientImpl implements TargetsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final TargetsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of TargetsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    TargetsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service = RestProxy.create(TargetsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientTargets to be used by the proxy
     * service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientTargets")
    public interface TargetsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<TargetInner>> getByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<TargetInner> getByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") TargetInner resource, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") TargetInner resource, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") TargetInner properties, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") TargetInner properties, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @QueryParam("forceDelete") Boolean forceDelete,
            @PathParam("targetName") String targetName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @QueryParam("forceDelete") Boolean forceDelete,
            @PathParam("targetName") String targetName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<TargetListResult>> listByResourceGroup(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<TargetListResult> listByResourceGroupSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @HeaderParam("Accept") String accept,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/targets")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<TargetListResult>> list(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Edge/targets")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<TargetListResult> listSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/installSolution")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> installSolution(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") InstallSolutionParameter body, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/installSolution")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> installSolutionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") InstallSolutionParameter body, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/uninstallSolution")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> uninstallSolution(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") UninstallSolutionParameter body, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/uninstallSolution")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> uninstallSolutionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") UninstallSolutionParameter body, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/removeRevision")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> removeRevision(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") RemoveRevisionParameter body, Context context);

        @Headers({ "Accept: application/json;q=0.9" })
        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/removeRevision")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> removeRevisionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType,
            @BodyParam("application/json") RemoveRevisionParameter body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/resolveConfiguration")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> resolveConfiguration(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateParameter body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/resolveConfiguration")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> resolveConfigurationSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateParameter body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/reviewSolutionVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> reviewSolutionVersion(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateParameter body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/reviewSolutionVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> reviewSolutionVersionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionTemplateParameter body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/publishSolutionVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> publishSolutionVersion(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionVersionParameter body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/publishSolutionVersion")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> publishSolutionVersionSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") SolutionVersionParameter body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/updateExternalValidationStatus")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> updateExternalValidationStatus(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") UpdateExternalValidationStatusParameter body, Context context);

        @Post("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/updateExternalValidationStatus")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateExternalValidationStatusSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("targetName") String targetName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") UpdateExternalValidationStatusParameter body, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<TargetListResult>> listByResourceGroupNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<TargetListResult> listByResourceGroupNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<TargetListResult>> listBySubscriptionNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<TargetListResult> listBySubscriptionNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<TargetInner>> getByResourceGroupWithResponseAsync(String resourceGroupName,
        String targetName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.getByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<TargetInner> getByResourceGroupAsync(String resourceGroupName, String targetName) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, targetName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<TargetInner> getByResourceGroupWithResponse(String resourceGroupName, String targetName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getByResourceGroupSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, accept, context);
    }

    /**
     * Get a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TargetInner getByResourceGroup(String resourceGroupName, String targetName) {
        return getByResourceGroupWithResponse(resourceGroupName, targetName, Context.NONE).getValue();
    }

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String targetName, TargetInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String targetName,
        TargetInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, resource,
            Context.NONE);
    }

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String targetName,
        TargetInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, resource, context);
    }

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<TargetInner>, TargetInner> beginCreateOrUpdateAsync(String resourceGroupName,
        String targetName, TargetInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, targetName, resource);
        return this.client.<TargetInner, TargetInner>getLroResult(mono, this.client.getHttpPipeline(),
            TargetInner.class, TargetInner.class, this.client.getContext());
    }

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<TargetInner>, TargetInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, TargetInner resource) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, targetName, resource);
        return this.client.<TargetInner, TargetInner>getLroResult(response, TargetInner.class, TargetInner.class,
            Context.NONE);
    }

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<TargetInner>, TargetInner> beginCreateOrUpdate(String resourceGroupName,
        String targetName, TargetInner resource, Context context) {
        Response<BinaryData> response = createOrUpdateWithResponse(resourceGroupName, targetName, resource, context);
        return this.client.<TargetInner, TargetInner>getLroResult(response, TargetInner.class, TargetInner.class,
            context);
    }

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<TargetInner> createOrUpdateAsync(String resourceGroupName, String targetName, TargetInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, targetName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TargetInner createOrUpdate(String resourceGroupName, String targetName, TargetInner resource) {
        return beginCreateOrUpdate(resourceGroupName, targetName, resource).getFinalResult();
    }

    /**
     * Create or update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TargetInner createOrUpdate(String resourceGroupName, String targetName, TargetInner resource,
        Context context) {
        return beginCreateOrUpdate(resourceGroupName, targetName, resource, context).getFinalResult();
    }

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String targetName,
        TargetInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String targetName,
        TargetInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, properties,
            Context.NONE);
    }

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String targetName, TargetInner properties,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, properties, context);
    }

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<TargetInner>, TargetInner> beginUpdateAsync(String resourceGroupName,
        String targetName, TargetInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono = updateWithResponseAsync(resourceGroupName, targetName, properties);
        return this.client.<TargetInner, TargetInner>getLroResult(mono, this.client.getHttpPipeline(),
            TargetInner.class, TargetInner.class, this.client.getContext());
    }

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<TargetInner>, TargetInner> beginUpdate(String resourceGroupName, String targetName,
        TargetInner properties) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, targetName, properties);
        return this.client.<TargetInner, TargetInner>getLroResult(response, TargetInner.class, TargetInner.class,
            Context.NONE);
    }

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of target Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<TargetInner>, TargetInner> beginUpdate(String resourceGroupName, String targetName,
        TargetInner properties, Context context) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, targetName, properties, context);
        return this.client.<TargetInner, TargetInner>getLroResult(response, TargetInner.class, TargetInner.class,
            context);
    }

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<TargetInner> updateAsync(String resourceGroupName, String targetName, TargetInner properties) {
        return beginUpdateAsync(resourceGroupName, targetName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TargetInner update(String resourceGroupName, String targetName, TargetInner properties) {
        return beginUpdate(resourceGroupName, targetName, properties).getFinalResult();
    }

    /**
     * update a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return target Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TargetInner update(String resourceGroupName, String targetName, TargetInner properties, Context context) {
        return beginUpdate(resourceGroupName, targetName, properties, context).getFinalResult();
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String targetName,
        Boolean forceDelete) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, forceDelete, targetName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String targetName, Boolean forceDelete) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, forceDelete, targetName, Context.NONE);
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String targetName, Boolean forceDelete,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, forceDelete, targetName, context);
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String targetName,
        Boolean forceDelete) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, targetName, forceDelete);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String targetName) {
        final Boolean forceDelete = null;
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, targetName, forceDelete);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName,
        Boolean forceDelete) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, targetName, forceDelete);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName) {
        final Boolean forceDelete = null;
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, targetName, forceDelete);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String targetName,
        Boolean forceDelete, Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, targetName, forceDelete, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String targetName, Boolean forceDelete) {
        return beginDeleteAsync(resourceGroupName, targetName, forceDelete).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String targetName) {
        final Boolean forceDelete = null;
        return beginDeleteAsync(resourceGroupName, targetName, forceDelete).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String targetName) {
        final Boolean forceDelete = null;
        beginDelete(resourceGroupName, targetName, forceDelete).getFinalResult();
    }

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String targetName, Boolean forceDelete, Context context) {
        beginDelete(resourceGroupName, targetName, forceDelete, context).getFinalResult();
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<TargetInner>> listByResourceGroupSinglePageAsync(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByResourceGroup(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, accept, context))
            .<PagedResponse<TargetInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<TargetInner> listByResourceGroupAsync(String resourceGroupName) {
        return new PagedFlux<>(() -> listByResourceGroupSinglePageAsync(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<TargetInner> listByResourceGroupSinglePage(String resourceGroupName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<TargetListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<TargetInner> listByResourceGroupSinglePage(String resourceGroupName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<TargetListResult> res = service.listByResourceGroupSync(this.client.getEndpoint(),
            this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<TargetInner> listByResourceGroup(String resourceGroupName) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName),
            nextLink -> listByResourceGroupNextSinglePage(nextLink));
    }

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<TargetInner> listByResourceGroup(String resourceGroupName, Context context) {
        return new PagedIterable<>(() -> listByResourceGroupSinglePage(resourceGroupName, context),
            nextLink -> listByResourceGroupNextSinglePage(nextLink, context));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<TargetInner>> listSinglePageAsync() {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.list(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), accept, context))
            .<PagedResponse<TargetInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<TargetInner> listAsync() {
        return new PagedFlux<>(() -> listSinglePageAsync(),
            nextLink -> listBySubscriptionNextSinglePageAsync(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<TargetInner> listSinglePage() {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<TargetListResult> res = service.listSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<TargetInner> listSinglePage(Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<TargetListResult> res = service.listSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List by subscription.
     * 
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<TargetInner> list() {
        return new PagedIterable<>(() -> listSinglePage(), nextLink -> listBySubscriptionNextSinglePage(nextLink));
    }

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<TargetInner> list(Context context) {
        return new PagedIterable<>(() -> listSinglePage(context),
            nextLink -> listBySubscriptionNextSinglePage(nextLink, context));
    }

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> installSolutionWithResponseAsync(String resourceGroupName,
        String targetName, InstallSolutionParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return FluxUtil
            .withContext(context -> service.installSolution(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> installSolutionWithResponse(String resourceGroupName, String targetName,
        InstallSolutionParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.installSolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, body, Context.NONE);
    }

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> installSolutionWithResponse(String resourceGroupName, String targetName,
        InstallSolutionParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.installSolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, body, context);
    }

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginInstallSolutionAsync(String resourceGroupName, String targetName,
        InstallSolutionParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono = installSolutionWithResponseAsync(resourceGroupName, targetName, body);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginInstallSolution(String resourceGroupName, String targetName,
        InstallSolutionParameter body) {
        Response<BinaryData> response = installSolutionWithResponse(resourceGroupName, targetName, body);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginInstallSolution(String resourceGroupName, String targetName,
        InstallSolutionParameter body, Context context) {
        Response<BinaryData> response = installSolutionWithResponse(resourceGroupName, targetName, body, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> installSolutionAsync(String resourceGroupName, String targetName,
        InstallSolutionParameter body) {
        return beginInstallSolutionAsync(resourceGroupName, targetName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void installSolution(String resourceGroupName, String targetName, InstallSolutionParameter body) {
        beginInstallSolution(resourceGroupName, targetName, body).getFinalResult();
    }

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void installSolution(String resourceGroupName, String targetName, InstallSolutionParameter body,
        Context context) {
        beginInstallSolution(resourceGroupName, targetName, body, context).getFinalResult();
    }

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> uninstallSolutionWithResponseAsync(String resourceGroupName,
        String targetName, UninstallSolutionParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return FluxUtil
            .withContext(context -> service.uninstallSolution(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> uninstallSolutionWithResponse(String resourceGroupName, String targetName,
        UninstallSolutionParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.uninstallSolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, body, Context.NONE);
    }

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> uninstallSolutionWithResponse(String resourceGroupName, String targetName,
        UninstallSolutionParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.uninstallSolutionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, body, context);
    }

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginUninstallSolutionAsync(String resourceGroupName, String targetName,
        UninstallSolutionParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono = uninstallSolutionWithResponseAsync(resourceGroupName, targetName, body);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginUninstallSolution(String resourceGroupName, String targetName,
        UninstallSolutionParameter body) {
        Response<BinaryData> response = uninstallSolutionWithResponse(resourceGroupName, targetName, body);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginUninstallSolution(String resourceGroupName, String targetName,
        UninstallSolutionParameter body, Context context) {
        Response<BinaryData> response = uninstallSolutionWithResponse(resourceGroupName, targetName, body, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> uninstallSolutionAsync(String resourceGroupName, String targetName,
        UninstallSolutionParameter body) {
        return beginUninstallSolutionAsync(resourceGroupName, targetName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void uninstallSolution(String resourceGroupName, String targetName, UninstallSolutionParameter body) {
        beginUninstallSolution(resourceGroupName, targetName, body).getFinalResult();
    }

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void uninstallSolution(String resourceGroupName, String targetName, UninstallSolutionParameter body,
        Context context) {
        beginUninstallSolution(resourceGroupName, targetName, body, context).getFinalResult();
    }

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> removeRevisionWithResponseAsync(String resourceGroupName,
        String targetName, RemoveRevisionParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return FluxUtil
            .withContext(context -> service.removeRevision(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> removeRevisionWithResponse(String resourceGroupName, String targetName,
        RemoveRevisionParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.removeRevisionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, body, Context.NONE);
    }

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> removeRevisionWithResponse(String resourceGroupName, String targetName,
        RemoveRevisionParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        return service.removeRevisionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, body, context);
    }

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginRemoveRevisionAsync(String resourceGroupName, String targetName,
        RemoveRevisionParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono = removeRevisionWithResponseAsync(resourceGroupName, targetName, body);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginRemoveRevision(String resourceGroupName, String targetName,
        RemoveRevisionParameter body) {
        Response<BinaryData> response = removeRevisionWithResponse(resourceGroupName, targetName, body);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginRemoveRevision(String resourceGroupName, String targetName,
        RemoveRevisionParameter body, Context context) {
        Response<BinaryData> response = removeRevisionWithResponse(resourceGroupName, targetName, body, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> removeRevisionAsync(String resourceGroupName, String targetName, RemoveRevisionParameter body) {
        return beginRemoveRevisionAsync(resourceGroupName, targetName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void removeRevision(String resourceGroupName, String targetName, RemoveRevisionParameter body) {
        beginRemoveRevision(resourceGroupName, targetName, body).getFinalResult();
    }

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void removeRevision(String resourceGroupName, String targetName, RemoveRevisionParameter body,
        Context context) {
        beginRemoveRevision(resourceGroupName, targetName, body, context).getFinalResult();
    }

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> resolveConfigurationWithResponseAsync(String resourceGroupName,
        String targetName, SolutionTemplateParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.resolveConfiguration(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> resolveConfigurationWithResponse(String resourceGroupName, String targetName,
        SolutionTemplateParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.resolveConfigurationSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, Context.NONE);
    }

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> resolveConfigurationWithResponse(String resourceGroupName, String targetName,
        SolutionTemplateParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.resolveConfigurationSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, context);
    }

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<ResolvedConfigurationInner>, ResolvedConfigurationInner>
        beginResolveConfigurationAsync(String resourceGroupName, String targetName, SolutionTemplateParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = resolveConfigurationWithResponseAsync(resourceGroupName, targetName, body);
        return this.client.<ResolvedConfigurationInner, ResolvedConfigurationInner>getLroResult(mono,
            this.client.getHttpPipeline(), ResolvedConfigurationInner.class, ResolvedConfigurationInner.class,
            this.client.getContext());
    }

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ResolvedConfigurationInner>, ResolvedConfigurationInner>
        beginResolveConfiguration(String resourceGroupName, String targetName, SolutionTemplateParameter body) {
        Response<BinaryData> response = resolveConfigurationWithResponse(resourceGroupName, targetName, body);
        return this.client.<ResolvedConfigurationInner, ResolvedConfigurationInner>getLroResult(response,
            ResolvedConfigurationInner.class, ResolvedConfigurationInner.class, Context.NONE);
    }

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<ResolvedConfigurationInner>, ResolvedConfigurationInner> beginResolveConfiguration(
        String resourceGroupName, String targetName, SolutionTemplateParameter body, Context context) {
        Response<BinaryData> response = resolveConfigurationWithResponse(resourceGroupName, targetName, body, context);
        return this.client.<ResolvedConfigurationInner, ResolvedConfigurationInner>getLroResult(response,
            ResolvedConfigurationInner.class, ResolvedConfigurationInner.class, context);
    }

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<ResolvedConfigurationInner> resolveConfigurationAsync(String resourceGroupName, String targetName,
        SolutionTemplateParameter body) {
        return beginResolveConfigurationAsync(resourceGroupName, targetName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResolvedConfigurationInner resolveConfiguration(String resourceGroupName, String targetName,
        SolutionTemplateParameter body) {
        return beginResolveConfiguration(resourceGroupName, targetName, body).getFinalResult();
    }

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public ResolvedConfigurationInner resolveConfiguration(String resourceGroupName, String targetName,
        SolutionTemplateParameter body, Context context) {
        return beginResolveConfiguration(resourceGroupName, targetName, body, context).getFinalResult();
    }

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> reviewSolutionVersionWithResponseAsync(String resourceGroupName,
        String targetName, SolutionTemplateParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.reviewSolutionVersion(this.client.getEndpoint(), this.client.getApiVersion(),
                    this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> reviewSolutionVersionWithResponse(String resourceGroupName, String targetName,
        SolutionTemplateParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.reviewSolutionVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, Context.NONE);
    }

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> reviewSolutionVersionWithResponse(String resourceGroupName, String targetName,
        SolutionTemplateParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.reviewSolutionVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, context);
    }

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SolutionVersionInner>, SolutionVersionInner>
        beginReviewSolutionVersionAsync(String resourceGroupName, String targetName, SolutionTemplateParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = reviewSolutionVersionWithResponseAsync(resourceGroupName, targetName, body);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(mono, this.client.getHttpPipeline(),
            SolutionVersionInner.class, SolutionVersionInner.class, this.client.getContext());
    }

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner>
        beginReviewSolutionVersion(String resourceGroupName, String targetName, SolutionTemplateParameter body) {
        Response<BinaryData> response = reviewSolutionVersionWithResponse(resourceGroupName, targetName, body);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, Context.NONE);
    }

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginReviewSolutionVersion(
        String resourceGroupName, String targetName, SolutionTemplateParameter body, Context context) {
        Response<BinaryData> response = reviewSolutionVersionWithResponse(resourceGroupName, targetName, body, context);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, context);
    }

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionVersionInner> reviewSolutionVersionAsync(String resourceGroupName, String targetName,
        SolutionTemplateParameter body) {
        return beginReviewSolutionVersionAsync(resourceGroupName, targetName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner reviewSolutionVersion(String resourceGroupName, String targetName,
        SolutionTemplateParameter body) {
        return beginReviewSolutionVersion(resourceGroupName, targetName, body).getFinalResult();
    }

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner reviewSolutionVersion(String resourceGroupName, String targetName,
        SolutionTemplateParameter body, Context context) {
        return beginReviewSolutionVersion(resourceGroupName, targetName, body, context).getFinalResult();
    }

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> publishSolutionVersionWithResponseAsync(String resourceGroupName,
        String targetName, SolutionVersionParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.publishSolutionVersion(this.client.getEndpoint(), this.client.getApiVersion(),
                    this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> publishSolutionVersionWithResponse(String resourceGroupName, String targetName,
        SolutionVersionParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.publishSolutionVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, Context.NONE);
    }

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> publishSolutionVersionWithResponse(String resourceGroupName, String targetName,
        SolutionVersionParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.publishSolutionVersionSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, context);
    }

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SolutionVersionInner>, SolutionVersionInner>
        beginPublishSolutionVersionAsync(String resourceGroupName, String targetName, SolutionVersionParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = publishSolutionVersionWithResponseAsync(resourceGroupName, targetName, body);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(mono, this.client.getHttpPipeline(),
            SolutionVersionInner.class, SolutionVersionInner.class, this.client.getContext());
    }

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner>
        beginPublishSolutionVersion(String resourceGroupName, String targetName, SolutionVersionParameter body) {
        Response<BinaryData> response = publishSolutionVersionWithResponse(resourceGroupName, targetName, body);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, Context.NONE);
    }

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginPublishSolutionVersion(
        String resourceGroupName, String targetName, SolutionVersionParameter body, Context context) {
        Response<BinaryData> response
            = publishSolutionVersionWithResponse(resourceGroupName, targetName, body, context);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, context);
    }

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionVersionInner> publishSolutionVersionAsync(String resourceGroupName, String targetName,
        SolutionVersionParameter body) {
        return beginPublishSolutionVersionAsync(resourceGroupName, targetName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner publishSolutionVersion(String resourceGroupName, String targetName,
        SolutionVersionParameter body) {
        return beginPublishSolutionVersion(resourceGroupName, targetName, body).getFinalResult();
    }

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner publishSolutionVersion(String resourceGroupName, String targetName,
        SolutionVersionParameter body, Context context) {
        return beginPublishSolutionVersion(resourceGroupName, targetName, body, context).getFinalResult();
    }

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateExternalValidationStatusWithResponseAsync(String resourceGroupName,
        String targetName, UpdateExternalValidationStatusParameter body) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            return Mono.error(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            return Mono.error(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.updateExternalValidationStatus(this.client.getEndpoint(),
                this.client.getApiVersion(), this.client.getSubscriptionId(), resourceGroupName, targetName,
                contentType, accept, body, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateExternalValidationStatusWithResponse(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateExternalValidationStatusSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, Context.NONE);
    }

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateExternalValidationStatusWithResponse(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (targetName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter targetName is required and cannot be null."));
        }
        if (body == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Parameter body is required and cannot be null."));
        } else {
            body.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateExternalValidationStatusSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, targetName, contentType, accept, body, context);
    }

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdateExternalValidationStatusAsync(
        String resourceGroupName, String targetName, UpdateExternalValidationStatusParameter body) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = updateExternalValidationStatusWithResponseAsync(resourceGroupName, targetName, body);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(mono, this.client.getHttpPipeline(),
            SolutionVersionInner.class, SolutionVersionInner.class, this.client.getContext());
    }

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdateExternalValidationStatus(
        String resourceGroupName, String targetName, UpdateExternalValidationStatusParameter body) {
        Response<BinaryData> response = updateExternalValidationStatusWithResponse(resourceGroupName, targetName, body);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, Context.NONE);
    }

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<SolutionVersionInner>, SolutionVersionInner> beginUpdateExternalValidationStatus(
        String resourceGroupName, String targetName, UpdateExternalValidationStatusParameter body, Context context) {
        Response<BinaryData> response
            = updateExternalValidationStatusWithResponse(resourceGroupName, targetName, body, context);
        return this.client.<SolutionVersionInner, SolutionVersionInner>getLroResult(response,
            SolutionVersionInner.class, SolutionVersionInner.class, context);
    }

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<SolutionVersionInner> updateExternalValidationStatusAsync(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body) {
        return beginUpdateExternalValidationStatusAsync(resourceGroupName, targetName, body).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner updateExternalValidationStatus(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body) {
        return beginUpdateExternalValidationStatus(resourceGroupName, targetName, body).getFinalResult();
    }

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public SolutionVersionInner updateExternalValidationStatus(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body, Context context) {
        return beginUpdateExternalValidationStatus(resourceGroupName, targetName, body, context).getFinalResult();
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<TargetInner>> listByResourceGroupNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listByResourceGroupNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<TargetInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<TargetInner> listByResourceGroupNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<TargetListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<TargetInner> listByResourceGroupNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<TargetListResult> res
            = service.listByResourceGroupNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<TargetInner>> listBySubscriptionNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(
                context -> service.listBySubscriptionNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<TargetInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<TargetInner> listBySubscriptionNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<TargetListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<TargetInner> listBySubscriptionNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<TargetListResult> res
            = service.listBySubscriptionNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(TargetsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/TargetsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ResolvedConfigurationInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner;
import com.azure.resourcemanager.workloadorchestration.models.InstallSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.RemoveRevisionParameter;
import com.azure.resourcemanager.workloadorchestration.models.ResolvedConfiguration;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionParameter;
import com.azure.resourcemanager.workloadorchestration.models.Target;
import com.azure.resourcemanager.workloadorchestration.models.Targets;
import com.azure.resourcemanager.workloadorchestration.models.UninstallSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.UpdateExternalValidationStatusParameter;

public final class TargetsImpl implements Targets {
    private static final ClientLogger LOGGER = new ClientLogger(TargetsImpl.class);

    private final TargetsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public TargetsImpl(TargetsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<Target> getByResourceGroupWithResponse(String resourceGroupName, String targetName,
        Context context) {
        Response<TargetInner> inner
            = this.serviceClient().getByResourceGroupWithResponse(resourceGroupName, targetName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new TargetImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public Target getByResourceGroup(String resourceGroupName, String targetName) {
        TargetInner inner = this.serviceClient().getByResourceGroup(resourceGroupName, targetName);
        if (inner != null) {
            return new TargetImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String targetName) {
        this.serviceClient().delete(resourceGroupName, targetName);
    }

    public void delete(String resourceGroupName, String targetName, Boolean forceDelete, Context context) {
        this.serviceClient().delete(resourceGroupName, targetName, forceDelete, context);
    }

    public PagedIterable<Target> listByResourceGroup(String resourceGroupName) {
        PagedIterable<TargetInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new TargetImpl(inner1, this.manager()));
    }

    public PagedIterable<Target> listByResourceGroup(String resourceGroupName, Context context) {
        PagedIterable<TargetInner> inner = this.serviceClient().listByResourceGroup(resourceGroupName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new TargetImpl(inner1, this.manager()));
    }

    public PagedIterable<Target> list() {
        PagedIterable<TargetInner> inner = this.serviceClient().list();
        return ResourceManagerUtils.mapPage(inner, inner1 -> new TargetImpl(inner1, this.manager()));
    }

    public PagedIterable<Target> list(Context context) {
        PagedIterable<TargetInner> inner = this.serviceClient().list(context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new TargetImpl(inner1, this.manager()));
    }

    public void installSolution(String resourceGroupName, String targetName, InstallSolutionParameter body) {
        this.serviceClient().installSolution(resourceGroupName, targetName, body);
    }

    public void installSolution(String resourceGroupName, String targetName, InstallSolutionParameter body,
        Context context) {
        this.serviceClient().installSolution(resourceGroupName, targetName, body, context);
    }

    public void uninstallSolution(String resourceGroupName, String targetName, UninstallSolutionParameter body) {
        this.serviceClient().uninstallSolution(resourceGroupName, targetName, body);
    }

    public void uninstallSolution(String resourceGroupName, String targetName, UninstallSolutionParameter body,
        Context context) {
        this.serviceClient().uninstallSolution(resourceGroupName, targetName, body, context);
    }

    public void removeRevision(String resourceGroupName, String targetName, RemoveRevisionParameter body) {
        this.serviceClient().removeRevision(resourceGroupName, targetName, body);
    }

    public void removeRevision(String resourceGroupName, String targetName, RemoveRevisionParameter body,
        Context context) {
        this.serviceClient().removeRevision(resourceGroupName, targetName, body, context);
    }

    public ResolvedConfiguration resolveConfiguration(String resourceGroupName, String targetName,
        SolutionTemplateParameter body) {
        ResolvedConfigurationInner inner
            = this.serviceClient().resolveConfiguration(resourceGroupName, targetName, body);
        if (inner != null) {
            return new ResolvedConfigurationImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public ResolvedConfiguration resolveConfiguration(String resourceGroupName, String targetName,
        SolutionTemplateParameter body, Context context) {
        ResolvedConfigurationInner inner
            = this.serviceClient().resolveConfiguration(resourceGroupName, targetName, body, context);
        if (inner != null) {
            return new ResolvedConfigurationImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SolutionVersion reviewSolutionVersion(String resourceGroupName, String targetName,
        SolutionTemplateParameter body) {
        SolutionVersionInner inner = this.serviceClient().reviewSolutionVersion(resourceGroupName, targetName, body);
        if (inner != null) {
            return new SolutionVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SolutionVersion reviewSolutionVersion(String resourceGroupName, String targetName,
        SolutionTemplateParameter body, Context context) {
        SolutionVersionInner inner
            = this.serviceClient().reviewSolutionVersion(resourceGroupName, targetName, body, context);
        if (inner != null) {
            return new SolutionVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SolutionVersion publishSolutionVersion(String resourceGroupName, String targetName,
        SolutionVersionParameter body) {
        SolutionVersionInner inner = this.serviceClient().publishSolutionVersion(resourceGroupName, targetName, body);
        if (inner != null) {
            return new SolutionVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SolutionVersion publishSolutionVersion(String resourceGroupName, String targetName,
        SolutionVersionParameter body, Context context) {
        SolutionVersionInner inner
            = this.serviceClient().publishSolutionVersion(resourceGroupName, targetName, body, context);
        if (inner != null) {
            return new SolutionVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SolutionVersion updateExternalValidationStatus(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body) {
        SolutionVersionInner inner
            = this.serviceClient().updateExternalValidationStatus(resourceGroupName, targetName, body);
        if (inner != null) {
            return new SolutionVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public SolutionVersion updateExternalValidationStatus(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body, Context context) {
        SolutionVersionInner inner
            = this.serviceClient().updateExternalValidationStatus(resourceGroupName, targetName, body, context);
        if (inner != null) {
            return new SolutionVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public Target getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, targetName, Context.NONE).getValue();
    }

    public Response<Target> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        return this.getByResourceGroupWithResponse(resourceGroupName, targetName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        Boolean localForceDelete = null;
        this.delete(resourceGroupName, targetName, localForceDelete, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Boolean forceDelete, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String targetName = ResourceManagerUtils.getValueFromIdByName(id, "targets");
        if (targetName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'targets'.", id)));
        }
        this.delete(resourceGroupName, targetName, forceDelete, context);
    }

    private TargetsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public TargetImpl define(String name) {
        return new TargetImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/WorkflowImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.Workflow;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties;

public final class WorkflowImpl implements Workflow, Workflow.Definition, Workflow.Update {
    private WorkflowInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public WorkflowProperties properties() {
        return this.innerModel().properties();
    }

    public ExtendedLocation extendedLocation() {
        return this.innerModel().extendedLocation();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public WorkflowInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String contextName;

    private String workflowName;

    public WorkflowImpl withExistingContext(String resourceGroupName, String contextName) {
        this.resourceGroupName = resourceGroupName;
        this.contextName = contextName;
        return this;
    }

    public Workflow create() {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflows()
            .createOrUpdate(resourceGroupName, contextName, workflowName, this.innerModel(), Context.NONE);
        return this;
    }

    public Workflow create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflows()
            .createOrUpdate(resourceGroupName, contextName, workflowName, this.innerModel(), context);
        return this;
    }

    WorkflowImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new WorkflowInner();
        this.serviceManager = serviceManager;
        this.workflowName = name;
    }

    public WorkflowImpl update() {
        return this;
    }

    public Workflow apply() {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflows()
            .update(resourceGroupName, contextName, workflowName, this.innerModel(), Context.NONE);
        return this;
    }

    public Workflow apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflows()
            .update(resourceGroupName, contextName, workflowName, this.innerModel(), context);
        return this;
    }

    WorkflowImpl(WorkflowInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.contextName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "contexts");
        this.workflowName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "workflows");
    }

    public Workflow refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflows()
            .getWithResponse(resourceGroupName, contextName, workflowName, Context.NONE)
            .getValue();
        return this;
    }

    public Workflow refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflows()
            .getWithResponse(resourceGroupName, contextName, workflowName, context)
            .getValue();
        return this;
    }

    public WorkflowImpl withProperties(WorkflowProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }

    public WorkflowImpl withExtendedLocation(ExtendedLocation extendedLocation) {
        this.innerModel().withExtendedLocation(extendedLocation);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/WorkflowsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.WorkflowListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in WorkflowsClient.
 */
public final class WorkflowsClientImpl implements WorkflowsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final WorkflowsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of WorkflowsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    WorkflowsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(WorkflowsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientWorkflows to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientWorkflows")
    public interface WorkflowsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<WorkflowInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<WorkflowInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") WorkflowInner resource,
            Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") WorkflowInner resource,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") WorkflowInner properties,
            Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @HeaderParam("Content-Type") String contentType,
            @HeaderParam("Accept") String accept, @BodyParam("application/json") WorkflowInner properties,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<WorkflowListResult>> listByContext(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<WorkflowListResult> listByContextSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<WorkflowListResult>> listByContextNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<WorkflowListResult> listByContextNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<WorkflowInner>> getWithResponseAsync(String resourceGroupName, String contextName,
        String workflowName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, accept, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<WorkflowInner> getAsync(String resourceGroupName, String contextName, String workflowName) {
        return getWithResponseAsync(resourceGroupName, contextName, workflowName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<WorkflowInner> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, contextName, workflowName, accept, context);
    }

    /**
     * Get a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowInner get(String resourceGroupName, String contextName, String workflowName) {
        return getWithResponse(resourceGroupName, contextName, workflowName, Context.NONE).getValue();
    }

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String contextName, String workflowName, WorkflowInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, contentType, accept,
                resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        String workflowName, WorkflowInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, contentType, accept,
            resource, Context.NONE);
    }

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        String workflowName, WorkflowInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, contentType, accept,
            resource, context);
    }

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<WorkflowInner>, WorkflowInner> beginCreateOrUpdateAsync(String resourceGroupName,
        String contextName, String workflowName, WorkflowInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, contextName, workflowName, resource);
        return this.client.<WorkflowInner, WorkflowInner>getLroResult(mono, this.client.getHttpPipeline(),
            WorkflowInner.class, WorkflowInner.class, this.client.getContext());
    }

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<WorkflowInner>, WorkflowInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, WorkflowInner resource) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, contextName, workflowName, resource);
        return this.client.<WorkflowInner, WorkflowInner>getLroResult(response, WorkflowInner.class,
            WorkflowInner.class, Context.NONE);
    }

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<WorkflowInner>, WorkflowInner> beginCreateOrUpdate(String resourceGroupName,
        String contextName, String workflowName, WorkflowInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, contextName, workflowName, resource, context);
        return this.client.<WorkflowInner, WorkflowInner>getLroResult(response, WorkflowInner.class,
            WorkflowInner.class, context);
    }

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<WorkflowInner> createOrUpdateAsync(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, contextName, workflowName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner resource) {
        return beginCreateOrUpdate(resourceGroupName, contextName, workflowName, resource).getFinalResult();
    }

    /**
     * Create or update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, contextName, workflowName, resource, context).getFinalResult();
    }

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String contextName,
        String workflowName, WorkflowInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, contentType, accept,
                properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, contentType, accept,
            properties, Context.NONE);
    }

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, contentType, accept,
            properties, context);
    }

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<WorkflowInner>, WorkflowInner> beginUpdateAsync(String resourceGroupName,
        String contextName, String workflowName, WorkflowInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = updateWithResponseAsync(resourceGroupName, contextName, workflowName, properties);
        return this.client.<WorkflowInner, WorkflowInner>getLroResult(mono, this.client.getHttpPipeline(),
            WorkflowInner.class, WorkflowInner.class, this.client.getContext());
    }

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<WorkflowInner>, WorkflowInner> beginUpdate(String resourceGroupName,
        String contextName, String workflowName, WorkflowInner properties) {
        Response<BinaryData> response = updateWithResponse(resourceGroupName, contextName, workflowName, properties);
        return this.client.<WorkflowInner, WorkflowInner>getLroResult(response, WorkflowInner.class,
            WorkflowInner.class, Context.NONE);
    }

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<WorkflowInner>, WorkflowInner> beginUpdate(String resourceGroupName,
        String contextName, String workflowName, WorkflowInner properties, Context context) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, contextName, workflowName, properties, context);
        return this.client.<WorkflowInner, WorkflowInner>getLroResult(response, WorkflowInner.class,
            WorkflowInner.class, context);
    }

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<WorkflowInner> updateAsync(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner properties) {
        return beginUpdateAsync(resourceGroupName, contextName, workflowName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowInner update(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner properties) {
        return beginUpdate(resourceGroupName, contextName, workflowName, properties).getFinalResult();
    }

    /**
     * update a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowInner update(String resourceGroupName, String contextName, String workflowName,
        WorkflowInner properties, Context context) {
        return beginUpdate(resourceGroupName, contextName, workflowName, properties, context).getFinalResult();
    }

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String contextName,
        String workflowName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName, String workflowName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, Context.NONE);
    }

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName, String workflowName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, context);
    }

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String contextName,
        String workflowName) {
        Mono<Response<Flux<ByteBuffer>>> mono = deleteWithResponseAsync(resourceGroupName, contextName, workflowName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String workflowName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, contextName, workflowName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String workflowName, Context context) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, contextName, workflowName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String contextName, String workflowName) {
        return beginDeleteAsync(resourceGroupName, contextName, workflowName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName, String workflowName) {
        beginDelete(resourceGroupName, contextName, workflowName).getFinalResult();
    }

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName, String workflowName, Context context) {
        beginDelete(resourceGroupName, contextName, workflowName, context).getFinalResult();
    }

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<WorkflowInner>> listByContextSinglePageAsync(String resourceGroupName,
        String contextName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByContext(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, accept, context))
            .<PagedResponse<WorkflowInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<WorkflowInner> listByContextAsync(String resourceGroupName, String contextName) {
        return new PagedFlux<>(() -> listByContextSinglePageAsync(resourceGroupName, contextName),
            nextLink -> listByContextNextSinglePageAsync(nextLink));
    }

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<WorkflowInner> listByContextSinglePage(String resourceGroupName, String contextName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<WorkflowListResult> res
            = service.listByContextSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<WorkflowInner> listByContextSinglePage(String resourceGroupName, String contextName,
        Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<WorkflowListResult> res
            = service.listByContextSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<WorkflowInner> listByContext(String resourceGroupName, String contextName) {
        return new PagedIterable<>(() -> listByContextSinglePage(resourceGroupName, contextName),
            nextLink -> listByContextNextSinglePage(nextLink));
    }

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<WorkflowInner> listByContext(String resourceGroupName, String contextName, Context context) {
        return new PagedIterable<>(() -> listByContextSinglePage(resourceGroupName, contextName, context),
            nextLink -> listByContextNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation along with {@link PagedResponse} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<WorkflowInner>> listByContextNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByContextNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<WorkflowInner>>map(res -> new PagedResponseBase<>(res.getRequest(), res.getStatusCode(),
                res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<WorkflowInner> listByContextNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<WorkflowListResult> res
            = service.listByContextNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<WorkflowInner> listByContextNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<WorkflowListResult> res
            = service.listByContextNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(WorkflowsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/WorkflowsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner;
import com.azure.resourcemanager.workloadorchestration.models.Workflow;
import com.azure.resourcemanager.workloadorchestration.models.Workflows;

public final class WorkflowsImpl implements Workflows {
    private static final ClientLogger LOGGER = new ClientLogger(WorkflowsImpl.class);

    private final WorkflowsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public WorkflowsImpl(WorkflowsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<Workflow> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        Context context) {
        Response<WorkflowInner> inner
            = this.serviceClient().getWithResponse(resourceGroupName, contextName, workflowName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new WorkflowImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public Workflow get(String resourceGroupName, String contextName, String workflowName) {
        WorkflowInner inner = this.serviceClient().get(resourceGroupName, contextName, workflowName);
        if (inner != null) {
            return new WorkflowImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String contextName, String workflowName) {
        this.serviceClient().delete(resourceGroupName, contextName, workflowName);
    }

    public void delete(String resourceGroupName, String contextName, String workflowName, Context context) {
        this.serviceClient().delete(resourceGroupName, contextName, workflowName, context);
    }

    public PagedIterable<Workflow> listByContext(String resourceGroupName, String contextName) {
        PagedIterable<WorkflowInner> inner = this.serviceClient().listByContext(resourceGroupName, contextName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new WorkflowImpl(inner1, this.manager()));
    }

    public PagedIterable<Workflow> listByContext(String resourceGroupName, String contextName, Context context) {
        PagedIterable<WorkflowInner> inner
            = this.serviceClient().listByContext(resourceGroupName, contextName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new WorkflowImpl(inner1, this.manager()));
    }

    public Workflow getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        return this.getWithResponse(resourceGroupName, contextName, workflowName, Context.NONE).getValue();
    }

    public Response<Workflow> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        return this.getWithResponse(resourceGroupName, contextName, workflowName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        this.delete(resourceGroupName, contextName, workflowName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        this.delete(resourceGroupName, contextName, workflowName, context);
    }

    private WorkflowsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public WorkflowImpl define(String name) {
        return new WorkflowImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/WorkflowVersionImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersion;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties;

public final class WorkflowVersionImpl implements WorkflowVersion, WorkflowVersion.Definition, WorkflowVersion.Update {
    private WorkflowVersionInner innerObject;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public String id() {
        return this.innerModel().id();
    }

    public String name() {
        return this.innerModel().name();
    }

    public String type() {
        return this.innerModel().type();
    }

    public WorkflowVersionProperties properties() {
        return this.innerModel().properties();
    }

    public ExtendedLocation extendedLocation() {
        return this.innerModel().extendedLocation();
    }

    public String eTag() {
        return this.innerModel().eTag();
    }

    public SystemData systemData() {
        return this.innerModel().systemData();
    }

    public String resourceGroupName() {
        return resourceGroupName;
    }

    public WorkflowVersionInner innerModel() {
        return this.innerObject;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    private String resourceGroupName;

    private String contextName;

    private String workflowName;

    private String versionName;

    public WorkflowVersionImpl withExistingWorkflow(String resourceGroupName, String contextName, String workflowName) {
        this.resourceGroupName = resourceGroupName;
        this.contextName = contextName;
        this.workflowName = workflowName;
        return this;
    }

    public WorkflowVersion create() {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflowVersions()
            .createOrUpdate(resourceGroupName, contextName, workflowName, versionName, this.innerModel(), Context.NONE);
        return this;
    }

    public WorkflowVersion create(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflowVersions()
            .createOrUpdate(resourceGroupName, contextName, workflowName, versionName, this.innerModel(), context);
        return this;
    }

    WorkflowVersionImpl(String name,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = new WorkflowVersionInner();
        this.serviceManager = serviceManager;
        this.versionName = name;
    }

    public WorkflowVersionImpl update() {
        return this;
    }

    public WorkflowVersion apply() {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflowVersions()
            .update(resourceGroupName, contextName, workflowName, versionName, this.innerModel(), Context.NONE);
        return this;
    }

    public WorkflowVersion apply(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflowVersions()
            .update(resourceGroupName, contextName, workflowName, versionName, this.innerModel(), context);
        return this;
    }

    WorkflowVersionImpl(WorkflowVersionInner innerObject,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerObject = innerObject;
        this.serviceManager = serviceManager;
        this.resourceGroupName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "resourceGroups");
        this.contextName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "contexts");
        this.workflowName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "workflows");
        this.versionName = ResourceManagerUtils.getValueFromIdByName(innerObject.id(), "versions");
    }

    public WorkflowVersion refresh() {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflowVersions()
            .getWithResponse(resourceGroupName, contextName, workflowName, versionName, Context.NONE)
            .getValue();
        return this;
    }

    public WorkflowVersion refresh(Context context) {
        this.innerObject = serviceManager.serviceClient()
            .getWorkflowVersions()
            .getWithResponse(resourceGroupName, contextName, workflowName, versionName, context)
            .getValue();
        return this;
    }

    public WorkflowVersionImpl withProperties(WorkflowVersionProperties properties) {
        this.innerModel().withProperties(properties);
        return this;
    }

    public WorkflowVersionImpl withExtendedLocation(ExtendedLocation extendedLocation) {
        this.innerModel().withExtendedLocation(extendedLocation);
        return this;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/WorkflowVersionsClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Headers;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner;
import com.azure.resourcemanager.workloadorchestration.implementation.models.WorkflowVersionListResult;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in WorkflowVersionsClient.
 */
public final class WorkflowVersionsClientImpl implements WorkflowVersionsClient {
    /**
     * The proxy service used to perform REST calls.
     */
    private final WorkflowVersionsService service;

    /**
     * The service client containing this operation class.
     */
    private final WorkloadOrchestrationManagementClientImpl client;

    /**
     * Initializes an instance of WorkflowVersionsClientImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    WorkflowVersionsClientImpl(WorkloadOrchestrationManagementClientImpl client) {
        this.service
            = RestProxy.create(WorkflowVersionsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for WorkloadOrchestrationManagementClientWorkflowVersions to be used by
     * the proxy service to perform REST calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "WorkloadOrchestrationManagementClientWorkflowVersions")
    public interface WorkflowVersionsService {
        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<WorkflowVersionInner>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<WorkflowVersionInner> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> createOrUpdate(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") WorkflowVersionInner resource, Context context);

        @Put("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> createOrUpdateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") WorkflowVersionInner resource, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> update(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") WorkflowVersionInner properties, Context context);

        @Patch("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> updateSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") WorkflowVersionInner properties, Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<Flux<ByteBuffer>>> delete(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            Context context);

        @Headers({ "Accept: application/json;q=0.9", "Content-Type: application/json" })
        @Delete("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<BinaryData> deleteSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @PathParam("versionName") String versionName,
            Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<WorkflowVersionListResult>> listByWorkflow(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<WorkflowVersionListResult> listByWorkflowSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("subscriptionId") String subscriptionId,
            @PathParam("resourceGroupName") String resourceGroupName, @PathParam("contextName") String contextName,
            @PathParam("workflowName") String workflowName, @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Mono<Response<WorkflowVersionListResult>> listByWorkflowNext(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);

        @Headers({ "Content-Type: application/json" })
        @Get("{nextLink}")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(ManagementException.class)
        Response<WorkflowVersionListResult> listByWorkflowNextSync(
            @PathParam(value = "nextLink", encoded = true) String nextLink, @HostParam("endpoint") String endpoint,
            @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Get a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<WorkflowVersionInner>> getWithResponseAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.get(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, accept,
                context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<WorkflowVersionInner> getAsync(String resourceGroupName, String contextName, String workflowName,
        String versionName) {
        return getWithResponseAsync(resourceGroupName, contextName, workflowName, versionName)
            .flatMap(res -> Mono.justOrEmpty(res.getValue()));
    }

    /**
     * Get a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<WorkflowVersionInner> getWithResponse(String resourceGroupName, String contextName,
        String workflowName, String versionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getApiVersion(), this.client.getSubscriptionId(),
            resourceGroupName, contextName, workflowName, versionName, accept, context);
    }

    /**
     * Get a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowVersionInner get(String resourceGroupName, String contextName, String workflowName,
        String versionName) {
        return getWithResponse(resourceGroupName, contextName, workflowName, versionName, Context.NONE).getValue();
    }

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName,
        String contextName, String workflowName, String versionName, WorkflowVersionInner resource) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (resource == null) {
            return Mono.error(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.createOrUpdate(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, contentType,
                accept, resource, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        String workflowName, String versionName, WorkflowVersionInner resource) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, contentType,
            accept, resource, Context.NONE);
    }

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> createOrUpdateWithResponse(String resourceGroupName, String contextName,
        String workflowName, String versionName, WorkflowVersionInner resource, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (resource == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resource is required and cannot be null."));
        } else {
            resource.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.createOrUpdateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, contentType,
            accept, resource, context);
    }

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginCreateOrUpdateAsync(
        String resourceGroupName, String contextName, String workflowName, String versionName,
        WorkflowVersionInner resource) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = createOrUpdateWithResponseAsync(resourceGroupName, contextName, workflowName, versionName, resource);
        return this.client.<WorkflowVersionInner, WorkflowVersionInner>getLroResult(mono, this.client.getHttpPipeline(),
            WorkflowVersionInner.class, WorkflowVersionInner.class, this.client.getContext());
    }

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginCreateOrUpdate(
        String resourceGroupName, String contextName, String workflowName, String versionName,
        WorkflowVersionInner resource) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, contextName, workflowName, versionName, resource);
        return this.client.<WorkflowVersionInner, WorkflowVersionInner>getLroResult(response,
            WorkflowVersionInner.class, WorkflowVersionInner.class, Context.NONE);
    }

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginCreateOrUpdate(
        String resourceGroupName, String contextName, String workflowName, String versionName,
        WorkflowVersionInner resource, Context context) {
        Response<BinaryData> response
            = createOrUpdateWithResponse(resourceGroupName, contextName, workflowName, versionName, resource, context);
        return this.client.<WorkflowVersionInner, WorkflowVersionInner>getLroResult(response,
            WorkflowVersionInner.class, WorkflowVersionInner.class, context);
    }

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<WorkflowVersionInner> createOrUpdateAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName, WorkflowVersionInner resource) {
        return beginCreateOrUpdateAsync(resourceGroupName, contextName, workflowName, versionName, resource).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowVersionInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        String versionName, WorkflowVersionInner resource) {
        return beginCreateOrUpdate(resourceGroupName, contextName, workflowName, versionName, resource)
            .getFinalResult();
    }

    /**
     * Create or update a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param resource Resource create parameters.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowVersionInner createOrUpdate(String resourceGroupName, String contextName, String workflowName,
        String versionName, WorkflowVersionInner resource, Context context) {
        return beginCreateOrUpdate(resourceGroupName, contextName, workflowName, versionName, resource, context)
            .getFinalResult();
    }

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> updateWithResponseAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName, WorkflowVersionInner properties) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (properties == null) {
            return Mono.error(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.update(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, contentType,
                accept, properties, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, WorkflowVersionInner properties) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, contentType,
            accept, properties, Context.NONE);
    }

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> updateWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, WorkflowVersionInner properties, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        if (properties == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter properties is required and cannot be null."));
        } else {
            properties.validate();
        }
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.updateSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, contentType,
            accept, properties, context);
    }

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginUpdateAsync(
        String resourceGroupName, String contextName, String workflowName, String versionName,
        WorkflowVersionInner properties) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = updateWithResponseAsync(resourceGroupName, contextName, workflowName, versionName, properties);
        return this.client.<WorkflowVersionInner, WorkflowVersionInner>getLroResult(mono, this.client.getHttpPipeline(),
            WorkflowVersionInner.class, WorkflowVersionInner.class, this.client.getContext());
    }

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, WorkflowVersionInner properties) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, contextName, workflowName, versionName, properties);
        return this.client.<WorkflowVersionInner, WorkflowVersionInner>getLroResult(response,
            WorkflowVersionInner.class, WorkflowVersionInner.class, Context.NONE);
    }

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<WorkflowVersionInner>, WorkflowVersionInner> beginUpdate(String resourceGroupName,
        String contextName, String workflowName, String versionName, WorkflowVersionInner properties, Context context) {
        Response<BinaryData> response
            = updateWithResponse(resourceGroupName, contextName, workflowName, versionName, properties, context);
        return this.client.<WorkflowVersionInner, WorkflowVersionInner>getLroResult(response,
            WorkflowVersionInner.class, WorkflowVersionInner.class, context);
    }

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<WorkflowVersionInner> updateAsync(String resourceGroupName, String contextName, String workflowName,
        String versionName, WorkflowVersionInner properties) {
        return beginUpdateAsync(resourceGroupName, contextName, workflowName, versionName, properties).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowVersionInner update(String resourceGroupName, String contextName, String workflowName,
        String versionName, WorkflowVersionInner properties) {
        return beginUpdate(resourceGroupName, contextName, workflowName, versionName, properties).getFinalResult();
    }

    /**
     * update an WorkflowVersion Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param properties The resource properties to be updated.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return workflow Version Resource.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WorkflowVersionInner update(String resourceGroupName, String contextName, String workflowName,
        String versionName, WorkflowVersionInner properties, Context context) {
        return beginUpdate(resourceGroupName, contextName, workflowName, versionName, properties, context)
            .getFinalResult();
    }

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Response<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            return Mono.error(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        return FluxUtil
            .withContext(context -> service.delete(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, context))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, Context.NONE);
    }

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Response<BinaryData> deleteWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        if (versionName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter versionName is required and cannot be null."));
        }
        return service.deleteSync(this.client.getEndpoint(), this.client.getApiVersion(),
            this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, versionName, context);
    }

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    private PollerFlux<PollResult<Void>, Void> beginDeleteAsync(String resourceGroupName, String contextName,
        String workflowName, String versionName) {
        Mono<Response<Flux<ByteBuffer>>> mono
            = deleteWithResponseAsync(resourceGroupName, contextName, workflowName, versionName);
        return this.client.<Void, Void>getLroResult(mono, this.client.getHttpPipeline(), Void.class, Void.class,
            this.client.getContext());
    }

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String workflowName, String versionName) {
        Response<BinaryData> response = deleteWithResponse(resourceGroupName, contextName, workflowName, versionName);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, Context.NONE);
    }

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<PollResult<Void>, Void> beginDelete(String resourceGroupName, String contextName,
        String workflowName, String versionName, Context context) {
        Response<BinaryData> response
            = deleteWithResponse(resourceGroupName, contextName, workflowName, versionName, context);
        return this.client.<Void, Void>getLroResult(response, Void.class, Void.class, context);
    }

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return A {@link Mono} that completes when a successful response is received.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<Void> deleteAsync(String resourceGroupName, String contextName, String workflowName,
        String versionName) {
        return beginDeleteAsync(resourceGroupName, contextName, workflowName, versionName).last()
            .flatMap(this.client::getLroFinalResultOrError);
    }

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName, String workflowName, String versionName) {
        beginDelete(resourceGroupName, contextName, workflowName, versionName).getFinalResult();
    }

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        Context context) {
        beginDelete(resourceGroupName, contextName, workflowName, versionName, context).getFinalResult();
    }

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<WorkflowVersionInner>> listByWorkflowSinglePageAsync(String resourceGroupName,
        String contextName, String workflowName) {
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            return Mono.error(new IllegalArgumentException(
                "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            return Mono.error(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            return Mono.error(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByWorkflow(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, accept, context))
            .<PagedResponse<WorkflowVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    private PagedFlux<WorkflowVersionInner> listByWorkflowAsync(String resourceGroupName, String contextName,
        String workflowName) {
        return new PagedFlux<>(() -> listByWorkflowSinglePageAsync(resourceGroupName, contextName, workflowName),
            nextLink -> listByWorkflowNextSinglePageAsync(nextLink));
    }

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<WorkflowVersionInner> listByWorkflowSinglePage(String resourceGroupName, String contextName,
        String workflowName) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<WorkflowVersionListResult> res
            = service.listByWorkflowSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<WorkflowVersionInner> listByWorkflowSinglePage(String resourceGroupName, String contextName,
        String workflowName, Context context) {
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        if (this.client.getSubscriptionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getSubscriptionId() is required and cannot be null."));
        }
        if (resourceGroupName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null."));
        }
        if (contextName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter contextName is required and cannot be null."));
        }
        if (workflowName == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter workflowName is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<WorkflowVersionListResult> res
            = service.listByWorkflowSync(this.client.getEndpoint(), this.client.getApiVersion(),
                this.client.getSubscriptionId(), resourceGroupName, contextName, workflowName, accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<WorkflowVersionInner> listByWorkflow(String resourceGroupName, String contextName,
        String workflowName) {
        return new PagedIterable<>(() -> listByWorkflowSinglePage(resourceGroupName, contextName, workflowName),
            nextLink -> listByWorkflowNextSinglePage(nextLink));
    }

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<WorkflowVersionInner> listByWorkflow(String resourceGroupName, String contextName,
        String workflowName, Context context) {
        return new PagedIterable<>(
            () -> listByWorkflowSinglePage(resourceGroupName, contextName, workflowName, context),
            nextLink -> listByWorkflowNextSinglePage(nextLink, context));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation along with {@link PagedResponse} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<WorkflowVersionInner>> listByWorkflowNextSinglePageAsync(String nextLink) {
        if (nextLink == null) {
            return Mono.error(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            return Mono.error(
                new IllegalArgumentException("Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        return FluxUtil
            .withContext(context -> service.listByWorkflowNext(nextLink, this.client.getEndpoint(), accept, context))
            .<PagedResponse<WorkflowVersionInner>>map(res -> new PagedResponseBase<>(res.getRequest(),
                res.getStatusCode(), res.getHeaders(), res.getValue().value(), res.getValue().nextLink(), null))
            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<WorkflowVersionInner> listByWorkflowNextSinglePage(String nextLink) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<WorkflowVersionListResult> res
            = service.listByWorkflowNextSync(nextLink, this.client.getEndpoint(), accept, Context.NONE);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink The URL to get the next list of items.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<WorkflowVersionInner> listByWorkflowNextSinglePage(String nextLink, Context context) {
        if (nextLink == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Parameter nextLink is required and cannot be null."));
        }
        if (this.client.getEndpoint() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Parameter this.client.getEndpoint() is required and cannot be null."));
        }
        final String accept = "application/json";
        Response<WorkflowVersionListResult> res
            = service.listByWorkflowNextSync(nextLink, this.client.getEndpoint(), accept, context);
        return new PagedResponseBase<>(res.getRequest(), res.getStatusCode(), res.getHeaders(), res.getValue().value(),
            res.getValue().nextLink(), null);
    }

    private static final ClientLogger LOGGER = new ClientLogger(WorkflowVersionsClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/WorkflowVersionsImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersion;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersions;

public final class WorkflowVersionsImpl implements WorkflowVersions {
    private static final ClientLogger LOGGER = new ClientLogger(WorkflowVersionsImpl.class);

    private final WorkflowVersionsClient innerClient;

    private final com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager;

    public WorkflowVersionsImpl(WorkflowVersionsClient innerClient,
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public Response<WorkflowVersion> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, Context context) {
        Response<WorkflowVersionInner> inner
            = this.serviceClient().getWithResponse(resourceGroupName, contextName, workflowName, versionName, context);
        if (inner != null) {
            return new SimpleResponse<>(inner.getRequest(), inner.getStatusCode(), inner.getHeaders(),
                new WorkflowVersionImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public WorkflowVersion get(String resourceGroupName, String contextName, String workflowName, String versionName) {
        WorkflowVersionInner inner
            = this.serviceClient().get(resourceGroupName, contextName, workflowName, versionName);
        if (inner != null) {
            return new WorkflowVersionImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public void delete(String resourceGroupName, String contextName, String workflowName, String versionName) {
        this.serviceClient().delete(resourceGroupName, contextName, workflowName, versionName);
    }

    public void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        Context context) {
        this.serviceClient().delete(resourceGroupName, contextName, workflowName, versionName, context);
    }

    public PagedIterable<WorkflowVersion> listByWorkflow(String resourceGroupName, String contextName,
        String workflowName) {
        PagedIterable<WorkflowVersionInner> inner
            = this.serviceClient().listByWorkflow(resourceGroupName, contextName, workflowName);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new WorkflowVersionImpl(inner1, this.manager()));
    }

    public PagedIterable<WorkflowVersion> listByWorkflow(String resourceGroupName, String contextName,
        String workflowName, Context context) {
        PagedIterable<WorkflowVersionInner> inner
            = this.serviceClient().listByWorkflow(resourceGroupName, contextName, workflowName, context);
        return ResourceManagerUtils.mapPage(inner, inner1 -> new WorkflowVersionImpl(inner1, this.manager()));
    }

    public WorkflowVersion getById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        String versionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (versionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, contextName, workflowName, versionName, Context.NONE).getValue();
    }

    public Response<WorkflowVersion> getByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        String versionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (versionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        return this.getWithResponse(resourceGroupName, contextName, workflowName, versionName, context);
    }

    public void deleteById(String id) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        String versionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (versionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        this.delete(resourceGroupName, contextName, workflowName, versionName, Context.NONE);
    }

    public void deleteByIdWithResponse(String id, Context context) {
        String resourceGroupName = ResourceManagerUtils.getValueFromIdByName(id, "resourceGroups");
        if (resourceGroupName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'resourceGroups'.", id)));
        }
        String contextName = ResourceManagerUtils.getValueFromIdByName(id, "contexts");
        if (contextName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'contexts'.", id)));
        }
        String workflowName = ResourceManagerUtils.getValueFromIdByName(id, "workflows");
        if (workflowName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'workflows'.", id)));
        }
        String versionName = ResourceManagerUtils.getValueFromIdByName(id, "versions");
        if (versionName == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                String.format("The resource ID '%s' is not valid. Missing path segment 'versions'.", id)));
        }
        this.delete(resourceGroupName, contextName, workflowName, versionName, context);
    }

    private WorkflowVersionsClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager() {
        return this.serviceManager;
    }

    public WorkflowVersionImpl define(String name) {
        return new WorkflowVersionImpl(name, this.manager());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/WorkloadOrchestrationManagementClientImpl.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation;

import com.azure.core.annotation.ServiceClient;
import com.azure.core.http.HttpHeaderName;
import com.azure.core.http.HttpHeaders;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpResponse;
import com.azure.core.http.rest.Response;
import com.azure.core.management.AzureEnvironment;
import com.azure.core.management.exception.ManagementError;
import com.azure.core.management.exception.ManagementException;
import com.azure.core.management.polling.PollResult;
import com.azure.core.management.polling.PollerFactory;
import com.azure.core.management.polling.SyncPollerFactory;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.AsyncPollResponse;
import com.azure.core.util.polling.LongRunningOperationStatus;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.core.util.serializer.SerializerAdapter;
import com.azure.core.util.serializer.SerializerEncoding;
import com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient;
import com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.JobsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient;
import com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient;
import com.azure.resourcemanager.workloadorchestration.fluent.WorkloadOrchestrationManagementClient;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the WorkloadOrchestrationManagementClientImpl type.
 */
@ServiceClient(builder = WorkloadOrchestrationManagementClientBuilder.class)
public final class WorkloadOrchestrationManagementClientImpl implements WorkloadOrchestrationManagementClient {
    /**
     * Service host.
     */
    private final String endpoint;

    /**
     * Gets Service host.
     * 
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /**
     * Version parameter.
     */
    private final String apiVersion;

    /**
     * Gets Version parameter.
     * 
     * @return the apiVersion value.
     */
    public String getApiVersion() {
        return this.apiVersion;
    }

    /**
     * The ID of the target subscription. The value must be an UUID.
     */
    private final String subscriptionId;

    /**
     * Gets The ID of the target subscription. The value must be an UUID.
     * 
     * @return the subscriptionId value.
     */
    public String getSubscriptionId() {
        return this.subscriptionId;
    }

    /**
     * The HTTP pipeline to send requests through.
     */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     * 
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * The serializer to serialize an object into a string.
     */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     * 
     * @return the serializerAdapter value.
     */
    SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * The default poll interval for long-running operation.
     */
    private final Duration defaultPollInterval;

    /**
     * Gets The default poll interval for long-running operation.
     * 
     * @return the defaultPollInterval value.
     */
    public Duration getDefaultPollInterval() {
        return this.defaultPollInterval;
    }

    /**
     * The DynamicSchemasClient object to access its operations.
     */
    private final DynamicSchemasClient dynamicSchemas;

    /**
     * Gets the DynamicSchemasClient object to access its operations.
     * 
     * @return the DynamicSchemasClient object.
     */
    public DynamicSchemasClient getDynamicSchemas() {
        return this.dynamicSchemas;
    }

    /**
     * The SchemasClient object to access its operations.
     */
    private final SchemasClient schemas;

    /**
     * Gets the SchemasClient object to access its operations.
     * 
     * @return the SchemasClient object.
     */
    public SchemasClient getSchemas() {
        return this.schemas;
    }

    /**
     * The SchemaVersionsClient object to access its operations.
     */
    private final SchemaVersionsClient schemaVersions;

    /**
     * Gets the SchemaVersionsClient object to access its operations.
     * 
     * @return the SchemaVersionsClient object.
     */
    public SchemaVersionsClient getSchemaVersions() {
        return this.schemaVersions;
    }

    /**
     * The SolutionVersionsClient object to access its operations.
     */
    private final SolutionVersionsClient solutionVersions;

    /**
     * Gets the SolutionVersionsClient object to access its operations.
     * 
     * @return the SolutionVersionsClient object.
     */
    public SolutionVersionsClient getSolutionVersions() {
        return this.solutionVersions;
    }

    /**
     * The JobsClient object to access its operations.
     */
    private final JobsClient jobs;

    /**
     * Gets the JobsClient object to access its operations.
     * 
     * @return the JobsClient object.
     */
    public JobsClient getJobs() {
        return this.jobs;
    }

    /**
     * The TargetsClient object to access its operations.
     */
    private final TargetsClient targets;

    /**
     * Gets the TargetsClient object to access its operations.
     * 
     * @return the TargetsClient object.
     */
    public TargetsClient getTargets() {
        return this.targets;
    }

    /**
     * The DynamicSchemaVersionsClient object to access its operations.
     */
    private final DynamicSchemaVersionsClient dynamicSchemaVersions;

    /**
     * Gets the DynamicSchemaVersionsClient object to access its operations.
     * 
     * @return the DynamicSchemaVersionsClient object.
     */
    public DynamicSchemaVersionsClient getDynamicSchemaVersions() {
        return this.dynamicSchemaVersions;
    }

    /**
     * The SchemaReferencesClient object to access its operations.
     */
    private final SchemaReferencesClient schemaReferences;

    /**
     * Gets the SchemaReferencesClient object to access its operations.
     * 
     * @return the SchemaReferencesClient object.
     */
    public SchemaReferencesClient getSchemaReferences() {
        return this.schemaReferences;
    }

    /**
     * The SolutionsClient object to access its operations.
     */
    private final SolutionsClient solutions;

    /**
     * Gets the SolutionsClient object to access its operations.
     * 
     * @return the SolutionsClient object.
     */
    public SolutionsClient getSolutions() {
        return this.solutions;
    }

    /**
     * The SolutionTemplateVersionsClient object to access its operations.
     */
    private final SolutionTemplateVersionsClient solutionTemplateVersions;

    /**
     * Gets the SolutionTemplateVersionsClient object to access its operations.
     * 
     * @return the SolutionTemplateVersionsClient object.
     */
    public SolutionTemplateVersionsClient getSolutionTemplateVersions() {
        return this.solutionTemplateVersions;
    }

    /**
     * The SolutionTemplatesClient object to access its operations.
     */
    private final SolutionTemplatesClient solutionTemplates;

    /**
     * Gets the SolutionTemplatesClient object to access its operations.
     * 
     * @return the SolutionTemplatesClient object.
     */
    public SolutionTemplatesClient getSolutionTemplates() {
        return this.solutionTemplates;
    }

    /**
     * The InstancesClient object to access its operations.
     */
    private final InstancesClient instances;

    /**
     * Gets the InstancesClient object to access its operations.
     * 
     * @return the InstancesClient object.
     */
    public InstancesClient getInstances() {
        return this.instances;
    }

    /**
     * The InstanceHistoriesClient object to access its operations.
     */
    private final InstanceHistoriesClient instanceHistories;

    /**
     * Gets the InstanceHistoriesClient object to access its operations.
     * 
     * @return the InstanceHistoriesClient object.
     */
    public InstanceHistoriesClient getInstanceHistories() {
        return this.instanceHistories;
    }

    /**
     * The ConfigTemplatesClient object to access its operations.
     */
    private final ConfigTemplatesClient configTemplates;

    /**
     * Gets the ConfigTemplatesClient object to access its operations.
     * 
     * @return the ConfigTemplatesClient object.
     */
    public ConfigTemplatesClient getConfigTemplates() {
        return this.configTemplates;
    }

    /**
     * The ConfigTemplateVersionsClient object to access its operations.
     */
    private final ConfigTemplateVersionsClient configTemplateVersions;

    /**
     * Gets the ConfigTemplateVersionsClient object to access its operations.
     * 
     * @return the ConfigTemplateVersionsClient object.
     */
    public ConfigTemplateVersionsClient getConfigTemplateVersions() {
        return this.configTemplateVersions;
    }

    /**
     * The WorkflowsClient object to access its operations.
     */
    private final WorkflowsClient workflows;

    /**
     * Gets the WorkflowsClient object to access its operations.
     * 
     * @return the WorkflowsClient object.
     */
    public WorkflowsClient getWorkflows() {
        return this.workflows;
    }

    /**
     * The WorkflowVersionsClient object to access its operations.
     */
    private final WorkflowVersionsClient workflowVersions;

    /**
     * Gets the WorkflowVersionsClient object to access its operations.
     * 
     * @return the WorkflowVersionsClient object.
     */
    public WorkflowVersionsClient getWorkflowVersions() {
        return this.workflowVersions;
    }

    /**
     * The ExecutionsClient object to access its operations.
     */
    private final ExecutionsClient executions;

    /**
     * Gets the ExecutionsClient object to access its operations.
     * 
     * @return the ExecutionsClient object.
     */
    public ExecutionsClient getExecutions() {
        return this.executions;
    }

    /**
     * The DiagnosticsClient object to access its operations.
     */
    private final DiagnosticsClient diagnostics;

    /**
     * Gets the DiagnosticsClient object to access its operations.
     * 
     * @return the DiagnosticsClient object.
     */
    public DiagnosticsClient getDiagnostics() {
        return this.diagnostics;
    }

    /**
     * The ContextsClient object to access its operations.
     */
    private final ContextsClient contexts;

    /**
     * Gets the ContextsClient object to access its operations.
     * 
     * @return the ContextsClient object.
     */
    public ContextsClient getContexts() {
        return this.contexts;
    }

    /**
     * The SiteReferencesClient object to access its operations.
     */
    private final SiteReferencesClient siteReferences;

    /**
     * Gets the SiteReferencesClient object to access its operations.
     * 
     * @return the SiteReferencesClient object.
     */
    public SiteReferencesClient getSiteReferences() {
        return this.siteReferences;
    }

    /**
     * Initializes an instance of WorkloadOrchestrationManagementClient client.
     * 
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param defaultPollInterval The default poll interval for long-running operation.
     * @param environment The Azure environment.
     * @param endpoint Service host.
     * @param subscriptionId The ID of the target subscription. The value must be an UUID.
     */
    WorkloadOrchestrationManagementClientImpl(HttpPipeline httpPipeline, SerializerAdapter serializerAdapter,
        Duration defaultPollInterval, AzureEnvironment environment, String endpoint, String subscriptionId) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.defaultPollInterval = defaultPollInterval;
        this.endpoint = endpoint;
        this.subscriptionId = subscriptionId;
        this.apiVersion = "2025-06-01";
        this.dynamicSchemas = new DynamicSchemasClientImpl(this);
        this.schemas = new SchemasClientImpl(this);
        this.schemaVersions = new SchemaVersionsClientImpl(this);
        this.solutionVersions = new SolutionVersionsClientImpl(this);
        this.jobs = new JobsClientImpl(this);
        this.targets = new TargetsClientImpl(this);
        this.dynamicSchemaVersions = new DynamicSchemaVersionsClientImpl(this);
        this.schemaReferences = new SchemaReferencesClientImpl(this);
        this.solutions = new SolutionsClientImpl(this);
        this.solutionTemplateVersions = new SolutionTemplateVersionsClientImpl(this);
        this.solutionTemplates = new SolutionTemplatesClientImpl(this);
        this.instances = new InstancesClientImpl(this);
        this.instanceHistories = new InstanceHistoriesClientImpl(this);
        this.configTemplates = new ConfigTemplatesClientImpl(this);
        this.configTemplateVersions = new ConfigTemplateVersionsClientImpl(this);
        this.workflows = new WorkflowsClientImpl(this);
        this.workflowVersions = new WorkflowVersionsClientImpl(this);
        this.executions = new ExecutionsClientImpl(this);
        this.diagnostics = new DiagnosticsClientImpl(this);
        this.contexts = new ContextsClientImpl(this);
        this.siteReferences = new SiteReferencesClientImpl(this);
    }

    /**
     * Gets default client context.
     * 
     * @return the default client context.
     */
    public Context getContext() {
        return Context.NONE;
    }

    /**
     * Merges default client context with provided context.
     * 
     * @param context the context to be merged with default client context.
     * @return the merged context.
     */
    public Context mergeContext(Context context) {
        return CoreUtils.mergeContexts(this.getContext(), context);
    }

    /**
     * Gets long running operation result.
     * 
     * @param activationResponse the response of activation operation.
     * @param httpPipeline the http pipeline.
     * @param pollResultType type of poll result.
     * @param finalResultType type of final result.
     * @param context the context shared by all requests.
     * @param <T> type of poll result.
     * @param <U> type of final result.
     * @return poller flux for poll result and final result.
     */
    public <T, U> PollerFlux<PollResult<T>, U> getLroResult(Mono<Response<Flux<ByteBuffer>>> activationResponse,
        HttpPipeline httpPipeline, Type pollResultType, Type finalResultType, Context context) {
        return PollerFactory.create(serializerAdapter, httpPipeline, pollResultType, finalResultType,
            defaultPollInterval, activationResponse, context);
    }

    /**
     * Gets long running operation result.
     * 
     * @param activationResponse the response of activation operation.
     * @param pollResultType type of poll result.
     * @param finalResultType type of final result.
     * @param context the context shared by all requests.
     * @param <T> type of poll result.
     * @param <U> type of final result.
     * @return SyncPoller for poll result and final result.
     */
    public <T, U> SyncPoller<PollResult<T>, U> getLroResult(Response<BinaryData> activationResponse,
        Type pollResultType, Type finalResultType, Context context) {
        return SyncPollerFactory.create(serializerAdapter, httpPipeline, pollResultType, finalResultType,
            defaultPollInterval, () -> activationResponse, context);
    }

    /**
     * Gets the final result, or an error, based on last async poll response.
     * 
     * @param response the last async poll response.
     * @param <T> type of poll result.
     * @param <U> type of final result.
     * @return the final result, or an error.
     */
    public <T, U> Mono<U> getLroFinalResultOrError(AsyncPollResponse<PollResult<T>, U> response) {
        if (response.getStatus() != LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {
            String errorMessage;
            ManagementError managementError = null;
            HttpResponse errorResponse = null;
            PollResult.Error lroError = response.getValue().getError();
            if (lroError != null) {
                errorResponse = new HttpResponseImpl(lroError.getResponseStatusCode(), lroError.getResponseHeaders(),
                    lroError.getResponseBody());

                errorMessage = response.getValue().getError().getMessage();
                String errorBody = response.getValue().getError().getResponseBody();
                if (errorBody != null) {
                    // try to deserialize error body to ManagementError
                    try {
                        managementError = this.getSerializerAdapter()
                            .deserialize(errorBody, ManagementError.class, SerializerEncoding.JSON);
                        if (managementError.getCode() == null || managementError.getMessage() == null) {
                            managementError = null;
                        }
                    } catch (IOException | RuntimeException ioe) {
                        LOGGER.logThrowableAsWarning(ioe);
                    }
                }
            } else {
                // fallback to default error message
                errorMessage = "Long running operation failed.";
            }
            if (managementError == null) {
                // fallback to default ManagementError
                managementError = new ManagementError(response.getStatus().toString(), errorMessage);
            }
            return Mono.error(new ManagementException(errorMessage, errorResponse, managementError));
        } else {
            return response.getFinalResult();
        }
    }

    private static final class HttpResponseImpl extends HttpResponse {
        private final int statusCode;

        private final byte[] responseBody;

        private final HttpHeaders httpHeaders;

        HttpResponseImpl(int statusCode, HttpHeaders httpHeaders, String responseBody) {
            super(null);
            this.statusCode = statusCode;
            this.httpHeaders = httpHeaders;
            this.responseBody = responseBody == null ? null : responseBody.getBytes(StandardCharsets.UTF_8);
        }

        public int getStatusCode() {
            return statusCode;
        }

        public String getHeaderValue(String s) {
            return httpHeaders.getValue(HttpHeaderName.fromString(s));
        }

        public HttpHeaders getHeaders() {
            return httpHeaders;
        }

        public Flux<ByteBuffer> getBody() {
            return Flux.just(ByteBuffer.wrap(responseBody));
        }

        public Mono<byte[]> getBodyAsByteArray() {
            return Mono.just(responseBody);
        }

        public Mono<String> getBodyAsString() {
            return Mono.just(new String(responseBody, StandardCharsets.UTF_8));
        }

        public Mono<String> getBodyAsString(Charset charset) {
            return Mono.just(new String(responseBody, charset));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(WorkloadOrchestrationManagementClientImpl.class);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/ConfigTemplateListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a ConfigTemplate list operation.
 */
@Immutable
public final class ConfigTemplateListResult implements JsonSerializable<ConfigTemplateListResult> {
    /*
     * The ConfigTemplate items on this page
     */
    private List<ConfigTemplateInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of ConfigTemplateListResult class.
     */
    private ConfigTemplateListResult() {
    }

    /**
     * Get the value property: The ConfigTemplate items on this page.
     * 
     * @return the value value.
     */
    public List<ConfigTemplateInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model ConfigTemplateListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ConfigTemplateListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ConfigTemplateListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ConfigTemplateListResult if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ConfigTemplateListResult.
     */
    public static ConfigTemplateListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ConfigTemplateListResult deserializedConfigTemplateListResult = new ConfigTemplateListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<ConfigTemplateInner> value
                        = reader.readArray(reader1 -> ConfigTemplateInner.fromJson(reader1));
                    deserializedConfigTemplateListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedConfigTemplateListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedConfigTemplateListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/ConfigTemplateVersionListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a ConfigTemplateVersion list operation.
 */
@Immutable
public final class ConfigTemplateVersionListResult implements JsonSerializable<ConfigTemplateVersionListResult> {
    /*
     * The ConfigTemplateVersion items on this page
     */
    private List<ConfigTemplateVersionInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of ConfigTemplateVersionListResult class.
     */
    private ConfigTemplateVersionListResult() {
    }

    /**
     * Get the value property: The ConfigTemplateVersion items on this page.
     * 
     * @return the value value.
     */
    public List<ConfigTemplateVersionInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property value in model ConfigTemplateVersionListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ConfigTemplateVersionListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ConfigTemplateVersionListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ConfigTemplateVersionListResult if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ConfigTemplateVersionListResult.
     */
    public static ConfigTemplateVersionListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ConfigTemplateVersionListResult deserializedConfigTemplateVersionListResult
                = new ConfigTemplateVersionListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<ConfigTemplateVersionInner> value
                        = reader.readArray(reader1 -> ConfigTemplateVersionInner.fromJson(reader1));
                    deserializedConfigTemplateVersionListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedConfigTemplateVersionListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedConfigTemplateVersionListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/ContextListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a Context list operation.
 */
@Immutable
public final class ContextListResult implements JsonSerializable<ContextListResult> {
    /*
     * The Context items on this page
     */
    private List<ContextInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of ContextListResult class.
     */
    private ContextListResult() {
    }

    /**
     * Get the value property: The Context items on this page.
     * 
     * @return the value value.
     */
    public List<ContextInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model ContextListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ContextListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ContextListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ContextListResult if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ContextListResult.
     */
    public static ContextListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ContextListResult deserializedContextListResult = new ContextListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<ContextInner> value = reader.readArray(reader1 -> ContextInner.fromJson(reader1));
                    deserializedContextListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedContextListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedContextListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/DiagnosticListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a Diagnostic list operation.
 */
@Immutable
public final class DiagnosticListResult implements JsonSerializable<DiagnosticListResult> {
    /*
     * The Diagnostic items on this page
     */
    private List<DiagnosticInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of DiagnosticListResult class.
     */
    private DiagnosticListResult() {
    }

    /**
     * Get the value property: The Diagnostic items on this page.
     * 
     * @return the value value.
     */
    public List<DiagnosticInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model DiagnosticListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(DiagnosticListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DiagnosticListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DiagnosticListResult if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the DiagnosticListResult.
     */
    public static DiagnosticListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DiagnosticListResult deserializedDiagnosticListResult = new DiagnosticListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<DiagnosticInner> value = reader.readArray(reader1 -> DiagnosticInner.fromJson(reader1));
                    deserializedDiagnosticListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedDiagnosticListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDiagnosticListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/DynamicSchemaListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a DynamicSchema list operation.
 */
@Immutable
public final class DynamicSchemaListResult implements JsonSerializable<DynamicSchemaListResult> {
    /*
     * The DynamicSchema items on this page
     */
    private List<DynamicSchemaInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of DynamicSchemaListResult class.
     */
    private DynamicSchemaListResult() {
    }

    /**
     * Get the value property: The DynamicSchema items on this page.
     * 
     * @return the value value.
     */
    public List<DynamicSchemaInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model DynamicSchemaListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(DynamicSchemaListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DynamicSchemaListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DynamicSchemaListResult if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the DynamicSchemaListResult.
     */
    public static DynamicSchemaListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DynamicSchemaListResult deserializedDynamicSchemaListResult = new DynamicSchemaListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<DynamicSchemaInner> value = reader.readArray(reader1 -> DynamicSchemaInner.fromJson(reader1));
                    deserializedDynamicSchemaListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedDynamicSchemaListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDynamicSchemaListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/DynamicSchemaVersionListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a DynamicSchemaVersion list operation.
 */
@Immutable
public final class DynamicSchemaVersionListResult implements JsonSerializable<DynamicSchemaVersionListResult> {
    /*
     * The DynamicSchemaVersion items on this page
     */
    private List<DynamicSchemaVersionInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of DynamicSchemaVersionListResult class.
     */
    private DynamicSchemaVersionListResult() {
    }

    /**
     * Get the value property: The DynamicSchemaVersion items on this page.
     * 
     * @return the value value.
     */
    public List<DynamicSchemaVersionInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property value in model DynamicSchemaVersionListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(DynamicSchemaVersionListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DynamicSchemaVersionListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DynamicSchemaVersionListResult if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the DynamicSchemaVersionListResult.
     */
    public static DynamicSchemaVersionListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DynamicSchemaVersionListResult deserializedDynamicSchemaVersionListResult
                = new DynamicSchemaVersionListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<DynamicSchemaVersionInner> value
                        = reader.readArray(reader1 -> DynamicSchemaVersionInner.fromJson(reader1));
                    deserializedDynamicSchemaVersionListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedDynamicSchemaVersionListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDynamicSchemaVersionListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/ExecutionListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a Execution list operation.
 */
@Immutable
public final class ExecutionListResult implements JsonSerializable<ExecutionListResult> {
    /*
     * The Execution items on this page
     */
    private List<ExecutionInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of ExecutionListResult class.
     */
    private ExecutionListResult() {
    }

    /**
     * Get the value property: The Execution items on this page.
     * 
     * @return the value value.
     */
    public List<ExecutionInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model ExecutionListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ExecutionListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ExecutionListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ExecutionListResult if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ExecutionListResult.
     */
    public static ExecutionListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ExecutionListResult deserializedExecutionListResult = new ExecutionListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<ExecutionInner> value = reader.readArray(reader1 -> ExecutionInner.fromJson(reader1));
                    deserializedExecutionListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedExecutionListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedExecutionListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/InstanceHistoryListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a InstanceHistory list operation.
 */
@Immutable
public final class InstanceHistoryListResult implements JsonSerializable<InstanceHistoryListResult> {
    /*
     * The InstanceHistory items on this page
     */
    private List<InstanceHistoryInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of InstanceHistoryListResult class.
     */
    private InstanceHistoryListResult() {
    }

    /**
     * Get the value property: The InstanceHistory items on this page.
     * 
     * @return the value value.
     */
    public List<InstanceHistoryInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Missing required property value in model InstanceHistoryListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(InstanceHistoryListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of InstanceHistoryListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of InstanceHistoryListResult if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the InstanceHistoryListResult.
     */
    public static InstanceHistoryListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            InstanceHistoryListResult deserializedInstanceHistoryListResult = new InstanceHistoryListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<InstanceHistoryInner> value
                        = reader.readArray(reader1 -> InstanceHistoryInner.fromJson(reader1));
                    deserializedInstanceHistoryListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedInstanceHistoryListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedInstanceHistoryListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/InstanceListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a Instance list operation.
 */
@Immutable
public final class InstanceListResult implements JsonSerializable<InstanceListResult> {
    /*
     * The Instance items on this page
     */
    private List<InstanceInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of InstanceListResult class.
     */
    private InstanceListResult() {
    }

    /**
     * Get the value property: The Instance items on this page.
     * 
     * @return the value value.
     */
    public List<InstanceInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model InstanceListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(InstanceListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of InstanceListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of InstanceListResult if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the InstanceListResult.
     */
    public static InstanceListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            InstanceListResult deserializedInstanceListResult = new InstanceListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<InstanceInner> value = reader.readArray(reader1 -> InstanceInner.fromJson(reader1));
                    deserializedInstanceListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedInstanceListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedInstanceListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/JobListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.JobInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a Job list operation.
 */
@Immutable
public final class JobListResult implements JsonSerializable<JobListResult> {
    /*
     * The Job items on this page
     */
    private List<JobInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of JobListResult class.
     */
    private JobListResult() {
    }

    /**
     * Get the value property: The Job items on this page.
     * 
     * @return the value value.
     */
    public List<JobInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model JobListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(JobListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of JobListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of JobListResult if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the JobListResult.
     */
    public static JobListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            JobListResult deserializedJobListResult = new JobListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<JobInner> value = reader.readArray(reader1 -> JobInner.fromJson(reader1));
                    deserializedJobListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedJobListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedJobListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/SchemaListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a Schema list operation.
 */
@Immutable
public final class SchemaListResult implements JsonSerializable<SchemaListResult> {
    /*
     * The Schema items on this page
     */
    private List<SchemaInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of SchemaListResult class.
     */
    private SchemaListResult() {
    }

    /**
     * Get the value property: The Schema items on this page.
     * 
     * @return the value value.
     */
    public List<SchemaInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model SchemaListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemaListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaListResult if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaListResult.
     */
    public static SchemaListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaListResult deserializedSchemaListResult = new SchemaListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<SchemaInner> value = reader.readArray(reader1 -> SchemaInner.fromJson(reader1));
                    deserializedSchemaListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedSchemaListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/SchemaReferenceListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a SchemaReference list operation.
 */
@Immutable
public final class SchemaReferenceListResult implements JsonSerializable<SchemaReferenceListResult> {
    /*
     * The SchemaReference items on this page
     */
    private List<SchemaReferenceInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of SchemaReferenceListResult class.
     */
    private SchemaReferenceListResult() {
    }

    /**
     * Get the value property: The SchemaReference items on this page.
     * 
     * @return the value value.
     */
    public List<SchemaReferenceInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Missing required property value in model SchemaReferenceListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemaReferenceListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaReferenceListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaReferenceListResult if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaReferenceListResult.
     */
    public static SchemaReferenceListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaReferenceListResult deserializedSchemaReferenceListResult = new SchemaReferenceListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<SchemaReferenceInner> value
                        = reader.readArray(reader1 -> SchemaReferenceInner.fromJson(reader1));
                    deserializedSchemaReferenceListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedSchemaReferenceListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaReferenceListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/SchemaVersionListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a SchemaVersion list operation.
 */
@Immutable
public final class SchemaVersionListResult implements JsonSerializable<SchemaVersionListResult> {
    /*
     * The SchemaVersion items on this page
     */
    private List<SchemaVersionInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of SchemaVersionListResult class.
     */
    private SchemaVersionListResult() {
    }

    /**
     * Get the value property: The SchemaVersion items on this page.
     * 
     * @return the value value.
     */
    public List<SchemaVersionInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model SchemaVersionListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemaVersionListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaVersionListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaVersionListResult if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaVersionListResult.
     */
    public static SchemaVersionListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaVersionListResult deserializedSchemaVersionListResult = new SchemaVersionListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<SchemaVersionInner> value = reader.readArray(reader1 -> SchemaVersionInner.fromJson(reader1));
                    deserializedSchemaVersionListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedSchemaVersionListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaVersionListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/SiteReferenceListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a SiteReference list operation.
 */
@Immutable
public final class SiteReferenceListResult implements JsonSerializable<SiteReferenceListResult> {
    /*
     * The SiteReference items on this page
     */
    private List<SiteReferenceInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of SiteReferenceListResult class.
     */
    private SiteReferenceListResult() {
    }

    /**
     * Get the value property: The SiteReference items on this page.
     * 
     * @return the value value.
     */
    public List<SiteReferenceInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model SiteReferenceListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SiteReferenceListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SiteReferenceListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SiteReferenceListResult if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SiteReferenceListResult.
     */
    public static SiteReferenceListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SiteReferenceListResult deserializedSiteReferenceListResult = new SiteReferenceListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<SiteReferenceInner> value = reader.readArray(reader1 -> SiteReferenceInner.fromJson(reader1));
                    deserializedSiteReferenceListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedSiteReferenceListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSiteReferenceListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/SolutionListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a Solution list operation.
 */
@Immutable
public final class SolutionListResult implements JsonSerializable<SolutionListResult> {
    /*
     * The Solution items on this page
     */
    private List<SolutionInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of SolutionListResult class.
     */
    private SolutionListResult() {
    }

    /**
     * Get the value property: The Solution items on this page.
     * 
     * @return the value value.
     */
    public List<SolutionInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model SolutionListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionListResult if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionListResult.
     */
    public static SolutionListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionListResult deserializedSolutionListResult = new SolutionListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<SolutionInner> value = reader.readArray(reader1 -> SolutionInner.fromJson(reader1));
                    deserializedSolutionListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedSolutionListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/SolutionTemplateListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a SolutionTemplate list operation.
 */
@Immutable
public final class SolutionTemplateListResult implements JsonSerializable<SolutionTemplateListResult> {
    /*
     * The SolutionTemplate items on this page
     */
    private List<SolutionTemplateInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of SolutionTemplateListResult class.
     */
    private SolutionTemplateListResult() {
    }

    /**
     * Get the value property: The SolutionTemplate items on this page.
     * 
     * @return the value value.
     */
    public List<SolutionTemplateInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property value in model SolutionTemplateListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplateListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionTemplateListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionTemplateListResult if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionTemplateListResult.
     */
    public static SolutionTemplateListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionTemplateListResult deserializedSolutionTemplateListResult = new SolutionTemplateListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<SolutionTemplateInner> value
                        = reader.readArray(reader1 -> SolutionTemplateInner.fromJson(reader1));
                    deserializedSolutionTemplateListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedSolutionTemplateListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionTemplateListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/SolutionTemplateVersionListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a SolutionTemplateVersion list operation.
 */
@Immutable
public final class SolutionTemplateVersionListResult implements JsonSerializable<SolutionTemplateVersionListResult> {
    /*
     * The SolutionTemplateVersion items on this page
     */
    private List<SolutionTemplateVersionInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of SolutionTemplateVersionListResult class.
     */
    private SolutionTemplateVersionListResult() {
    }

    /**
     * Get the value property: The SolutionTemplateVersion items on this page.
     * 
     * @return the value value.
     */
    public List<SolutionTemplateVersionInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property value in model SolutionTemplateVersionListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplateVersionListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionTemplateVersionListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionTemplateVersionListResult if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionTemplateVersionListResult.
     */
    public static SolutionTemplateVersionListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionTemplateVersionListResult deserializedSolutionTemplateVersionListResult
                = new SolutionTemplateVersionListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<SolutionTemplateVersionInner> value
                        = reader.readArray(reader1 -> SolutionTemplateVersionInner.fromJson(reader1));
                    deserializedSolutionTemplateVersionListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedSolutionTemplateVersionListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionTemplateVersionListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/SolutionVersionListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a SolutionVersion list operation.
 */
@Immutable
public final class SolutionVersionListResult implements JsonSerializable<SolutionVersionListResult> {
    /*
     * The SolutionVersion items on this page
     */
    private List<SolutionVersionInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of SolutionVersionListResult class.
     */
    private SolutionVersionListResult() {
    }

    /**
     * Get the value property: The SolutionVersion items on this page.
     * 
     * @return the value value.
     */
    public List<SolutionVersionInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Missing required property value in model SolutionVersionListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionVersionListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionVersionListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionVersionListResult if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionVersionListResult.
     */
    public static SolutionVersionListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionVersionListResult deserializedSolutionVersionListResult = new SolutionVersionListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<SolutionVersionInner> value
                        = reader.readArray(reader1 -> SolutionVersionInner.fromJson(reader1));
                    deserializedSolutionVersionListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedSolutionVersionListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionVersionListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/TargetListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a Target list operation.
 */
@Immutable
public final class TargetListResult implements JsonSerializable<TargetListResult> {
    /*
     * The Target items on this page
     */
    private List<TargetInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of TargetListResult class.
     */
    private TargetListResult() {
    }

    /**
     * Get the value property: The Target items on this page.
     * 
     * @return the value value.
     */
    public List<TargetInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model TargetListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(TargetListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TargetListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TargetListResult if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TargetListResult.
     */
    public static TargetListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TargetListResult deserializedTargetListResult = new TargetListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<TargetInner> value = reader.readArray(reader1 -> TargetInner.fromJson(reader1));
                    deserializedTargetListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedTargetListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTargetListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/WorkflowListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a Workflow list operation.
 */
@Immutable
public final class WorkflowListResult implements JsonSerializable<WorkflowListResult> {
    /*
     * The Workflow items on this page
     */
    private List<WorkflowInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of WorkflowListResult class.
     */
    private WorkflowListResult() {
    }

    /**
     * Get the value property: The Workflow items on this page.
     * 
     * @return the value value.
     */
    public List<WorkflowInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model WorkflowListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(WorkflowListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of WorkflowListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of WorkflowListResult if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the WorkflowListResult.
     */
    public static WorkflowListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            WorkflowListResult deserializedWorkflowListResult = new WorkflowListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<WorkflowInner> value = reader.readArray(reader1 -> WorkflowInner.fromJson(reader1));
                    deserializedWorkflowListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedWorkflowListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedWorkflowListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/implementation/models/WorkflowVersionListResult.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.implementation.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner;
import java.io.IOException;
import java.util.List;

/**
 * The response of a WorkflowVersion list operation.
 */
@Immutable
public final class WorkflowVersionListResult implements JsonSerializable<WorkflowVersionListResult> {
    /*
     * The WorkflowVersion items on this page
     */
    private List<WorkflowVersionInner> value;

    /*
     * The link to the next page of items
     */
    private String nextLink;

    /**
     * Creates an instance of WorkflowVersionListResult class.
     */
    private WorkflowVersionListResult() {
    }

    /**
     * Get the value property: The WorkflowVersion items on this page.
     * 
     * @return the value value.
     */
    public List<WorkflowVersionInner> value() {
        return this.value;
    }

    /**
     * Get the nextLink property: The link to the next page of items.
     * 
     * @return the nextLink value.
     */
    public String nextLink() {
        return this.nextLink;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Missing required property value in model WorkflowVersionListResult"));
        } else {
            value().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(WorkflowVersionListResult.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("value", this.value, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("nextLink", this.nextLink);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of WorkflowVersionListResult from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of WorkflowVersionListResult if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the WorkflowVersionListResult.
     */
    public static WorkflowVersionListResult fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            WorkflowVersionListResult deserializedWorkflowVersionListResult = new WorkflowVersionListResult();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    List<WorkflowVersionInner> value
                        = reader.readArray(reader1 -> WorkflowVersionInner.fromJson(reader1));
                    deserializedWorkflowVersionListResult.value = value;
                } else if ("nextLink".equals(fieldName)) {
                    deserializedWorkflowVersionListResult.nextLink = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedWorkflowVersionListResult;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ActiveState.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Instance State.
 */
public final class ActiveState extends ExpandableStringEnum<ActiveState> {
    /**
     * Instance is active.
     */
    public static final ActiveState ACTIVE = fromString("active");

    /**
     * Instance is inactive.
     */
    public static final ActiveState INACTIVE = fromString("inactive");

    /**
     * Creates a new instance of ActiveState value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public ActiveState() {
    }

    /**
     * Creates or finds a ActiveState from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding ActiveState.
     */
    public static ActiveState fromString(String name) {
        return fromString(name, ActiveState.class);
    }

    /**
     * Gets known ActiveState values.
     * 
     * @return known ActiveState values.
     */
    public static Collection<ActiveState> values() {
        return values(ActiveState.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/AvailableSolutionTemplateVersion.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Available Solution template Version along with latest revision.
 */
@Immutable
public final class AvailableSolutionTemplateVersion implements JsonSerializable<AvailableSolutionTemplateVersion> {
    /*
     * Solution template Version
     */
    private String solutionTemplateVersion;

    /*
     * Latest Configuration Revision
     */
    private String latestConfigRevision;

    /*
     * Has this solution template version been configured
     */
    private boolean isConfigured;

    /**
     * Creates an instance of AvailableSolutionTemplateVersion class.
     */
    private AvailableSolutionTemplateVersion() {
    }

    /**
     * Get the solutionTemplateVersion property: Solution template Version.
     * 
     * @return the solutionTemplateVersion value.
     */
    public String solutionTemplateVersion() {
        return this.solutionTemplateVersion;
    }

    /**
     * Get the latestConfigRevision property: Latest Configuration Revision.
     * 
     * @return the latestConfigRevision value.
     */
    public String latestConfigRevision() {
        return this.latestConfigRevision;
    }

    /**
     * Get the isConfigured property: Has this solution template version been configured.
     * 
     * @return the isConfigured value.
     */
    public boolean isConfigured() {
        return this.isConfigured;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionTemplateVersion() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionTemplateVersion in model AvailableSolutionTemplateVersion"));
        }
        if (latestConfigRevision() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property latestConfigRevision in model AvailableSolutionTemplateVersion"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(AvailableSolutionTemplateVersion.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionTemplateVersion", this.solutionTemplateVersion);
        jsonWriter.writeStringField("latestConfigRevision", this.latestConfigRevision);
        jsonWriter.writeBooleanField("isConfigured", this.isConfigured);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AvailableSolutionTemplateVersion from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AvailableSolutionTemplateVersion if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the AvailableSolutionTemplateVersion.
     */
    public static AvailableSolutionTemplateVersion fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            AvailableSolutionTemplateVersion deserializedAvailableSolutionTemplateVersion
                = new AvailableSolutionTemplateVersion();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionTemplateVersion".equals(fieldName)) {
                    deserializedAvailableSolutionTemplateVersion.solutionTemplateVersion = reader.getString();
                } else if ("latestConfigRevision".equals(fieldName)) {
                    deserializedAvailableSolutionTemplateVersion.latestConfigRevision = reader.getString();
                } else if ("isConfigured".equals(fieldName)) {
                    deserializedAvailableSolutionTemplateVersion.isConfigured = reader.getBoolean();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedAvailableSolutionTemplateVersion;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/BulkDeploySolutionParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Bulk deploy solution parameter.
 */
@Fluent
public final class BulkDeploySolutionParameter implements JsonSerializable<BulkDeploySolutionParameter> {
    /*
     * Targets to which solution needs to be deployed
     */
    private List<BulkDeployTargetDetails> targets;

    /**
     * Creates an instance of BulkDeploySolutionParameter class.
     */
    public BulkDeploySolutionParameter() {
    }

    /**
     * Get the targets property: Targets to which solution needs to be deployed.
     * 
     * @return the targets value.
     */
    public List<BulkDeployTargetDetails> targets() {
        return this.targets;
    }

    /**
     * Set the targets property: Targets to which solution needs to be deployed.
     * 
     * @param targets the targets value to set.
     * @return the BulkDeploySolutionParameter object itself.
     */
    public BulkDeploySolutionParameter withTargets(List<BulkDeployTargetDetails> targets) {
        this.targets = targets;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (targets() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property targets in model BulkDeploySolutionParameter"));
        } else {
            targets().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(BulkDeploySolutionParameter.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("targets", this.targets, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BulkDeploySolutionParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of BulkDeploySolutionParameter if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the BulkDeploySolutionParameter.
     */
    public static BulkDeploySolutionParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            BulkDeploySolutionParameter deserializedBulkDeploySolutionParameter = new BulkDeploySolutionParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("targets".equals(fieldName)) {
                    List<BulkDeployTargetDetails> targets
                        = reader.readArray(reader1 -> BulkDeployTargetDetails.fromJson(reader1));
                    deserializedBulkDeploySolutionParameter.targets = targets;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedBulkDeploySolutionParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/BulkDeployTargetDetails.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Bulk deploy target details.
 */
@Fluent
public final class BulkDeployTargetDetails implements JsonSerializable<BulkDeployTargetDetails> {
    /*
     * ArmId of Target Solution Version
     */
    private String solutionVersionId;

    /**
     * Creates an instance of BulkDeployTargetDetails class.
     */
    public BulkDeployTargetDetails() {
    }

    /**
     * Get the solutionVersionId property: ArmId of Target Solution Version.
     * 
     * @return the solutionVersionId value.
     */
    public String solutionVersionId() {
        return this.solutionVersionId;
    }

    /**
     * Set the solutionVersionId property: ArmId of Target Solution Version.
     * 
     * @param solutionVersionId the solutionVersionId value to set.
     * @return the BulkDeployTargetDetails object itself.
     */
    public BulkDeployTargetDetails withSolutionVersionId(String solutionVersionId) {
        this.solutionVersionId = solutionVersionId;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionVersionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionVersionId in model BulkDeployTargetDetails"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(BulkDeployTargetDetails.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionVersionId", this.solutionVersionId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BulkDeployTargetDetails from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of BulkDeployTargetDetails if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the BulkDeployTargetDetails.
     */
    public static BulkDeployTargetDetails fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            BulkDeployTargetDetails deserializedBulkDeployTargetDetails = new BulkDeployTargetDetails();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionVersionId".equals(fieldName)) {
                    deserializedBulkDeployTargetDetails.solutionVersionId = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedBulkDeployTargetDetails;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/BulkPublishSolutionParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Bulk publish solution parameter.
 */
@Fluent
public final class BulkPublishSolutionParameter implements JsonSerializable<BulkPublishSolutionParameter> {
    /*
     * Targets to which solution needs to be published
     */
    private List<BulkPublishTargetDetails> targets;

    /*
     * Name of the solution instance
     */
    private String solutionInstanceName;

    /*
     * Solution dependencies
     */
    private List<SolutionDependencyParameter> solutionDependencies;

    /**
     * Creates an instance of BulkPublishSolutionParameter class.
     */
    public BulkPublishSolutionParameter() {
    }

    /**
     * Get the targets property: Targets to which solution needs to be published.
     * 
     * @return the targets value.
     */
    public List<BulkPublishTargetDetails> targets() {
        return this.targets;
    }

    /**
     * Set the targets property: Targets to which solution needs to be published.
     * 
     * @param targets the targets value to set.
     * @return the BulkPublishSolutionParameter object itself.
     */
    public BulkPublishSolutionParameter withTargets(List<BulkPublishTargetDetails> targets) {
        this.targets = targets;
        return this;
    }

    /**
     * Get the solutionInstanceName property: Name of the solution instance.
     * 
     * @return the solutionInstanceName value.
     */
    public String solutionInstanceName() {
        return this.solutionInstanceName;
    }

    /**
     * Set the solutionInstanceName property: Name of the solution instance.
     * 
     * @param solutionInstanceName the solutionInstanceName value to set.
     * @return the BulkPublishSolutionParameter object itself.
     */
    public BulkPublishSolutionParameter withSolutionInstanceName(String solutionInstanceName) {
        this.solutionInstanceName = solutionInstanceName;
        return this;
    }

    /**
     * Get the solutionDependencies property: Solution dependencies.
     * 
     * @return the solutionDependencies value.
     */
    public List<SolutionDependencyParameter> solutionDependencies() {
        return this.solutionDependencies;
    }

    /**
     * Set the solutionDependencies property: Solution dependencies.
     * 
     * @param solutionDependencies the solutionDependencies value to set.
     * @return the BulkPublishSolutionParameter object itself.
     */
    public BulkPublishSolutionParameter
        withSolutionDependencies(List<SolutionDependencyParameter> solutionDependencies) {
        this.solutionDependencies = solutionDependencies;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (targets() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property targets in model BulkPublishSolutionParameter"));
        } else {
            targets().forEach(e -> e.validate());
        }
        if (solutionDependencies() != null) {
            solutionDependencies().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(BulkPublishSolutionParameter.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("targets", this.targets, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("solutionInstanceName", this.solutionInstanceName);
        jsonWriter.writeArrayField("solutionDependencies", this.solutionDependencies,
            (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BulkPublishSolutionParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of BulkPublishSolutionParameter if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the BulkPublishSolutionParameter.
     */
    public static BulkPublishSolutionParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            BulkPublishSolutionParameter deserializedBulkPublishSolutionParameter = new BulkPublishSolutionParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("targets".equals(fieldName)) {
                    List<BulkPublishTargetDetails> targets
                        = reader.readArray(reader1 -> BulkPublishTargetDetails.fromJson(reader1));
                    deserializedBulkPublishSolutionParameter.targets = targets;
                } else if ("solutionInstanceName".equals(fieldName)) {
                    deserializedBulkPublishSolutionParameter.solutionInstanceName = reader.getString();
                } else if ("solutionDependencies".equals(fieldName)) {
                    List<SolutionDependencyParameter> solutionDependencies
                        = reader.readArray(reader1 -> SolutionDependencyParameter.fromJson(reader1));
                    deserializedBulkPublishSolutionParameter.solutionDependencies = solutionDependencies;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedBulkPublishSolutionParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/BulkPublishTargetDetails.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Bulk publish target details.
 */
@Fluent
public final class BulkPublishTargetDetails implements JsonSerializable<BulkPublishTargetDetails> {
    /*
     * ArmId of Target
     */
    private String targetId;

    /*
     * Name of the solution instance
     */
    private String solutionInstanceName;

    /**
     * Creates an instance of BulkPublishTargetDetails class.
     */
    public BulkPublishTargetDetails() {
    }

    /**
     * Get the targetId property: ArmId of Target.
     * 
     * @return the targetId value.
     */
    public String targetId() {
        return this.targetId;
    }

    /**
     * Set the targetId property: ArmId of Target.
     * 
     * @param targetId the targetId value to set.
     * @return the BulkPublishTargetDetails object itself.
     */
    public BulkPublishTargetDetails withTargetId(String targetId) {
        this.targetId = targetId;
        return this;
    }

    /**
     * Get the solutionInstanceName property: Name of the solution instance.
     * 
     * @return the solutionInstanceName value.
     */
    public String solutionInstanceName() {
        return this.solutionInstanceName;
    }

    /**
     * Set the solutionInstanceName property: Name of the solution instance.
     * 
     * @param solutionInstanceName the solutionInstanceName value to set.
     * @return the BulkPublishTargetDetails object itself.
     */
    public BulkPublishTargetDetails withSolutionInstanceName(String solutionInstanceName) {
        this.solutionInstanceName = solutionInstanceName;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (targetId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property targetId in model BulkPublishTargetDetails"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(BulkPublishTargetDetails.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("targetId", this.targetId);
        jsonWriter.writeStringField("solutionInstanceName", this.solutionInstanceName);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BulkPublishTargetDetails from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of BulkPublishTargetDetails if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the BulkPublishTargetDetails.
     */
    public static BulkPublishTargetDetails fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            BulkPublishTargetDetails deserializedBulkPublishTargetDetails = new BulkPublishTargetDetails();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("targetId".equals(fieldName)) {
                    deserializedBulkPublishTargetDetails.targetId = reader.getString();
                } else if ("solutionInstanceName".equals(fieldName)) {
                    deserializedBulkPublishTargetDetails.solutionInstanceName = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedBulkPublishTargetDetails;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Capability.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Capability, to match in Solution Templates &amp; Targets.
 */
@Fluent
public final class Capability implements JsonSerializable<Capability> {
    /*
     * Name of Capability
     */
    private String name;

    /*
     * Description of Capability
     */
    private String description;

    /*
     * State of resource
     */
    private ResourceState state;

    /**
     * Creates an instance of Capability class.
     */
    public Capability() {
    }

    /**
     * Get the name property: Name of Capability.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Set the name property: Name of Capability.
     * 
     * @param name the name value to set.
     * @return the Capability object itself.
     */
    public Capability withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the description property: Description of Capability.
     * 
     * @return the description value.
     */
    public String description() {
        return this.description;
    }

    /**
     * Set the description property: Description of Capability.
     * 
     * @param description the description value to set.
     * @return the Capability object itself.
     */
    public Capability withDescription(String description) {
        this.description = description;
        return this;
    }

    /**
     * Get the state property: State of resource.
     * 
     * @return the state value.
     */
    public ResourceState state() {
        return this.state;
    }

    /**
     * Set the state property: State of resource.
     * 
     * @param state the state value to set.
     * @return the Capability object itself.
     */
    public Capability withState(ResourceState state) {
        this.state = state;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (name() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property name in model Capability"));
        }
        if (description() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property description in model Capability"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(Capability.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("description", this.description);
        jsonWriter.writeStringField("state", this.state == null ? null : this.state.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Capability from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Capability if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the Capability.
     */
    public static Capability fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            Capability deserializedCapability = new Capability();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedCapability.name = reader.getString();
                } else if ("description".equals(fieldName)) {
                    deserializedCapability.description = reader.getString();
                } else if ("state".equals(fieldName)) {
                    deserializedCapability.state = ResourceState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedCapability;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ComponentStatus.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Component Status.
 */
@Immutable
public final class ComponentStatus implements JsonSerializable<ComponentStatus> {
    /*
     * Component name
     */
    private String name;

    /*
     * Component status
     */
    private String status;

    /**
     * Creates an instance of ComponentStatus class.
     */
    private ComponentStatus() {
    }

    /**
     * Get the name property: Component name.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Get the status property: Component status.
     * 
     * @return the status value.
     */
    public String status() {
        return this.status;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("status", this.status);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ComponentStatus from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ComponentStatus if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the ComponentStatus.
     */
    public static ComponentStatus fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ComponentStatus deserializedComponentStatus = new ComponentStatus();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedComponentStatus.name = reader.getString();
                } else if ("status".equals(fieldName)) {
                    deserializedComponentStatus.status = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedComponentStatus;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ConfigTemplate.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.Response;
import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import java.util.Map;

/**
 * An immutable client-side representation of ConfigTemplate.
 */
public interface ConfigTemplate {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the location property: The geo-location where the resource lives.
     * 
     * @return the location value.
     */
    String location();

    /**
     * Gets the tags property: Resource tags.
     * 
     * @return the tags value.
     */
    Map<String, String> tags();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    ConfigTemplateProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the region of the resource.
     * 
     * @return the region of the resource.
     */
    Region region();

    /**
     * Gets the name of the resource region.
     * 
     * @return the name of the resource region.
     */
    String regionName();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner object.
     * 
     * @return the inner object.
     */
    ConfigTemplateInner innerModel();

    /**
     * The entirety of the ConfigTemplate definition.
     */
    interface Definition extends DefinitionStages.Blank, DefinitionStages.WithLocation,
        DefinitionStages.WithResourceGroup, DefinitionStages.WithCreate {
    }

    /**
     * The ConfigTemplate definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the ConfigTemplate definition.
         */
        interface Blank extends WithLocation {
        }

        /**
         * The stage of the ConfigTemplate definition allowing to specify location.
         */
        interface WithLocation {
            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(Region location);

            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(String location);
        }

        /**
         * The stage of the ConfigTemplate definition allowing to specify parent resource.
         */
        interface WithResourceGroup {
            /**
             * Specifies resourceGroupName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @return the next definition stage.
             */
            WithCreate withExistingResourceGroup(String resourceGroupName);
        }

        /**
         * The stage of the ConfigTemplate definition which contains all the minimum required properties for the
         * resource to be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithTags, DefinitionStages.WithProperties {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            ConfigTemplate create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            ConfigTemplate create(Context context);
        }

        /**
         * The stage of the ConfigTemplate definition allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            WithCreate withTags(Map<String, String> tags);
        }

        /**
         * The stage of the ConfigTemplate definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(ConfigTemplateProperties properties);
        }
    }

    /**
     * Begins update for the ConfigTemplate resource.
     * 
     * @return the stage of resource update.
     */
    ConfigTemplate.Update update();

    /**
     * The template for ConfigTemplate update.
     */
    interface Update extends UpdateStages.WithTags, UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        ConfigTemplate apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        ConfigTemplate apply(Context context);
    }

    /**
     * The ConfigTemplate update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the ConfigTemplate update allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            Update withTags(Map<String, String> tags);
        }

        /**
         * The stage of the ConfigTemplate update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(ConfigTemplateProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    ConfigTemplate refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    ConfigTemplate refresh(Context context);

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    ConfigTemplateVersion createVersion(ConfigTemplateVersionWithUpdateTypeInner body);

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    ConfigTemplateVersion createVersion(ConfigTemplateVersionWithUpdateTypeInner body, Context context);

    /**
     * Remove Config Template Version Resource.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response}.
     */
    Response<RemoveVersionResponse> removeVersionWithResponse(VersionParameter body, Context context);

    /**
     * Remove Config Template Version Resource.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response.
     */
    RemoveVersionResponse removeVersion(VersionParameter body);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ConfigTemplateProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Config Template Properties.
 */
@Fluent
public final class ConfigTemplateProperties implements JsonSerializable<ConfigTemplateProperties> {
    /*
     * Description of config template
     */
    private String description;

    /*
     * Latest config template version
     */
    private String latestVersion;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of ConfigTemplateProperties class.
     */
    public ConfigTemplateProperties() {
    }

    /**
     * Get the description property: Description of config template.
     * 
     * @return the description value.
     */
    public String description() {
        return this.description;
    }

    /**
     * Set the description property: Description of config template.
     * 
     * @param description the description value to set.
     * @return the ConfigTemplateProperties object itself.
     */
    public ConfigTemplateProperties withDescription(String description) {
        this.description = description;
        return this;
    }

    /**
     * Get the latestVersion property: Latest config template version.
     * 
     * @return the latestVersion value.
     */
    public String latestVersion() {
        return this.latestVersion;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (description() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property description in model ConfigTemplateProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ConfigTemplateProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("description", this.description);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ConfigTemplateProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ConfigTemplateProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ConfigTemplateProperties.
     */
    public static ConfigTemplateProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ConfigTemplateProperties deserializedConfigTemplateProperties = new ConfigTemplateProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("description".equals(fieldName)) {
                    deserializedConfigTemplateProperties.description = reader.getString();
                } else if ("latestVersion".equals(fieldName)) {
                    deserializedConfigTemplateProperties.latestVersion = reader.getString();
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedConfigTemplateProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedConfigTemplateProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ConfigTemplates.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;

/**
 * Resource collection API of ConfigTemplates.
 */
public interface ConfigTemplates {
    /**
     * Get a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource along with {@link Response}.
     */
    Response<ConfigTemplate> getByResourceGroupWithResponse(String resourceGroupName, String configTemplateName,
        Context context);

    /**
     * Get a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource.
     */
    ConfigTemplate getByResourceGroup(String resourceGroupName, String configTemplateName);

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    ConfigTemplateVersion createVersion(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body);

    /**
     * Create or update a Config Template Version Resource with the specified UpdateType.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    ConfigTemplateVersion createVersion(String resourceGroupName, String configTemplateName,
        ConfigTemplateVersionWithUpdateTypeInner body, Context context);

    /**
     * Remove Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response}.
     */
    Response<RemoveVersionResponse> removeVersionWithResponse(String resourceGroupName, String configTemplateName,
        VersionParameter body, Context context);

    /**
     * Remove Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response.
     */
    RemoveVersionResponse removeVersion(String resourceGroupName, String configTemplateName, VersionParameter body);

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByResourceGroup(String resourceGroupName, String configTemplateName);

    /**
     * Delete a Config Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String configTemplateName, Context context);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ConfigTemplate> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ConfigTemplate> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ConfigTemplate> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplate list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ConfigTemplate> list(Context context);

    /**
     * Get a Config Template Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource along with {@link Response}.
     */
    ConfigTemplate getById(String id);

    /**
     * Get a Config Template Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Resource along with {@link Response}.
     */
    Response<ConfigTemplate> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Config Template Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Config Template Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new ConfigTemplate resource.
     * 
     * @param name resource name.
     * @return the first stage of the new ConfigTemplate definition.
     */
    ConfigTemplate.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ConfigTemplateVersion.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;

/**
 * An immutable client-side representation of ConfigTemplateVersion.
 */
public interface ConfigTemplateVersion {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    ConfigTemplateVersionProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner object.
     * 
     * @return the inner object.
     */
    ConfigTemplateVersionInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ConfigTemplateVersionProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Config Template Version Properties.
 */
@Fluent
public final class ConfigTemplateVersionProperties implements JsonSerializable<ConfigTemplateVersionProperties> {
    /*
     * Configuration values
     */
    private String configurations;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of ConfigTemplateVersionProperties class.
     */
    public ConfigTemplateVersionProperties() {
    }

    /**
     * Get the configurations property: Configuration values.
     * 
     * @return the configurations value.
     */
    public String configurations() {
        return this.configurations;
    }

    /**
     * Set the configurations property: Configuration values.
     * 
     * @param configurations the configurations value to set.
     * @return the ConfigTemplateVersionProperties object itself.
     */
    public ConfigTemplateVersionProperties withConfigurations(String configurations) {
        this.configurations = configurations;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (configurations() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property configurations in model ConfigTemplateVersionProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ConfigTemplateVersionProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("configurations", this.configurations);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ConfigTemplateVersionProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ConfigTemplateVersionProperties if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ConfigTemplateVersionProperties.
     */
    public static ConfigTemplateVersionProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ConfigTemplateVersionProperties deserializedConfigTemplateVersionProperties
                = new ConfigTemplateVersionProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("configurations".equals(fieldName)) {
                    deserializedConfigTemplateVersionProperties.configurations = reader.getString();
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedConfigTemplateVersionProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedConfigTemplateVersionProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ConfigTemplateVersions.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of ConfigTemplateVersions.
 */
public interface ConfigTemplateVersions {
    /**
     * Get a Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param configTemplateVersionName The name of the ConfigTemplateVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Version Resource along with {@link Response}.
     */
    Response<ConfigTemplateVersion> getWithResponse(String resourceGroupName, String configTemplateName,
        String configTemplateVersionName, Context context);

    /**
     * Get a Config Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param configTemplateVersionName The name of the ConfigTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Config Template Version Resource.
     */
    ConfigTemplateVersion get(String resourceGroupName, String configTemplateName, String configTemplateVersionName);

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ConfigTemplateVersion> listByConfigTemplate(String resourceGroupName, String configTemplateName);

    /**
     * List Config Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param configTemplateName The name of the ConfigTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a ConfigTemplateVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ConfigTemplateVersion> listByConfigTemplate(String resourceGroupName, String configTemplateName,
        Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ConfigTemplateVersionWithUpdateType.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;

/**
 * An immutable client-side representation of ConfigTemplateVersionWithUpdateType.
 */
public interface ConfigTemplateVersionWithUpdateType {
    /**
     * Gets the updateType property: Update type.
     * 
     * @return the updateType value.
     */
    UpdateType updateType();

    /**
     * Gets the version property: Version to create.
     * 
     * @return the version value.
     */
    String version();

    /**
     * Gets the configTemplateVersion property: Config Template Version.
     * 
     * @return the configTemplateVersion value.
     */
    ConfigTemplateVersion configTemplateVersion();

    /**
     * Gets the inner
     * com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner object.
     * 
     * @return the inner object.
     */
    ConfigTemplateVersionWithUpdateTypeInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ConfigurationModel.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Available configuration models.
 */
public final class ConfigurationModel extends ExpandableStringEnum<ConfigurationModel> {
    /**
     * Configuration model Application.
     */
    public static final ConfigurationModel APPLICATION = fromString("Application");

    /**
     * Configuration model Common.
     */
    public static final ConfigurationModel COMMON = fromString("Common");

    /**
     * Creates a new instance of ConfigurationModel value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public ConfigurationModel() {
    }

    /**
     * Creates or finds a ConfigurationModel from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding ConfigurationModel.
     */
    public static ConfigurationModel fromString(String name) {
        return fromString(name, ConfigurationModel.class);
    }

    /**
     * Gets known ConfigurationModel values.
     * 
     * @return known ConfigurationModel values.
     */
    public static Collection<ConfigurationModel> values() {
        return values(ConfigurationModel.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ConfigurationType.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Available configuration types.
 */
public final class ConfigurationType extends ExpandableStringEnum<ConfigurationType> {
    /**
     * Configuration type Shared.
     */
    public static final ConfigurationType SHARED = fromString("Shared");

    /**
     * Configuration type Hierarchy.
     */
    public static final ConfigurationType HIERARCHY = fromString("Hierarchy");

    /**
     * Creates a new instance of ConfigurationType value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public ConfigurationType() {
    }

    /**
     * Creates or finds a ConfigurationType from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding ConfigurationType.
     */
    public static ConfigurationType fromString(String name) {
        return fromString(name, ConfigurationType.class);
    }

    /**
     * Gets known ConfigurationType values.
     * 
     * @return known ConfigurationType values.
     */
    public static Collection<ConfigurationType> values() {
        return values(ConfigurationType.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ContextModel.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner;
import java.util.Map;

/**
 * An immutable client-side representation of ContextModel.
 */
public interface ContextModel {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the location property: The geo-location where the resource lives.
     * 
     * @return the location value.
     */
    String location();

    /**
     * Gets the tags property: Resource tags.
     * 
     * @return the tags value.
     */
    Map<String, String> tags();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    ContextProperties properties();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the region of the resource.
     * 
     * @return the region of the resource.
     */
    Region region();

    /**
     * Gets the name of the resource region.
     * 
     * @return the name of the resource region.
     */
    String regionName();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner object.
     * 
     * @return the inner object.
     */
    ContextInner innerModel();

    /**
     * The entirety of the ContextModel definition.
     */
    interface Definition extends DefinitionStages.Blank, DefinitionStages.WithLocation,
        DefinitionStages.WithResourceGroup, DefinitionStages.WithCreate {
    }

    /**
     * The ContextModel definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the ContextModel definition.
         */
        interface Blank extends WithLocation {
        }

        /**
         * The stage of the ContextModel definition allowing to specify location.
         */
        interface WithLocation {
            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(Region location);

            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(String location);
        }

        /**
         * The stage of the ContextModel definition allowing to specify parent resource.
         */
        interface WithResourceGroup {
            /**
             * Specifies resourceGroupName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @return the next definition stage.
             */
            WithCreate withExistingResourceGroup(String resourceGroupName);
        }

        /**
         * The stage of the ContextModel definition which contains all the minimum required properties for the resource
         * to be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithTags, DefinitionStages.WithProperties {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            ContextModel create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            ContextModel create(Context context);
        }

        /**
         * The stage of the ContextModel definition allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            WithCreate withTags(Map<String, String> tags);
        }

        /**
         * The stage of the ContextModel definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(ContextProperties properties);
        }
    }

    /**
     * Begins update for the ContextModel resource.
     * 
     * @return the stage of resource update.
     */
    ContextModel.Update update();

    /**
     * The template for ContextModel update.
     */
    interface Update extends UpdateStages.WithTags, UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        ContextModel apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        ContextModel apply(Context context);
    }

    /**
     * The ContextModel update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the ContextModel update allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            Update withTags(Map<String, String> tags);
        }

        /**
         * The stage of the ContextModel update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(ContextProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    ContextModel refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    ContextModel refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ContextProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Context Properties.
 */
@Fluent
public final class ContextProperties implements JsonSerializable<ContextProperties> {
    /*
     * List of Capabilities
     */
    private List<Capability> capabilities;

    /*
     * List of Hierarchies
     */
    private List<Hierarchy> hierarchies;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of ContextProperties class.
     */
    public ContextProperties() {
    }

    /**
     * Get the capabilities property: List of Capabilities.
     * 
     * @return the capabilities value.
     */
    public List<Capability> capabilities() {
        return this.capabilities;
    }

    /**
     * Set the capabilities property: List of Capabilities.
     * 
     * @param capabilities the capabilities value to set.
     * @return the ContextProperties object itself.
     */
    public ContextProperties withCapabilities(List<Capability> capabilities) {
        this.capabilities = capabilities;
        return this;
    }

    /**
     * Get the hierarchies property: List of Hierarchies.
     * 
     * @return the hierarchies value.
     */
    public List<Hierarchy> hierarchies() {
        return this.hierarchies;
    }

    /**
     * Set the hierarchies property: List of Hierarchies.
     * 
     * @param hierarchies the hierarchies value to set.
     * @return the ContextProperties object itself.
     */
    public ContextProperties withHierarchies(List<Hierarchy> hierarchies) {
        this.hierarchies = hierarchies;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (capabilities() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property capabilities in model ContextProperties"));
        } else {
            capabilities().forEach(e -> e.validate());
        }
        if (hierarchies() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property hierarchies in model ContextProperties"));
        } else {
            hierarchies().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ContextProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("capabilities", this.capabilities, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("hierarchies", this.hierarchies, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ContextProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ContextProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ContextProperties.
     */
    public static ContextProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ContextProperties deserializedContextProperties = new ContextProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("capabilities".equals(fieldName)) {
                    List<Capability> capabilities = reader.readArray(reader1 -> Capability.fromJson(reader1));
                    deserializedContextProperties.capabilities = capabilities;
                } else if ("hierarchies".equals(fieldName)) {
                    List<Hierarchy> hierarchies = reader.readArray(reader1 -> Hierarchy.fromJson(reader1));
                    deserializedContextProperties.hierarchies = hierarchies;
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedContextProperties.provisioningState = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedContextProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Contexts.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of Contexts.
 */
public interface Contexts {
    /**
     * Get Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response}.
     */
    Response<ContextModel> getByResourceGroupWithResponse(String resourceGroupName, String contextName,
        Context context);

    /**
     * Get Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource.
     */
    ContextModel getByResourceGroup(String resourceGroupName, String contextName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ContextModel> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ContextModel> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ContextModel> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Context list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<ContextModel> list(Context context);

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByResourceGroup(String resourceGroupName, String contextName);

    /**
     * Delete Context Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String contextName, Context context);

    /**
     * Get Context Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response}.
     */
    ContextModel getById(String id);

    /**
     * Get Context Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return context Resource along with {@link Response}.
     */
    Response<ContextModel> getByIdWithResponse(String id, Context context);

    /**
     * Delete Context Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete Context Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new ContextModel resource.
     * 
     * @param name resource name.
     * @return the first stage of the new ContextModel definition.
     */
    ContextModel.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/DeployJobParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Parameters for a deployment job.
 */
@Immutable
public final class DeployJobParameter extends JobParameterBase {
    /*
     * Job type discriminator value
     */
    private JobType jobType = JobType.DEPLOY;

    /*
     * The parameter property.
     */
    private InstallSolutionParameter parameter;

    /**
     * Creates an instance of DeployJobParameter class.
     */
    private DeployJobParameter() {
    }

    /**
     * Get the jobType property: Job type discriminator value.
     * 
     * @return the jobType value.
     */
    @Override
    public JobType jobType() {
        return this.jobType;
    }

    /**
     * Get the parameter property: The parameter property.
     * 
     * @return the parameter value.
     */
    public InstallSolutionParameter parameter() {
        return this.parameter;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
        if (parameter() != null) {
            parameter().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("jobType", this.jobType == null ? null : this.jobType.toString());
        jsonWriter.writeJsonField("parameter", this.parameter);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DeployJobParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DeployJobParameter if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the DeployJobParameter.
     */
    public static DeployJobParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DeployJobParameter deserializedDeployJobParameter = new DeployJobParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("jobType".equals(fieldName)) {
                    deserializedDeployJobParameter.jobType = JobType.fromString(reader.getString());
                } else if ("parameter".equals(fieldName)) {
                    deserializedDeployJobParameter.parameter = InstallSolutionParameter.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDeployJobParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/DeployJobStepStatistics.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Deploy statistics for a job step, including total, success, and failed counts.
 */
@Immutable
public final class DeployJobStepStatistics extends JobStepStatisticsBase {
    /*
     * Statistics type discriminator value
     */
    private JobType statisticsType = JobType.DEPLOY;

    /*
     * Total count of items processed in this step
     */
    private Integer totalCount;

    /*
     * Count of successful items in this step
     */
    private Integer successCount;

    /*
     * Count of failed items in this step
     */
    private Integer failedCount;

    /**
     * Creates an instance of DeployJobStepStatistics class.
     */
    private DeployJobStepStatistics() {
    }

    /**
     * Get the statisticsType property: Statistics type discriminator value.
     * 
     * @return the statisticsType value.
     */
    @Override
    public JobType statisticsType() {
        return this.statisticsType;
    }

    /**
     * Get the totalCount property: Total count of items processed in this step.
     * 
     * @return the totalCount value.
     */
    public Integer totalCount() {
        return this.totalCount;
    }

    /**
     * Get the successCount property: Count of successful items in this step.
     * 
     * @return the successCount value.
     */
    public Integer successCount() {
        return this.successCount;
    }

    /**
     * Get the failedCount property: Count of failed items in this step.
     * 
     * @return the failedCount value.
     */
    public Integer failedCount() {
        return this.failedCount;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("statisticsType",
            this.statisticsType == null ? null : this.statisticsType.toString());
        jsonWriter.writeNumberField("totalCount", this.totalCount);
        jsonWriter.writeNumberField("successCount", this.successCount);
        jsonWriter.writeNumberField("failedCount", this.failedCount);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DeployJobStepStatistics from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DeployJobStepStatistics if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the DeployJobStepStatistics.
     */
    public static DeployJobStepStatistics fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DeployJobStepStatistics deserializedDeployJobStepStatistics = new DeployJobStepStatistics();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("statisticsType".equals(fieldName)) {
                    deserializedDeployJobStepStatistics.statisticsType = JobType.fromString(reader.getString());
                } else if ("totalCount".equals(fieldName)) {
                    deserializedDeployJobStepStatistics.totalCount = reader.getNullable(JsonReader::getInt);
                } else if ("successCount".equals(fieldName)) {
                    deserializedDeployJobStepStatistics.successCount = reader.getNullable(JsonReader::getInt);
                } else if ("failedCount".equals(fieldName)) {
                    deserializedDeployJobStepStatistics.failedCount = reader.getNullable(JsonReader::getInt);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDeployJobStepStatistics;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/DeploymentStatus.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Deployment Status.
 */
@Immutable
public final class DeploymentStatus implements JsonSerializable<DeploymentStatus> {
    /*
     * The lastModified of the Status
     */
    private OffsetDateTime lastModified;

    /*
     * Indicates if Instance is deployed
     */
    private Integer deployed;

    /*
     * The expected running job id
     */
    private Integer expectedRunningJobId;

    /*
     * The running job id
     */
    private Integer runningJobId;

    /*
     * Deployment status
     */
    private String status;

    /*
     * Status details
     */
    private String statusDetails;

    /*
     * Deployment Generation
     */
    private Integer generation;

    /*
     * Target resource statuses
     */
    private List<TargetStatus> targetStatuses;

    /**
     * Creates an instance of DeploymentStatus class.
     */
    private DeploymentStatus() {
    }

    /**
     * Get the lastModified property: The lastModified of the Status.
     * 
     * @return the lastModified value.
     */
    public OffsetDateTime lastModified() {
        return this.lastModified;
    }

    /**
     * Get the deployed property: Indicates if Instance is deployed.
     * 
     * @return the deployed value.
     */
    public Integer deployed() {
        return this.deployed;
    }

    /**
     * Get the expectedRunningJobId property: The expected running job id.
     * 
     * @return the expectedRunningJobId value.
     */
    public Integer expectedRunningJobId() {
        return this.expectedRunningJobId;
    }

    /**
     * Get the runningJobId property: The running job id.
     * 
     * @return the runningJobId value.
     */
    public Integer runningJobId() {
        return this.runningJobId;
    }

    /**
     * Get the status property: Deployment status.
     * 
     * @return the status value.
     */
    public String status() {
        return this.status;
    }

    /**
     * Get the statusDetails property: Status details.
     * 
     * @return the statusDetails value.
     */
    public String statusDetails() {
        return this.statusDetails;
    }

    /**
     * Get the generation property: Deployment Generation.
     * 
     * @return the generation value.
     */
    public Integer generation() {
        return this.generation;
    }

    /**
     * Get the targetStatuses property: Target resource statuses.
     * 
     * @return the targetStatuses value.
     */
    public List<TargetStatus> targetStatuses() {
        return this.targetStatuses;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (targetStatuses() != null) {
            targetStatuses().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("lastModified",
            this.lastModified == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.lastModified));
        jsonWriter.writeNumberField("deployed", this.deployed);
        jsonWriter.writeNumberField("expectedRunningJobId", this.expectedRunningJobId);
        jsonWriter.writeNumberField("runningJobId", this.runningJobId);
        jsonWriter.writeStringField("status", this.status);
        jsonWriter.writeStringField("statusDetails", this.statusDetails);
        jsonWriter.writeNumberField("generation", this.generation);
        jsonWriter.writeArrayField("targetStatuses", this.targetStatuses,
            (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DeploymentStatus from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DeploymentStatus if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the DeploymentStatus.
     */
    public static DeploymentStatus fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DeploymentStatus deserializedDeploymentStatus = new DeploymentStatus();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("lastModified".equals(fieldName)) {
                    deserializedDeploymentStatus.lastModified = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("deployed".equals(fieldName)) {
                    deserializedDeploymentStatus.deployed = reader.getNullable(JsonReader::getInt);
                } else if ("expectedRunningJobId".equals(fieldName)) {
                    deserializedDeploymentStatus.expectedRunningJobId = reader.getNullable(JsonReader::getInt);
                } else if ("runningJobId".equals(fieldName)) {
                    deserializedDeploymentStatus.runningJobId = reader.getNullable(JsonReader::getInt);
                } else if ("status".equals(fieldName)) {
                    deserializedDeploymentStatus.status = reader.getString();
                } else if ("statusDetails".equals(fieldName)) {
                    deserializedDeploymentStatus.statusDetails = reader.getString();
                } else if ("generation".equals(fieldName)) {
                    deserializedDeploymentStatus.generation = reader.getNullable(JsonReader::getInt);
                } else if ("targetStatuses".equals(fieldName)) {
                    List<TargetStatus> targetStatuses = reader.readArray(reader1 -> TargetStatus.fromJson(reader1));
                    deserializedDeploymentStatus.targetStatuses = targetStatuses;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDeploymentStatus;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Diagnostic.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner;
import java.util.Map;

/**
 * An immutable client-side representation of Diagnostic.
 */
public interface Diagnostic {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the location property: The geo-location where the resource lives.
     * 
     * @return the location value.
     */
    String location();

    /**
     * Gets the tags property: Resource tags.
     * 
     * @return the tags value.
     */
    Map<String, String> tags();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    DiagnosticProperties properties();

    /**
     * Gets the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    ExtendedLocation extendedLocation();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the region of the resource.
     * 
     * @return the region of the resource.
     */
    Region region();

    /**
     * Gets the name of the resource region.
     * 
     * @return the name of the resource region.
     */
    String regionName();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner object.
     * 
     * @return the inner object.
     */
    DiagnosticInner innerModel();

    /**
     * The entirety of the Diagnostic definition.
     */
    interface Definition extends DefinitionStages.Blank, DefinitionStages.WithLocation,
        DefinitionStages.WithResourceGroup, DefinitionStages.WithCreate {
    }

    /**
     * The Diagnostic definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the Diagnostic definition.
         */
        interface Blank extends WithLocation {
        }

        /**
         * The stage of the Diagnostic definition allowing to specify location.
         */
        interface WithLocation {
            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(Region location);

            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(String location);
        }

        /**
         * The stage of the Diagnostic definition allowing to specify parent resource.
         */
        interface WithResourceGroup {
            /**
             * Specifies resourceGroupName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @return the next definition stage.
             */
            WithCreate withExistingResourceGroup(String resourceGroupName);
        }

        /**
         * The stage of the Diagnostic definition which contains all the minimum required properties for the resource to
         * be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate
            extends DefinitionStages.WithTags, DefinitionStages.WithProperties, DefinitionStages.WithExtendedLocation {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            Diagnostic create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            Diagnostic create(Context context);
        }

        /**
         * The stage of the Diagnostic definition allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            WithCreate withTags(Map<String, String> tags);
        }

        /**
         * The stage of the Diagnostic definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(DiagnosticProperties properties);
        }

        /**
         * The stage of the Diagnostic definition allowing to specify extendedLocation.
         */
        interface WithExtendedLocation {
            /**
             * Specifies the extendedLocation property: The extendedLocation property..
             * 
             * @param extendedLocation The extendedLocation property.
             * @return the next definition stage.
             */
            WithCreate withExtendedLocation(ExtendedLocation extendedLocation);
        }
    }

    /**
     * Begins update for the Diagnostic resource.
     * 
     * @return the stage of resource update.
     */
    Diagnostic.Update update();

    /**
     * The template for Diagnostic update.
     */
    interface Update extends UpdateStages.WithTags, UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        Diagnostic apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        Diagnostic apply(Context context);
    }

    /**
     * The Diagnostic update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the Diagnostic update allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            Update withTags(Map<String, String> tags);
        }

        /**
         * The stage of the Diagnostic update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(DiagnosticProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    Diagnostic refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    Diagnostic refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/DiagnosticProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * The properties of a Diagnostic resource.
 */
@Immutable
public final class DiagnosticProperties implements JsonSerializable<DiagnosticProperties> {
    /*
     * The status of the last operation.
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of DiagnosticProperties class.
     */
    public DiagnosticProperties() {
    }

    /**
     * Get the provisioningState property: The status of the last operation.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DiagnosticProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DiagnosticProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the DiagnosticProperties.
     */
    public static DiagnosticProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DiagnosticProperties deserializedDiagnosticProperties = new DiagnosticProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("provisioningState".equals(fieldName)) {
                    deserializedDiagnosticProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDiagnosticProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Diagnostics.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of Diagnostics.
 */
public interface Diagnostics {
    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response}.
     */
    Response<Diagnostic> getByResourceGroupWithResponse(String resourceGroupName, String diagnosticName,
        Context context);

    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource.
     */
    Diagnostic getByResourceGroup(String resourceGroupName, String diagnosticName);

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByResourceGroup(String resourceGroupName, String diagnosticName);

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param diagnosticName Name of Diagnostic.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String diagnosticName, Context context);

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Diagnostic> listByResourceGroup(String resourceGroupName);

    /**
     * Returns a collection of Diagnostic resources within the resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Diagnostic> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Diagnostic> list();

    /**
     * Lists Diagnostics resources within an Azure subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Diagnostic list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Diagnostic> list(Context context);

    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response}.
     */
    Diagnostic getById(String id);

    /**
     * Returns details of specified Diagnostic resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Diagnostic resource along with {@link Response}.
     */
    Response<Diagnostic> getByIdWithResponse(String id, Context context);

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Deletes specified Diagnostic resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new Diagnostic resource.
     * 
     * @param name resource name.
     * @return the first stage of the new Diagnostic definition.
     */
    Diagnostic.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/DynamicSchema.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner;

/**
 * An immutable client-side representation of DynamicSchema.
 */
public interface DynamicSchema {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    DynamicSchemaProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner object.
     * 
     * @return the inner object.
     */
    DynamicSchemaInner innerModel();

    /**
     * The entirety of the DynamicSchema definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The DynamicSchema definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the DynamicSchema definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the DynamicSchema definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, schemaName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param schemaName The name of the Schema.
             * @return the next definition stage.
             */
            WithCreate withExistingSchema(String resourceGroupName, String schemaName);
        }

        /**
         * The stage of the DynamicSchema definition which contains all the minimum required properties for the resource
         * to be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            DynamicSchema create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            DynamicSchema create(Context context);
        }

        /**
         * The stage of the DynamicSchema definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(DynamicSchemaProperties properties);
        }
    }

    /**
     * Begins update for the DynamicSchema resource.
     * 
     * @return the stage of resource update.
     */
    DynamicSchema.Update update();

    /**
     * The template for DynamicSchema update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        DynamicSchema apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        DynamicSchema apply(Context context);
    }

    /**
     * The DynamicSchema update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the DynamicSchema update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(DynamicSchemaProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    DynamicSchema refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    DynamicSchema refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/DynamicSchemaProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * DynamicSchema Properties.
 */
@Immutable
public final class DynamicSchemaProperties implements JsonSerializable<DynamicSchemaProperties> {
    /*
     * Type of configuration
     */
    private ConfigurationType configurationType;

    /*
     * Type of configuration model
     */
    private ConfigurationModel configurationModel;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of DynamicSchemaProperties class.
     */
    public DynamicSchemaProperties() {
    }

    /**
     * Get the configurationType property: Type of configuration.
     * 
     * @return the configurationType value.
     */
    public ConfigurationType configurationType() {
        return this.configurationType;
    }

    /**
     * Get the configurationModel property: Type of configuration model.
     * 
     * @return the configurationModel value.
     */
    public ConfigurationModel configurationModel() {
        return this.configurationModel;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of DynamicSchemaProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of DynamicSchemaProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the DynamicSchemaProperties.
     */
    public static DynamicSchemaProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            DynamicSchemaProperties deserializedDynamicSchemaProperties = new DynamicSchemaProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("configurationType".equals(fieldName)) {
                    deserializedDynamicSchemaProperties.configurationType
                        = ConfigurationType.fromString(reader.getString());
                } else if ("configurationModel".equals(fieldName)) {
                    deserializedDynamicSchemaProperties.configurationModel
                        = ConfigurationModel.fromString(reader.getString());
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedDynamicSchemaProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedDynamicSchemaProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/DynamicSchemas.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of DynamicSchemas.
 */
public interface DynamicSchemas {
    /**
     * Get a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource along with {@link Response}.
     */
    Response<DynamicSchema> getWithResponse(String resourceGroupName, String schemaName, String dynamicSchemaName,
        Context context);

    /**
     * Get a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource.
     */
    DynamicSchema get(String resourceGroupName, String schemaName, String dynamicSchemaName);

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String schemaName, String dynamicSchemaName);

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String schemaName, String dynamicSchemaName, Context context);

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<DynamicSchema> listBySchema(String resourceGroupName, String schemaName);

    /**
     * List by Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchema list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<DynamicSchema> listBySchema(String resourceGroupName, String schemaName, Context context);

    /**
     * Get a DynamicSchema Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource along with {@link Response}.
     */
    DynamicSchema getById(String id);

    /**
     * Get a DynamicSchema Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a DynamicSchema Resource along with {@link Response}.
     */
    Response<DynamicSchema> getByIdWithResponse(String id, Context context);

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a DynamicSchema Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new DynamicSchema resource.
     * 
     * @param name resource name.
     * @return the first stage of the new DynamicSchema definition.
     */
    DynamicSchema.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/DynamicSchemaVersion.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner;

/**
 * An immutable client-side representation of DynamicSchemaVersion.
 */
public interface DynamicSchemaVersion {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    SchemaVersionProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner object.
     * 
     * @return the inner object.
     */
    DynamicSchemaVersionInner innerModel();

    /**
     * The entirety of the DynamicSchemaVersion definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The DynamicSchemaVersion definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the DynamicSchemaVersion definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the DynamicSchemaVersion definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, schemaName, dynamicSchemaName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param schemaName The name of the Schema.
             * @param dynamicSchemaName The name of the DynamicSchema.
             * @return the next definition stage.
             */
            WithCreate withExistingDynamicSchema(String resourceGroupName, String schemaName, String dynamicSchemaName);
        }

        /**
         * The stage of the DynamicSchemaVersion definition which contains all the minimum required properties for the
         * resource to be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            DynamicSchemaVersion create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            DynamicSchemaVersion create(Context context);
        }

        /**
         * The stage of the DynamicSchemaVersion definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(SchemaVersionProperties properties);
        }
    }

    /**
     * Begins update for the DynamicSchemaVersion resource.
     * 
     * @return the stage of resource update.
     */
    DynamicSchemaVersion.Update update();

    /**
     * The template for DynamicSchemaVersion update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        DynamicSchemaVersion apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        DynamicSchemaVersion apply(Context context);
    }

    /**
     * The DynamicSchemaVersion update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the DynamicSchemaVersion update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(SchemaVersionProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    DynamicSchemaVersion refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    DynamicSchemaVersion refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/DynamicSchemaVersions.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of DynamicSchemaVersions.
 */
public interface DynamicSchemaVersions {
    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource along with {@link Response}.
     */
    Response<DynamicSchemaVersion> getWithResponse(String resourceGroupName, String schemaName,
        String dynamicSchemaName, String dynamicSchemaVersionName, Context context);

    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource.
     */
    DynamicSchemaVersion get(String resourceGroupName, String schemaName, String dynamicSchemaName,
        String dynamicSchemaVersionName);

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName);

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param dynamicSchemaVersionName The name of the DynamicSchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String schemaName, String dynamicSchemaName, String dynamicSchemaVersionName,
        Context context);

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<DynamicSchemaVersion> listByDynamicSchema(String resourceGroupName, String schemaName,
        String dynamicSchemaName);

    /**
     * List by Dynamic Schema.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param dynamicSchemaName The name of the DynamicSchema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a DynamicSchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<DynamicSchemaVersion> listByDynamicSchema(String resourceGroupName, String schemaName,
        String dynamicSchemaName, Context context);

    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource along with {@link Response}.
     */
    DynamicSchemaVersion getById(String id);

    /**
     * Get a Dynamic Schema Version Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Dynamic Schema Version Resource along with {@link Response}.
     */
    Response<DynamicSchemaVersion> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Dynamic Schema Version Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new DynamicSchemaVersion resource.
     * 
     * @param name resource name.
     * @return the first stage of the new DynamicSchemaVersion definition.
     */
    DynamicSchemaVersion.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ErrorAction.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Error Action Properties.
 */
@Fluent
public final class ErrorAction implements JsonSerializable<ErrorAction> {
    /*
     * Error action mode
     */
    private ErrorActionMode mode;

    /*
     * Max tolerated failures
     */
    private Integer maxToleratedFailures;

    /**
     * Creates an instance of ErrorAction class.
     */
    public ErrorAction() {
    }

    /**
     * Get the mode property: Error action mode.
     * 
     * @return the mode value.
     */
    public ErrorActionMode mode() {
        return this.mode;
    }

    /**
     * Set the mode property: Error action mode.
     * 
     * @param mode the mode value to set.
     * @return the ErrorAction object itself.
     */
    public ErrorAction withMode(ErrorActionMode mode) {
        this.mode = mode;
        return this;
    }

    /**
     * Get the maxToleratedFailures property: Max tolerated failures.
     * 
     * @return the maxToleratedFailures value.
     */
    public Integer maxToleratedFailures() {
        return this.maxToleratedFailures;
    }

    /**
     * Set the maxToleratedFailures property: Max tolerated failures.
     * 
     * @param maxToleratedFailures the maxToleratedFailures value to set.
     * @return the ErrorAction object itself.
     */
    public ErrorAction withMaxToleratedFailures(Integer maxToleratedFailures) {
        this.maxToleratedFailures = maxToleratedFailures;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("mode", this.mode == null ? null : this.mode.toString());
        jsonWriter.writeNumberField("maxToleratedFailures", this.maxToleratedFailures);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ErrorAction from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ErrorAction if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the ErrorAction.
     */
    public static ErrorAction fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ErrorAction deserializedErrorAction = new ErrorAction();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("mode".equals(fieldName)) {
                    deserializedErrorAction.mode = ErrorActionMode.fromString(reader.getString());
                } else if ("maxToleratedFailures".equals(fieldName)) {
                    deserializedErrorAction.maxToleratedFailures = reader.getNullable(JsonReader::getInt);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedErrorAction;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ErrorActionMode.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Error Action Mode.
 */
public final class ErrorActionMode extends ExpandableStringEnum<ErrorActionMode> {
    /**
     * Stop on any failure.
     */
    public static final ErrorActionMode STOP_ON_ANY_FAILURE = fromString("stopOnAnyFailure");

    /**
     * Stop after N cumulative failures.
     */
    public static final ErrorActionMode STOP_ON_NFAILURES = fromString("stopOnNFailures");

    /**
     * Continue silently despite errors.
     */
    public static final ErrorActionMode SILENTLY_CONTINUE = fromString("silentlyContinue");

    /**
     * Creates a new instance of ErrorActionMode value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public ErrorActionMode() {
    }

    /**
     * Creates or finds a ErrorActionMode from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding ErrorActionMode.
     */
    public static ErrorActionMode fromString(String name) {
        return fromString(name, ErrorActionMode.class);
    }

    /**
     * Gets known ErrorActionMode values.
     * 
     * @return known ErrorActionMode values.
     */
    public static Collection<ErrorActionMode> values() {
        return values(ErrorActionMode.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Execution.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner;

/**
 * An immutable client-side representation of Execution.
 */
public interface Execution {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    ExecutionProperties properties();

    /**
     * Gets the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    ExtendedLocation extendedLocation();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner object.
     * 
     * @return the inner object.
     */
    ExecutionInner innerModel();

    /**
     * The entirety of the Execution definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The Execution definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the Execution definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the Execution definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, contextName, workflowName, versionName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param contextName The name of the Context.
             * @param workflowName Name of the workflow.
             * @param versionName The name of the workflowVersion.
             * @return the next definition stage.
             */
            WithCreate withExistingVersion(String resourceGroupName, String contextName, String workflowName,
                String versionName);
        }

        /**
         * The stage of the Execution definition which contains all the minimum required properties for the resource to
         * be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties, DefinitionStages.WithExtendedLocation {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            Execution create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            Execution create(Context context);
        }

        /**
         * The stage of the Execution definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(ExecutionProperties properties);
        }

        /**
         * The stage of the Execution definition allowing to specify extendedLocation.
         */
        interface WithExtendedLocation {
            /**
             * Specifies the extendedLocation property: The extendedLocation property..
             * 
             * @param extendedLocation The extendedLocation property.
             * @return the next definition stage.
             */
            WithCreate withExtendedLocation(ExtendedLocation extendedLocation);
        }
    }

    /**
     * Begins update for the Execution resource.
     * 
     * @return the stage of resource update.
     */
    Execution.Update update();

    /**
     * The template for Execution update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        Execution apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        Execution apply(Context context);
    }

    /**
     * The Execution update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the Execution update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(ExecutionProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    Execution refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    Execution refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ExecutionProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.Map;

/**
 * Execution Properties.
 */
@Fluent
public final class ExecutionProperties implements JsonSerializable<ExecutionProperties> {
    /*
     * Workflow version of execution
     */
    private String workflowVersionId;

    /*
     * Execution specification
     */
    private Map<String, BinaryData> specification;

    /*
     * Status of Execution
     */
    private ExecutionStatus status;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of ExecutionProperties class.
     */
    public ExecutionProperties() {
    }

    /**
     * Get the workflowVersionId property: Workflow version of execution.
     * 
     * @return the workflowVersionId value.
     */
    public String workflowVersionId() {
        return this.workflowVersionId;
    }

    /**
     * Set the workflowVersionId property: Workflow version of execution.
     * 
     * @param workflowVersionId the workflowVersionId value to set.
     * @return the ExecutionProperties object itself.
     */
    public ExecutionProperties withWorkflowVersionId(String workflowVersionId) {
        this.workflowVersionId = workflowVersionId;
        return this;
    }

    /**
     * Get the specification property: Execution specification.
     * 
     * @return the specification value.
     */
    public Map<String, BinaryData> specification() {
        return this.specification;
    }

    /**
     * Set the specification property: Execution specification.
     * 
     * @param specification the specification value to set.
     * @return the ExecutionProperties object itself.
     */
    public ExecutionProperties withSpecification(Map<String, BinaryData> specification) {
        this.specification = specification;
        return this;
    }

    /**
     * Get the status property: Status of Execution.
     * 
     * @return the status value.
     */
    public ExecutionStatus status() {
        return this.status;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (workflowVersionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property workflowVersionId in model ExecutionProperties"));
        }
        if (status() != null) {
            status().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ExecutionProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("workflowVersionId", this.workflowVersionId);
        jsonWriter.writeMapField("specification", this.specification,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ExecutionProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ExecutionProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ExecutionProperties.
     */
    public static ExecutionProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ExecutionProperties deserializedExecutionProperties = new ExecutionProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("workflowVersionId".equals(fieldName)) {
                    deserializedExecutionProperties.workflowVersionId = reader.getString();
                } else if ("specification".equals(fieldName)) {
                    Map<String, BinaryData> specification = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedExecutionProperties.specification = specification;
                } else if ("status".equals(fieldName)) {
                    deserializedExecutionProperties.status = ExecutionStatus.fromJson(reader);
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedExecutionProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedExecutionProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Executions.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of Executions.
 */
public interface Executions {
    /**
     * Get Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response}.
     */
    Response<Execution> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, String executionName, Context context);

    /**
     * Get Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource.
     */
    Execution get(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName);

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName);

    /**
     * Delete Execution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param executionName The name of the Execution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String contextName, String workflowName, String versionName,
        String executionName, Context context);

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Execution> listByWorkflowVersion(String resourceGroupName, String contextName, String workflowName,
        String versionName);

    /**
     * List Execution Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Execution list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Execution> listByWorkflowVersion(String resourceGroupName, String contextName, String workflowName,
        String versionName, Context context);

    /**
     * Get Execution Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response}.
     */
    Execution getById(String id);

    /**
     * Get Execution Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return execution Resource along with {@link Response}.
     */
    Response<Execution> getByIdWithResponse(String id, Context context);

    /**
     * Delete Execution Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete Execution Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new Execution resource.
     * 
     * @param name resource name.
     * @return the first stage of the new Execution definition.
     */
    Execution.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ExecutionStatus.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Execution Status.
 */
@Immutable
public final class ExecutionStatus implements JsonSerializable<ExecutionStatus> {
    /*
     * The lastModified timestamp of the Status
     */
    private OffsetDateTime updateTime;

    /*
     * Deployment status
     */
    private Integer status;

    /*
     * status details
     */
    private String statusMessage;

    /*
     * target resource statuses
     */
    private List<StageStatus> stageHistory;

    /**
     * Creates an instance of ExecutionStatus class.
     */
    private ExecutionStatus() {
    }

    /**
     * Get the updateTime property: The lastModified timestamp of the Status.
     * 
     * @return the updateTime value.
     */
    public OffsetDateTime updateTime() {
        return this.updateTime;
    }

    /**
     * Get the status property: Deployment status.
     * 
     * @return the status value.
     */
    public Integer status() {
        return this.status;
    }

    /**
     * Get the statusMessage property: status details.
     * 
     * @return the statusMessage value.
     */
    public String statusMessage() {
        return this.statusMessage;
    }

    /**
     * Get the stageHistory property: target resource statuses.
     * 
     * @return the stageHistory value.
     */
    public List<StageStatus> stageHistory() {
        return this.stageHistory;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (stageHistory() != null) {
            stageHistory().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("updateTime",
            this.updateTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.updateTime));
        jsonWriter.writeNumberField("status", this.status);
        jsonWriter.writeStringField("statusMessage", this.statusMessage);
        jsonWriter.writeArrayField("stageHistory", this.stageHistory, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ExecutionStatus from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ExecutionStatus if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the ExecutionStatus.
     */
    public static ExecutionStatus fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ExecutionStatus deserializedExecutionStatus = new ExecutionStatus();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("updateTime".equals(fieldName)) {
                    deserializedExecutionStatus.updateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("status".equals(fieldName)) {
                    deserializedExecutionStatus.status = reader.getNullable(JsonReader::getInt);
                } else if ("statusMessage".equals(fieldName)) {
                    deserializedExecutionStatus.statusMessage = reader.getString();
                } else if ("stageHistory".equals(fieldName)) {
                    List<StageStatus> stageHistory = reader.readArray(reader1 -> StageStatus.fromJson(reader1));
                    deserializedExecutionStatus.stageHistory = stageHistory;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedExecutionStatus;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ExtendedLocation.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * The complex type of the extended location.
 */
@Fluent
public final class ExtendedLocation implements JsonSerializable<ExtendedLocation> {
    /*
     * The name of the extended location.
     */
    private String name;

    /*
     * The type of the extended location.
     */
    private ExtendedLocationType type;

    /**
     * Creates an instance of ExtendedLocation class.
     */
    public ExtendedLocation() {
    }

    /**
     * Get the name property: The name of the extended location.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Set the name property: The name of the extended location.
     * 
     * @param name the name value to set.
     * @return the ExtendedLocation object itself.
     */
    public ExtendedLocation withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the type property: The type of the extended location.
     * 
     * @return the type value.
     */
    public ExtendedLocationType type() {
        return this.type;
    }

    /**
     * Set the type property: The type of the extended location.
     * 
     * @param type the type value to set.
     * @return the ExtendedLocation object itself.
     */
    public ExtendedLocation withType(ExtendedLocationType type) {
        this.type = type;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (name() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property name in model ExtendedLocation"));
        }
        if (type() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property type in model ExtendedLocation"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ExtendedLocation.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("type", this.type == null ? null : this.type.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ExtendedLocation from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ExtendedLocation if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ExtendedLocation.
     */
    public static ExtendedLocation fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ExtendedLocation deserializedExtendedLocation = new ExtendedLocation();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedExtendedLocation.name = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedExtendedLocation.type = ExtendedLocationType.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedExtendedLocation;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ExtendedLocationType.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * The supported ExtendedLocation types.
 */
public final class ExtendedLocationType extends ExpandableStringEnum<ExtendedLocationType> {
    /**
     * Azure Edge Zones location type.
     */
    public static final ExtendedLocationType EDGE_ZONE = fromString("EdgeZone");

    /**
     * Azure Custom Locations type.
     */
    public static final ExtendedLocationType CUSTOM_LOCATION = fromString("CustomLocation");

    /**
     * Creates a new instance of ExtendedLocationType value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public ExtendedLocationType() {
    }

    /**
     * Creates or finds a ExtendedLocationType from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding ExtendedLocationType.
     */
    public static ExtendedLocationType fromString(String name) {
        return fromString(name, ExtendedLocationType.class);
    }

    /**
     * Gets known ExtendedLocationType values.
     * 
     * @return known ExtendedLocationType values.
     */
    public static Collection<ExtendedLocationType> values() {
        return values(ExtendedLocationType.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Hierarchy.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Hierarchy, to tag Sites / Hierarchy Provider nodes with what they represent.
 */
@Fluent
public final class Hierarchy implements JsonSerializable<Hierarchy> {
    /*
     * Name of Hierarchy
     */
    private String name;

    /*
     * Description of Hierarchy
     */
    private String description;

    /**
     * Creates an instance of Hierarchy class.
     */
    public Hierarchy() {
    }

    /**
     * Get the name property: Name of Hierarchy.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Set the name property: Name of Hierarchy.
     * 
     * @param name the name value to set.
     * @return the Hierarchy object itself.
     */
    public Hierarchy withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the description property: Description of Hierarchy.
     * 
     * @return the description value.
     */
    public String description() {
        return this.description;
    }

    /**
     * Set the description property: Description of Hierarchy.
     * 
     * @param description the description value to set.
     * @return the Hierarchy object itself.
     */
    public Hierarchy withDescription(String description) {
        this.description = description;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (name() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property name in model Hierarchy"));
        }
        if (description() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property description in model Hierarchy"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(Hierarchy.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("description", this.description);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Hierarchy from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Hierarchy if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the Hierarchy.
     */
    public static Hierarchy fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            Hierarchy deserializedHierarchy = new Hierarchy();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedHierarchy.name = reader.getString();
                } else if ("description".equals(fieldName)) {
                    deserializedHierarchy.description = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedHierarchy;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/InstallSolutionParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Install Solution Parameter.
 */
@Fluent
public final class InstallSolutionParameter implements JsonSerializable<InstallSolutionParameter> {
    /*
     * Solution Version ARM Id
     */
    private String solutionVersionId;

    /**
     * Creates an instance of InstallSolutionParameter class.
     */
    public InstallSolutionParameter() {
    }

    /**
     * Get the solutionVersionId property: Solution Version ARM Id.
     * 
     * @return the solutionVersionId value.
     */
    public String solutionVersionId() {
        return this.solutionVersionId;
    }

    /**
     * Set the solutionVersionId property: Solution Version ARM Id.
     * 
     * @param solutionVersionId the solutionVersionId value to set.
     * @return the InstallSolutionParameter object itself.
     */
    public InstallSolutionParameter withSolutionVersionId(String solutionVersionId) {
        this.solutionVersionId = solutionVersionId;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionVersionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionVersionId in model InstallSolutionParameter"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(InstallSolutionParameter.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionVersionId", this.solutionVersionId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of InstallSolutionParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of InstallSolutionParameter if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the InstallSolutionParameter.
     */
    public static InstallSolutionParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            InstallSolutionParameter deserializedInstallSolutionParameter = new InstallSolutionParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionVersionId".equals(fieldName)) {
                    deserializedInstallSolutionParameter.solutionVersionId = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedInstallSolutionParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Instance.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner;

/**
 * An immutable client-side representation of Instance.
 */
public interface Instance {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    InstanceProperties properties();

    /**
     * Gets the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    ExtendedLocation extendedLocation();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner object.
     * 
     * @return the inner object.
     */
    InstanceInner innerModel();

    /**
     * The entirety of the Instance definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The Instance definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the Instance definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the Instance definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, targetName, solutionName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param targetName Name of the target.
             * @param solutionName Name of the solution.
             * @return the next definition stage.
             */
            WithCreate withExistingSolution(String resourceGroupName, String targetName, String solutionName);
        }

        /**
         * The stage of the Instance definition which contains all the minimum required properties for the resource to
         * be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties, DefinitionStages.WithExtendedLocation {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            Instance create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            Instance create(Context context);
        }

        /**
         * The stage of the Instance definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(InstanceProperties properties);
        }

        /**
         * The stage of the Instance definition allowing to specify extendedLocation.
         */
        interface WithExtendedLocation {
            /**
             * Specifies the extendedLocation property: The extendedLocation property..
             * 
             * @param extendedLocation The extendedLocation property.
             * @return the next definition stage.
             */
            WithCreate withExtendedLocation(ExtendedLocation extendedLocation);
        }
    }

    /**
     * Begins update for the Instance resource.
     * 
     * @return the stage of resource update.
     */
    Instance.Update update();

    /**
     * The template for Instance update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        Instance apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        Instance apply(Context context);
    }

    /**
     * The Instance update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the Instance update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(InstanceProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    Instance refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    Instance refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/InstanceHistories.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of InstanceHistories.
 */
public interface InstanceHistories {
    /**
     * Get InstanceHistory Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param instanceHistoryName Name of the instance history.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instanceHistory Resource along with {@link Response}.
     */
    Response<InstanceHistory> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, String instanceHistoryName, Context context);

    /**
     * Get InstanceHistory Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param instanceHistoryName Name of the instance history.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instanceHistory Resource.
     */
    InstanceHistory get(String resourceGroupName, String targetName, String solutionName, String instanceName,
        String instanceHistoryName);

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<InstanceHistory> listByInstance(String resourceGroupName, String targetName, String solutionName,
        String instanceName);

    /**
     * List InstanceHistory Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a InstanceHistory list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<InstanceHistory> listByInstance(String resourceGroupName, String targetName, String solutionName,
        String instanceName, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/InstanceHistory.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner;

/**
 * An immutable client-side representation of InstanceHistory.
 */
public interface InstanceHistory {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    InstanceHistoryProperties properties();

    /**
     * Gets the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    ExtendedLocation extendedLocation();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner object.
     * 
     * @return the inner object.
     */
    InstanceHistoryInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/InstanceHistoryProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Instance History Properties.
 */
@Immutable
public final class InstanceHistoryProperties implements JsonSerializable<InstanceHistoryProperties> {
    /*
     * Solution version of instance
     */
    private SolutionVersionSnapshot solutionVersion;

    /*
     * Target of instance
     */
    private TargetSnapshot target;

    /*
     * Scope of instance
     */
    private String solutionScope;

    /*
     * State of instance
     */
    private ActiveState activeState;

    /*
     * Reconciliation policy of instance
     */
    private ReconciliationPolicyProperties reconciliationPolicy;

    /*
     * Deployment Status of instance
     */
    private DeploymentStatus status;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of InstanceHistoryProperties class.
     */
    private InstanceHistoryProperties() {
    }

    /**
     * Get the solutionVersion property: Solution version of instance.
     * 
     * @return the solutionVersion value.
     */
    public SolutionVersionSnapshot solutionVersion() {
        return this.solutionVersion;
    }

    /**
     * Get the target property: Target of instance.
     * 
     * @return the target value.
     */
    public TargetSnapshot target() {
        return this.target;
    }

    /**
     * Get the solutionScope property: Scope of instance.
     * 
     * @return the solutionScope value.
     */
    public String solutionScope() {
        return this.solutionScope;
    }

    /**
     * Get the activeState property: State of instance.
     * 
     * @return the activeState value.
     */
    public ActiveState activeState() {
        return this.activeState;
    }

    /**
     * Get the reconciliationPolicy property: Reconciliation policy of instance.
     * 
     * @return the reconciliationPolicy value.
     */
    public ReconciliationPolicyProperties reconciliationPolicy() {
        return this.reconciliationPolicy;
    }

    /**
     * Get the status property: Deployment Status of instance.
     * 
     * @return the status value.
     */
    public DeploymentStatus status() {
        return this.status;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionVersion() != null) {
            solutionVersion().validate();
        }
        if (target() != null) {
            target().validate();
        }
        if (reconciliationPolicy() != null) {
            reconciliationPolicy().validate();
        }
        if (status() != null) {
            status().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("activeState", this.activeState == null ? null : this.activeState.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of InstanceHistoryProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of InstanceHistoryProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the InstanceHistoryProperties.
     */
    public static InstanceHistoryProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            InstanceHistoryProperties deserializedInstanceHistoryProperties = new InstanceHistoryProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionVersion".equals(fieldName)) {
                    deserializedInstanceHistoryProperties.solutionVersion = SolutionVersionSnapshot.fromJson(reader);
                } else if ("target".equals(fieldName)) {
                    deserializedInstanceHistoryProperties.target = TargetSnapshot.fromJson(reader);
                } else if ("solutionScope".equals(fieldName)) {
                    deserializedInstanceHistoryProperties.solutionScope = reader.getString();
                } else if ("activeState".equals(fieldName)) {
                    deserializedInstanceHistoryProperties.activeState = ActiveState.fromString(reader.getString());
                } else if ("reconciliationPolicy".equals(fieldName)) {
                    deserializedInstanceHistoryProperties.reconciliationPolicy
                        = ReconciliationPolicyProperties.fromJson(reader);
                } else if ("status".equals(fieldName)) {
                    deserializedInstanceHistoryProperties.status = DeploymentStatus.fromJson(reader);
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedInstanceHistoryProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedInstanceHistoryProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/InstanceProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Instance Properties.
 */
@Fluent
public final class InstanceProperties implements JsonSerializable<InstanceProperties> {
    /*
     * Solution version of instance
     */
    private String solutionVersionId;

    /*
     * Target of instance
     */
    private String targetId;

    /*
     * State of instance
     */
    private ActiveState activeState;

    /*
     * Reconciliation policy of instance
     */
    private ReconciliationPolicyProperties reconciliationPolicy;

    /*
     * Scope of instance
     */
    private String solutionScope;

    /*
     * Status of instance
     */
    private DeploymentStatus status;

    /*
     * Deployment timestamp of instance
     */
    private Long deploymentTimestampEpoch;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of InstanceProperties class.
     */
    public InstanceProperties() {
    }

    /**
     * Get the solutionVersionId property: Solution version of instance.
     * 
     * @return the solutionVersionId value.
     */
    public String solutionVersionId() {
        return this.solutionVersionId;
    }

    /**
     * Set the solutionVersionId property: Solution version of instance.
     * 
     * @param solutionVersionId the solutionVersionId value to set.
     * @return the InstanceProperties object itself.
     */
    public InstanceProperties withSolutionVersionId(String solutionVersionId) {
        this.solutionVersionId = solutionVersionId;
        return this;
    }

    /**
     * Get the targetId property: Target of instance.
     * 
     * @return the targetId value.
     */
    public String targetId() {
        return this.targetId;
    }

    /**
     * Set the targetId property: Target of instance.
     * 
     * @param targetId the targetId value to set.
     * @return the InstanceProperties object itself.
     */
    public InstanceProperties withTargetId(String targetId) {
        this.targetId = targetId;
        return this;
    }

    /**
     * Get the activeState property: State of instance.
     * 
     * @return the activeState value.
     */
    public ActiveState activeState() {
        return this.activeState;
    }

    /**
     * Set the activeState property: State of instance.
     * 
     * @param activeState the activeState value to set.
     * @return the InstanceProperties object itself.
     */
    public InstanceProperties withActiveState(ActiveState activeState) {
        this.activeState = activeState;
        return this;
    }

    /**
     * Get the reconciliationPolicy property: Reconciliation policy of instance.
     * 
     * @return the reconciliationPolicy value.
     */
    public ReconciliationPolicyProperties reconciliationPolicy() {
        return this.reconciliationPolicy;
    }

    /**
     * Set the reconciliationPolicy property: Reconciliation policy of instance.
     * 
     * @param reconciliationPolicy the reconciliationPolicy value to set.
     * @return the InstanceProperties object itself.
     */
    public InstanceProperties withReconciliationPolicy(ReconciliationPolicyProperties reconciliationPolicy) {
        this.reconciliationPolicy = reconciliationPolicy;
        return this;
    }

    /**
     * Get the solutionScope property: Scope of instance.
     * 
     * @return the solutionScope value.
     */
    public String solutionScope() {
        return this.solutionScope;
    }

    /**
     * Set the solutionScope property: Scope of instance.
     * 
     * @param solutionScope the solutionScope value to set.
     * @return the InstanceProperties object itself.
     */
    public InstanceProperties withSolutionScope(String solutionScope) {
        this.solutionScope = solutionScope;
        return this;
    }

    /**
     * Get the status property: Status of instance.
     * 
     * @return the status value.
     */
    public DeploymentStatus status() {
        return this.status;
    }

    /**
     * Get the deploymentTimestampEpoch property: Deployment timestamp of instance.
     * 
     * @return the deploymentTimestampEpoch value.
     */
    public Long deploymentTimestampEpoch() {
        return this.deploymentTimestampEpoch;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionVersionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionVersionId in model InstanceProperties"));
        }
        if (targetId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property targetId in model InstanceProperties"));
        }
        if (reconciliationPolicy() != null) {
            reconciliationPolicy().validate();
        }
        if (status() != null) {
            status().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(InstanceProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionVersionId", this.solutionVersionId);
        jsonWriter.writeStringField("targetId", this.targetId);
        jsonWriter.writeStringField("activeState", this.activeState == null ? null : this.activeState.toString());
        jsonWriter.writeJsonField("reconciliationPolicy", this.reconciliationPolicy);
        jsonWriter.writeStringField("solutionScope", this.solutionScope);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of InstanceProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of InstanceProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the InstanceProperties.
     */
    public static InstanceProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            InstanceProperties deserializedInstanceProperties = new InstanceProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionVersionId".equals(fieldName)) {
                    deserializedInstanceProperties.solutionVersionId = reader.getString();
                } else if ("targetId".equals(fieldName)) {
                    deserializedInstanceProperties.targetId = reader.getString();
                } else if ("activeState".equals(fieldName)) {
                    deserializedInstanceProperties.activeState = ActiveState.fromString(reader.getString());
                } else if ("reconciliationPolicy".equals(fieldName)) {
                    deserializedInstanceProperties.reconciliationPolicy
                        = ReconciliationPolicyProperties.fromJson(reader);
                } else if ("solutionScope".equals(fieldName)) {
                    deserializedInstanceProperties.solutionScope = reader.getString();
                } else if ("status".equals(fieldName)) {
                    deserializedInstanceProperties.status = DeploymentStatus.fromJson(reader);
                } else if ("deploymentTimestampEpoch".equals(fieldName)) {
                    deserializedInstanceProperties.deploymentTimestampEpoch = reader.getNullable(JsonReader::getLong);
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedInstanceProperties.provisioningState = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedInstanceProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Instances.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of Instances.
 */
public interface Instances {
    /**
     * Get Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response}.
     */
    Response<Instance> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String instanceName, Context context);

    /**
     * Get Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource.
     */
    Instance get(String resourceGroupName, String targetName, String solutionName, String instanceName);

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String targetName, String solutionName, String instanceName);

    /**
     * Delete Instance Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param instanceName Name of the instance.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String targetName, String solutionName, String instanceName, Context context);

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Instance> listBySolution(String resourceGroupName, String targetName, String solutionName);

    /**
     * List Instance Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Instance list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Instance> listBySolution(String resourceGroupName, String targetName, String solutionName,
        Context context);

    /**
     * Get Instance Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response}.
     */
    Instance getById(String id);

    /**
     * Get Instance Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return instance Resource along with {@link Response}.
     */
    Response<Instance> getByIdWithResponse(String id, Context context);

    /**
     * Delete Instance Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete Instance Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new Instance resource.
     * 
     * @param name resource name.
     * @return the first stage of the new Instance definition.
     */
    Instance.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Job.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.JobInner;

/**
 * An immutable client-side representation of Job.
 */
public interface Job {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    JobProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.JobInner object.
     * 
     * @return the inner object.
     */
    JobInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/JobParameterBase.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Base Job Parameter.
 */
@Immutable
public class JobParameterBase implements JsonSerializable<JobParameterBase> {
    /*
     * Job type discriminator value
     */
    private JobType jobType = JobType.fromString("JobParameterBase");

    /**
     * Creates an instance of JobParameterBase class.
     */
    protected JobParameterBase() {
    }

    /**
     * Get the jobType property: Job type discriminator value.
     * 
     * @return the jobType value.
     */
    public JobType jobType() {
        return this.jobType;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("jobType", this.jobType == null ? null : this.jobType.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of JobParameterBase from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of JobParameterBase if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the JobParameterBase.
     */
    public static JobParameterBase fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String discriminatorValue = null;
            try (JsonReader readerToUse = reader.bufferObject()) {
                readerToUse.nextToken(); // Prepare for reading
                while (readerToUse.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = readerToUse.getFieldName();
                    readerToUse.nextToken();
                    if ("jobType".equals(fieldName)) {
                        discriminatorValue = readerToUse.getString();
                        break;
                    } else {
                        readerToUse.skipChildren();
                    }
                }
                // Use the discriminator value to determine which subtype should be deserialized.
                if ("deploy".equals(discriminatorValue)) {
                    return DeployJobParameter.fromJson(readerToUse.reset());
                } else {
                    return fromJsonKnownDiscriminator(readerToUse.reset());
                }
            }
        });
    }

    static JobParameterBase fromJsonKnownDiscriminator(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            JobParameterBase deserializedJobParameterBase = new JobParameterBase();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("jobType".equals(fieldName)) {
                    deserializedJobParameterBase.jobType = JobType.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedJobParameterBase;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/JobProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.management.exception.ManagementError;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Properties of a Job resource, including type, status, parameters, steps, and error details.
 */
@Immutable
public final class JobProperties implements JsonSerializable<JobProperties> {
    /*
     * The type of job.
     */
    private JobType jobType;

    /*
     * Start time of the job (ISO8601).
     */
    private OffsetDateTime startTime;

    /*
     * End time of the job (ISO8601).
     */
    private OffsetDateTime endTime;

    /*
     * Status of the job.
     */
    private JobStatus status;

    /*
     * Parameters for the job.
     */
    private JobParameterBase jobParameter;

    /*
     * Correlation ID for tracking.
     */
    private String correlationId;

    /*
     * Steps and substatuses for the job.
     */
    private List<JobStep> steps;

    /*
     * The OID or identity that triggered the job.
     */
    private String triggeredBy;

    /*
     * Provisioning state of the resource.
     */
    private ProvisioningState provisioningState;

    /*
     * Error Details if any failure is there
     */
    private ManagementError errorDetails;

    /**
     * Creates an instance of JobProperties class.
     */
    private JobProperties() {
    }

    /**
     * Get the jobType property: The type of job.
     * 
     * @return the jobType value.
     */
    public JobType jobType() {
        return this.jobType;
    }

    /**
     * Get the startTime property: Start time of the job (ISO8601).
     * 
     * @return the startTime value.
     */
    public OffsetDateTime startTime() {
        return this.startTime;
    }

    /**
     * Get the endTime property: End time of the job (ISO8601).
     * 
     * @return the endTime value.
     */
    public OffsetDateTime endTime() {
        return this.endTime;
    }

    /**
     * Get the status property: Status of the job.
     * 
     * @return the status value.
     */
    public JobStatus status() {
        return this.status;
    }

    /**
     * Get the jobParameter property: Parameters for the job.
     * 
     * @return the jobParameter value.
     */
    public JobParameterBase jobParameter() {
        return this.jobParameter;
    }

    /**
     * Get the correlationId property: Correlation ID for tracking.
     * 
     * @return the correlationId value.
     */
    public String correlationId() {
        return this.correlationId;
    }

    /**
     * Get the steps property: Steps and substatuses for the job.
     * 
     * @return the steps value.
     */
    public List<JobStep> steps() {
        return this.steps;
    }

    /**
     * Get the triggeredBy property: The OID or identity that triggered the job.
     * 
     * @return the triggeredBy value.
     */
    public String triggeredBy() {
        return this.triggeredBy;
    }

    /**
     * Get the provisioningState property: Provisioning state of the resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the errorDetails property: Error Details if any failure is there.
     * 
     * @return the errorDetails value.
     */
    public ManagementError errorDetails() {
        return this.errorDetails;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (jobType() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property jobType in model JobProperties"));
        }
        if (status() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property status in model JobProperties"));
        }
        if (jobParameter() != null) {
            jobParameter().validate();
        }
        if (steps() != null) {
            steps().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(JobProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("jobType", this.jobType == null ? null : this.jobType.toString());
        jsonWriter.writeStringField("status", this.status == null ? null : this.status.toString());
        jsonWriter.writeStringField("startTime",
            this.startTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.startTime));
        jsonWriter.writeStringField("endTime",
            this.endTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.endTime));
        jsonWriter.writeJsonField("jobParameter", this.jobParameter);
        jsonWriter.writeStringField("correlationId", this.correlationId);
        jsonWriter.writeArrayField("steps", this.steps, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("triggeredBy", this.triggeredBy);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of JobProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of JobProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the JobProperties.
     */
    public static JobProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            JobProperties deserializedJobProperties = new JobProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("jobType".equals(fieldName)) {
                    deserializedJobProperties.jobType = JobType.fromString(reader.getString());
                } else if ("status".equals(fieldName)) {
                    deserializedJobProperties.status = JobStatus.fromString(reader.getString());
                } else if ("startTime".equals(fieldName)) {
                    deserializedJobProperties.startTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("endTime".equals(fieldName)) {
                    deserializedJobProperties.endTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("jobParameter".equals(fieldName)) {
                    deserializedJobProperties.jobParameter = JobParameterBase.fromJson(reader);
                } else if ("correlationId".equals(fieldName)) {
                    deserializedJobProperties.correlationId = reader.getString();
                } else if ("steps".equals(fieldName)) {
                    List<JobStep> steps = reader.readArray(reader1 -> JobStep.fromJson(reader1));
                    deserializedJobProperties.steps = steps;
                } else if ("triggeredBy".equals(fieldName)) {
                    deserializedJobProperties.triggeredBy = reader.getString();
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedJobProperties.provisioningState = ProvisioningState.fromString(reader.getString());
                } else if ("errorDetails".equals(fieldName)) {
                    deserializedJobProperties.errorDetails = ManagementError.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedJobProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Jobs.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of Jobs.
 */
public interface Jobs {
    /**
     * Get a Job resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param jobName The name of the Job.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Job resource along with {@link Response}.
     */
    Response<Job> getWithResponse(String resourceUri, String jobName, Context context);

    /**
     * Get a Job resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param jobName The name of the Job.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Job resource.
     */
    Job get(String resourceUri, String jobName);

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Job> listByTarget(String resourceUri);

    /**
     * List Jobs by parent resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Job list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Job> listByTarget(String resourceUri, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/JobStatus.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Status of a job or job step.
 */
public final class JobStatus extends ExpandableStringEnum<JobStatus> {
    /**
     * The job or step is not started.
     */
    public static final JobStatus NOT_STARTED = fromString("NotStarted");

    /**
     * The job or step is in progress.
     */
    public static final JobStatus IN_PROGRESS = fromString("InProgress");

    /**
     * The job or step succeeded.
     */
    public static final JobStatus SUCCEEDED = fromString("Succeeded");

    /**
     * The job or step failed.
     */
    public static final JobStatus FAILED = fromString("Failed");

    /**
     * Creates a new instance of JobStatus value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public JobStatus() {
    }

    /**
     * Creates or finds a JobStatus from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding JobStatus.
     */
    public static JobStatus fromString(String name) {
        return fromString(name, JobStatus.class);
    }

    /**
     * Gets known JobStatus values.
     * 
     * @return known JobStatus values.
     */
    public static Collection<JobStatus> values() {
        return values(JobStatus.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/JobStep.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.management.exception.ManagementError;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Job Step.
 */
@Immutable
public final class JobStep implements JsonSerializable<JobStep> {
    /*
     * Name of the step
     */
    private String name;

    /*
     * Status of the step
     */
    private JobStatus status;

    /*
     * Start time of the step (ISO8601)
     */
    private OffsetDateTime startTime;

    /*
     * End time of the step (ISO8601)
     */
    private OffsetDateTime endTime;

    /*
     * Message for the step
     */
    private String message;

    /*
     * Statistics for the step
     */
    private JobStepStatisticsBase statistics;

    /*
     * Nested substeps for this step
     */
    private List<JobStep> steps;

    /*
     * Error Details if any failure is there
     */
    private ManagementError errorDetails;

    /**
     * Creates an instance of JobStep class.
     */
    private JobStep() {
    }

    /**
     * Get the name property: Name of the step.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Get the status property: Status of the step.
     * 
     * @return the status value.
     */
    public JobStatus status() {
        return this.status;
    }

    /**
     * Get the startTime property: Start time of the step (ISO8601).
     * 
     * @return the startTime value.
     */
    public OffsetDateTime startTime() {
        return this.startTime;
    }

    /**
     * Get the endTime property: End time of the step (ISO8601).
     * 
     * @return the endTime value.
     */
    public OffsetDateTime endTime() {
        return this.endTime;
    }

    /**
     * Get the message property: Message for the step.
     * 
     * @return the message value.
     */
    public String message() {
        return this.message;
    }

    /**
     * Get the statistics property: Statistics for the step.
     * 
     * @return the statistics value.
     */
    public JobStepStatisticsBase statistics() {
        return this.statistics;
    }

    /**
     * Get the steps property: Nested substeps for this step.
     * 
     * @return the steps value.
     */
    public List<JobStep> steps() {
        return this.steps;
    }

    /**
     * Get the errorDetails property: Error Details if any failure is there.
     * 
     * @return the errorDetails value.
     */
    public ManagementError errorDetails() {
        return this.errorDetails;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (name() == null) {
            throw LOGGER.atError().log(new IllegalArgumentException("Missing required property name in model JobStep"));
        }
        if (status() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property status in model JobStep"));
        }
        if (statistics() != null) {
            statistics().validate();
        }
        if (steps() != null) {
            steps().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(JobStep.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("status", this.status == null ? null : this.status.toString());
        jsonWriter.writeStringField("startTime",
            this.startTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.startTime));
        jsonWriter.writeStringField("endTime",
            this.endTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.endTime));
        jsonWriter.writeStringField("message", this.message);
        jsonWriter.writeJsonField("statistics", this.statistics);
        jsonWriter.writeArrayField("steps", this.steps, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of JobStep from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of JobStep if the JsonReader was pointing to an instance of it, or null if it was pointing to
     * JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the JobStep.
     */
    public static JobStep fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            JobStep deserializedJobStep = new JobStep();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedJobStep.name = reader.getString();
                } else if ("status".equals(fieldName)) {
                    deserializedJobStep.status = JobStatus.fromString(reader.getString());
                } else if ("startTime".equals(fieldName)) {
                    deserializedJobStep.startTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("endTime".equals(fieldName)) {
                    deserializedJobStep.endTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("message".equals(fieldName)) {
                    deserializedJobStep.message = reader.getString();
                } else if ("statistics".equals(fieldName)) {
                    deserializedJobStep.statistics = JobStepStatisticsBase.fromJson(reader);
                } else if ("steps".equals(fieldName)) {
                    List<JobStep> steps = reader.readArray(reader1 -> JobStep.fromJson(reader1));
                    deserializedJobStep.steps = steps;
                } else if ("errorDetails".equals(fieldName)) {
                    deserializedJobStep.errorDetails = ManagementError.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedJobStep;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/JobStepStatisticsBase.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Base Job Step Statistics.
 */
@Immutable
public class JobStepStatisticsBase implements JsonSerializable<JobStepStatisticsBase> {
    /*
     * Statistics type discriminator value
     */
    private JobType statisticsType = JobType.fromString("JobStepStatisticsBase");

    /**
     * Creates an instance of JobStepStatisticsBase class.
     */
    protected JobStepStatisticsBase() {
    }

    /**
     * Get the statisticsType property: Statistics type discriminator value.
     * 
     * @return the statisticsType value.
     */
    public JobType statisticsType() {
        return this.statisticsType;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("statisticsType",
            this.statisticsType == null ? null : this.statisticsType.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of JobStepStatisticsBase from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of JobStepStatisticsBase if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the JobStepStatisticsBase.
     */
    public static JobStepStatisticsBase fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String discriminatorValue = null;
            try (JsonReader readerToUse = reader.bufferObject()) {
                readerToUse.nextToken(); // Prepare for reading
                while (readerToUse.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = readerToUse.getFieldName();
                    readerToUse.nextToken();
                    if ("statisticsType".equals(fieldName)) {
                        discriminatorValue = readerToUse.getString();
                        break;
                    } else {
                        readerToUse.skipChildren();
                    }
                }
                // Use the discriminator value to determine which subtype should be deserialized.
                if ("deploy".equals(discriminatorValue)) {
                    return DeployJobStepStatistics.fromJson(readerToUse.reset());
                } else {
                    return fromJsonKnownDiscriminator(readerToUse.reset());
                }
            }
        });
    }

    static JobStepStatisticsBase fromJsonKnownDiscriminator(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            JobStepStatisticsBase deserializedJobStepStatisticsBase = new JobStepStatisticsBase();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("statisticsType".equals(fieldName)) {
                    deserializedJobStepStatisticsBase.statisticsType = JobType.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedJobStepStatisticsBase;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/JobType.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * JobType for the job. Supports extensibility via string values.
 */
public final class JobType extends ExpandableStringEnum<JobType> {
    /**
     * A deployment job.
     */
    public static final JobType DEPLOY = fromString("deploy");

    /**
     * A staging job.
     */
    public static final JobType STAGING = fromString("staging");

    /**
     * A validation job.
     */
    public static final JobType EXTERNAL_VALIDATION = fromString("externalValidation");

    /**
     * Creates a new instance of JobType value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public JobType() {
    }

    /**
     * Creates or finds a JobType from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding JobType.
     */
    public static JobType fromString(String name) {
        return fromString(name, JobType.class);
    }

    /**
     * Gets known JobType values.
     * 
     * @return known JobType values.
     */
    public static Collection<JobType> values() {
        return values(JobType.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/OrchestratorType.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Available Orchestrator types.
 */
public final class OrchestratorType extends ExpandableStringEnum<OrchestratorType> {
    /**
     * Default type.
     */
    public static final OrchestratorType TO = fromString("TO");

    /**
     * Creates a new instance of OrchestratorType value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public OrchestratorType() {
    }

    /**
     * Creates or finds a OrchestratorType from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding OrchestratorType.
     */
    public static OrchestratorType fromString(String name) {
        return fromString(name, OrchestratorType.class);
    }

    /**
     * Gets known OrchestratorType values.
     * 
     * @return known OrchestratorType values.
     */
    public static Collection<OrchestratorType> values() {
        return values(OrchestratorType.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/package-info.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

/**
 * Package containing the data models for WorkloadOrchestration.
 * Microsoft.Edge Resource Provider management API.
 */
package com.azure.resourcemanager.workloadorchestration.models;



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ProvisioningState.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Provisioning state of resource.
 */
public final class ProvisioningState extends ExpandableStringEnum<ProvisioningState> {
    /**
     * Resource has been created.
     */
    public static final ProvisioningState SUCCEEDED = fromString("Succeeded");

    /**
     * Resource creation failed.
     */
    public static final ProvisioningState FAILED = fromString("Failed");

    /**
     * Resource creation was canceled.
     */
    public static final ProvisioningState CANCELED = fromString("Canceled");

    /**
     * Resource Provisioning is initialized.
     */
    public static final ProvisioningState INITIALIZED = fromString("Initialized");

    /**
     * Resource Provisioning is in progress.
     */
    public static final ProvisioningState INPROGRESS = fromString("InProgress");

    /**
     * Resource Provisioning is deleting.
     */
    public static final ProvisioningState DELETING = fromString("Deleting");

    /**
     * Creates a new instance of ProvisioningState value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public ProvisioningState() {
    }

    /**
     * Creates or finds a ProvisioningState from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding ProvisioningState.
     */
    public static ProvisioningState fromString(String name) {
        return fromString(name, ProvisioningState.class);
    }

    /**
     * Gets known ProvisioningState values.
     * 
     * @return known ProvisioningState values.
     */
    public static Collection<ProvisioningState> values() {
        return values(ProvisioningState.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ReconciliationPolicyProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Defines a ReconciliationPolicy.
 */
@Fluent
public final class ReconciliationPolicyProperties implements JsonSerializable<ReconciliationPolicyProperties> {
    /*
     * The state of the ReconciliationPolicy
     */
    private ReconciliationState state;

    /*
     * Policy interval
     */
    private String interval;

    /**
     * Creates an instance of ReconciliationPolicyProperties class.
     */
    public ReconciliationPolicyProperties() {
    }

    /**
     * Get the state property: The state of the ReconciliationPolicy.
     * 
     * @return the state value.
     */
    public ReconciliationState state() {
        return this.state;
    }

    /**
     * Set the state property: The state of the ReconciliationPolicy.
     * 
     * @param state the state value to set.
     * @return the ReconciliationPolicyProperties object itself.
     */
    public ReconciliationPolicyProperties withState(ReconciliationState state) {
        this.state = state;
        return this;
    }

    /**
     * Get the interval property: Policy interval.
     * 
     * @return the interval value.
     */
    public String interval() {
        return this.interval;
    }

    /**
     * Set the interval property: Policy interval.
     * 
     * @param interval the interval value to set.
     * @return the ReconciliationPolicyProperties object itself.
     */
    public ReconciliationPolicyProperties withInterval(String interval) {
        this.interval = interval;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (state() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property state in model ReconciliationPolicyProperties"));
        }
        if (interval() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property interval in model ReconciliationPolicyProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ReconciliationPolicyProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("state", this.state == null ? null : this.state.toString());
        jsonWriter.writeStringField("interval", this.interval);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ReconciliationPolicyProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ReconciliationPolicyProperties if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ReconciliationPolicyProperties.
     */
    public static ReconciliationPolicyProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ReconciliationPolicyProperties deserializedReconciliationPolicyProperties
                = new ReconciliationPolicyProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("state".equals(fieldName)) {
                    deserializedReconciliationPolicyProperties.state
                        = ReconciliationState.fromString(reader.getString());
                } else if ("interval".equals(fieldName)) {
                    deserializedReconciliationPolicyProperties.interval = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedReconciliationPolicyProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ReconciliationState.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Defines a state of the reconciliation policy.
 */
public final class ReconciliationState extends ExpandableStringEnum<ReconciliationState> {
    /**
     * Reconciliation is inactive.
     */
    public static final ReconciliationState INACTIVE = fromString("inactive");

    /**
     * Reconciliation is active.
     */
    public static final ReconciliationState ACTIVE = fromString("active");

    /**
     * Creates a new instance of ReconciliationState value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public ReconciliationState() {
    }

    /**
     * Creates or finds a ReconciliationState from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding ReconciliationState.
     */
    public static ReconciliationState fromString(String name) {
        return fromString(name, ReconciliationState.class);
    }

    /**
     * Gets known ReconciliationState values.
     * 
     * @return known ReconciliationState values.
     */
    public static Collection<ReconciliationState> values() {
        return values(ReconciliationState.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/RemoveRevisionParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Install Solution Parameter.
 */
@Fluent
public final class RemoveRevisionParameter implements JsonSerializable<RemoveRevisionParameter> {
    /*
     * Solution Template ARM Id
     */
    private String solutionTemplateId;

    /*
     * Solution Version Name
     */
    private String solutionVersion;

    /**
     * Creates an instance of RemoveRevisionParameter class.
     */
    public RemoveRevisionParameter() {
    }

    /**
     * Get the solutionTemplateId property: Solution Template ARM Id.
     * 
     * @return the solutionTemplateId value.
     */
    public String solutionTemplateId() {
        return this.solutionTemplateId;
    }

    /**
     * Set the solutionTemplateId property: Solution Template ARM Id.
     * 
     * @param solutionTemplateId the solutionTemplateId value to set.
     * @return the RemoveRevisionParameter object itself.
     */
    public RemoveRevisionParameter withSolutionTemplateId(String solutionTemplateId) {
        this.solutionTemplateId = solutionTemplateId;
        return this;
    }

    /**
     * Get the solutionVersion property: Solution Version Name.
     * 
     * @return the solutionVersion value.
     */
    public String solutionVersion() {
        return this.solutionVersion;
    }

    /**
     * Set the solutionVersion property: Solution Version Name.
     * 
     * @param solutionVersion the solutionVersion value to set.
     * @return the RemoveRevisionParameter object itself.
     */
    public RemoveRevisionParameter withSolutionVersion(String solutionVersion) {
        this.solutionVersion = solutionVersion;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionTemplateId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionTemplateId in model RemoveRevisionParameter"));
        }
        if (solutionVersion() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionVersion in model RemoveRevisionParameter"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(RemoveRevisionParameter.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionTemplateId", this.solutionTemplateId);
        jsonWriter.writeStringField("solutionVersion", this.solutionVersion);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of RemoveRevisionParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of RemoveRevisionParameter if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the RemoveRevisionParameter.
     */
    public static RemoveRevisionParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            RemoveRevisionParameter deserializedRemoveRevisionParameter = new RemoveRevisionParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionTemplateId".equals(fieldName)) {
                    deserializedRemoveRevisionParameter.solutionTemplateId = reader.getString();
                } else if ("solutionVersion".equals(fieldName)) {
                    deserializedRemoveRevisionParameter.solutionVersion = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedRemoveRevisionParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/RemoveVersionResponse.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner;

/**
 * An immutable client-side representation of RemoveVersionResponse.
 */
public interface RemoveVersionResponse {
    /**
     * Gets the status property: Status for remove version response.
     * 
     * @return the status value.
     */
    String status();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner object.
     * 
     * @return the inner object.
     */
    RemoveVersionResponseInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ResolvedConfiguration.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.resourcemanager.workloadorchestration.fluent.models.ResolvedConfigurationInner;

/**
 * An immutable client-side representation of ResolvedConfiguration.
 */
public interface ResolvedConfiguration {
    /**
     * Gets the configuration property: Resolved Configuration as string.
     * 
     * @return the configuration value.
     */
    String configuration();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.ResolvedConfigurationInner object.
     * 
     * @return the inner object.
     */
    ResolvedConfigurationInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ResourceState.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Resource Type State.
 */
public final class ResourceState extends ExpandableStringEnum<ResourceState> {
    /**
     * Resource is active.
     */
    public static final ResourceState ACTIVE = fromString("active");

    /**
     * Resource is inactive.
     */
    public static final ResourceState INACTIVE = fromString("inactive");

    /**
     * Creates a new instance of ResourceState value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public ResourceState() {
    }

    /**
     * Creates or finds a ResourceState from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding ResourceState.
     */
    public static ResourceState fromString(String name) {
        return fromString(name, ResourceState.class);
    }

    /**
     * Gets known ResourceState values.
     * 
     * @return known ResourceState values.
     */
    public static Collection<ResourceState> values() {
        return values(ResourceState.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Schema.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.Response;
import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import java.util.Map;

/**
 * An immutable client-side representation of Schema.
 */
public interface Schema {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the location property: The geo-location where the resource lives.
     * 
     * @return the location value.
     */
    String location();

    /**
     * Gets the tags property: Resource tags.
     * 
     * @return the tags value.
     */
    Map<String, String> tags();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    SchemaProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the region of the resource.
     * 
     * @return the region of the resource.
     */
    Region region();

    /**
     * Gets the name of the resource region.
     * 
     * @return the name of the resource region.
     */
    String regionName();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner object.
     * 
     * @return the inner object.
     */
    SchemaInner innerModel();

    /**
     * The entirety of the Schema definition.
     */
    interface Definition extends DefinitionStages.Blank, DefinitionStages.WithLocation,
        DefinitionStages.WithResourceGroup, DefinitionStages.WithCreate {
    }

    /**
     * The Schema definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the Schema definition.
         */
        interface Blank extends WithLocation {
        }

        /**
         * The stage of the Schema definition allowing to specify location.
         */
        interface WithLocation {
            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(Region location);

            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(String location);
        }

        /**
         * The stage of the Schema definition allowing to specify parent resource.
         */
        interface WithResourceGroup {
            /**
             * Specifies resourceGroupName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @return the next definition stage.
             */
            WithCreate withExistingResourceGroup(String resourceGroupName);
        }

        /**
         * The stage of the Schema definition which contains all the minimum required properties for the resource to be
         * created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithTags, DefinitionStages.WithProperties {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            Schema create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            Schema create(Context context);
        }

        /**
         * The stage of the Schema definition allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            WithCreate withTags(Map<String, String> tags);
        }

        /**
         * The stage of the Schema definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(SchemaProperties properties);
        }
    }

    /**
     * Begins update for the Schema resource.
     * 
     * @return the stage of resource update.
     */
    Schema.Update update();

    /**
     * The template for Schema update.
     */
    interface Update extends UpdateStages.WithTags, UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        Schema apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        Schema apply(Context context);
    }

    /**
     * The Schema update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the Schema update allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            Update withTags(Map<String, String> tags);
        }

        /**
         * The stage of the Schema update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(SchemaProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    Schema refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    Schema refresh(Context context);

    /**
     * Create a Schema Version Resource.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SchemaVersion createVersion(SchemaVersionWithUpdateTypeInner body);

    /**
     * Create a Schema Version Resource.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SchemaVersion createVersion(SchemaVersionWithUpdateTypeInner body, Context context);

    /**
     * Remove Schema Version Resource.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response}.
     */
    Response<RemoveVersionResponse> removeVersionWithResponse(VersionParameter body, Context context);

    /**
     * Remove Schema Version Resource.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response.
     */
    RemoveVersionResponse removeVersion(VersionParameter body);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SchemaProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Schema Properties.
 */
@Immutable
public final class SchemaProperties implements JsonSerializable<SchemaProperties> {
    /*
     * Current Version of schema
     */
    private String currentVersion;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of SchemaProperties class.
     */
    public SchemaProperties() {
    }

    /**
     * Get the currentVersion property: Current Version of schema.
     * 
     * @return the currentVersion value.
     */
    public String currentVersion() {
        return this.currentVersion;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the SchemaProperties.
     */
    public static SchemaProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaProperties deserializedSchemaProperties = new SchemaProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("currentVersion".equals(fieldName)) {
                    deserializedSchemaProperties.currentVersion = reader.getString();
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedSchemaProperties.provisioningState = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SchemaReference.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner;

/**
 * An immutable client-side representation of SchemaReference.
 */
public interface SchemaReference {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    SchemaReferenceProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner object.
     * 
     * @return the inner object.
     */
    SchemaReferenceInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SchemaReferenceProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Schema Reference Properties.
 */
@Immutable
public final class SchemaReferenceProperties implements JsonSerializable<SchemaReferenceProperties> {
    /*
     * Schema Id of schema reference
     */
    private String schemaId;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of SchemaReferenceProperties class.
     */
    private SchemaReferenceProperties() {
    }

    /**
     * Get the schemaId property: Schema Id of schema reference.
     * 
     * @return the schemaId value.
     */
    public String schemaId() {
        return this.schemaId;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (schemaId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property schemaId in model SchemaReferenceProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemaReferenceProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("schemaId", this.schemaId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaReferenceProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaReferenceProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaReferenceProperties.
     */
    public static SchemaReferenceProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaReferenceProperties deserializedSchemaReferenceProperties = new SchemaReferenceProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("schemaId".equals(fieldName)) {
                    deserializedSchemaReferenceProperties.schemaId = reader.getString();
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedSchemaReferenceProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaReferenceProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SchemaReferences.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of SchemaReferences.
 */
public interface SchemaReferences {
    /**
     * Get a Schema Reference Resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param schemaReferenceName The name of the SchemaReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Reference Resource along with {@link Response}.
     */
    Response<SchemaReference> getWithResponse(String resourceUri, String schemaReferenceName, Context context);

    /**
     * Get a Schema Reference Resource.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param schemaReferenceName The name of the SchemaReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Reference Resource.
     */
    SchemaReference get(String resourceUri, String schemaReferenceName);

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SchemaReference> listByResourceGroup(String resourceUri);

    /**
     * List by specified resource group.
     * 
     * @param resourceUri The fully qualified Azure Resource manager identifier of the resource.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaReference list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SchemaReference> listByResourceGroup(String resourceUri, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Schemas.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;

/**
 * Resource collection API of Schemas.
 */
public interface Schemas {
    /**
     * Get a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource along with {@link Response}.
     */
    Response<Schema> getByResourceGroupWithResponse(String resourceGroupName, String schemaName, Context context);

    /**
     * Get a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource.
     */
    Schema getByResourceGroup(String resourceGroupName, String schemaName);

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByResourceGroup(String resourceGroupName, String schemaName);

    /**
     * Delete a Schema Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String schemaName, Context context);

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SchemaVersion createVersion(String resourceGroupName, String schemaName, SchemaVersionWithUpdateTypeInner body);

    /**
     * Create a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SchemaVersion createVersion(String resourceGroupName, String schemaName, SchemaVersionWithUpdateTypeInner body,
        Context context);

    /**
     * Remove Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response along with {@link Response}.
     */
    Response<RemoveVersionResponse> removeVersionWithResponse(String resourceGroupName, String schemaName,
        VersionParameter body, Context context);

    /**
     * Remove Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return remove Version response.
     */
    RemoveVersionResponse removeVersion(String resourceGroupName, String schemaName, VersionParameter body);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Schema> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Schema> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Schema> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Schema list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Schema> list(Context context);

    /**
     * Get a Schema Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource along with {@link Response}.
     */
    Schema getById(String id);

    /**
     * Get a Schema Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Resource along with {@link Response}.
     */
    Response<Schema> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Schema Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Schema Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new Schema resource.
     * 
     * @param name resource name.
     * @return the first stage of the new Schema definition.
     */
    Schema.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SchemaVersion.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;

/**
 * An immutable client-side representation of SchemaVersion.
 */
public interface SchemaVersion {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    SchemaVersionProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner object.
     * 
     * @return the inner object.
     */
    SchemaVersionInner innerModel();

    /**
     * The entirety of the SchemaVersion definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The SchemaVersion definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the SchemaVersion definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the SchemaVersion definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, schemaName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param schemaName The name of the Schema.
             * @return the next definition stage.
             */
            WithCreate withExistingSchema(String resourceGroupName, String schemaName);
        }

        /**
         * The stage of the SchemaVersion definition which contains all the minimum required properties for the resource
         * to be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            SchemaVersion create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            SchemaVersion create(Context context);
        }

        /**
         * The stage of the SchemaVersion definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(SchemaVersionProperties properties);
        }
    }

    /**
     * Begins update for the SchemaVersion resource.
     * 
     * @return the stage of resource update.
     */
    SchemaVersion.Update update();

    /**
     * The template for SchemaVersion update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        SchemaVersion apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        SchemaVersion apply(Context context);
    }

    /**
     * The SchemaVersion update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the SchemaVersion update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(SchemaVersionProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    SchemaVersion refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    SchemaVersion refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SchemaVersionProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Schema Version Properties.
 */
@Fluent
public final class SchemaVersionProperties implements JsonSerializable<SchemaVersionProperties> {
    /*
     * Value of schema version
     */
    private String value;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of SchemaVersionProperties class.
     */
    public SchemaVersionProperties() {
    }

    /**
     * Get the value property: Value of schema version.
     * 
     * @return the value value.
     */
    public String value() {
        return this.value;
    }

    /**
     * Set the value property: Value of schema version.
     * 
     * @param value the value value to set.
     * @return the SchemaVersionProperties object itself.
     */
    public SchemaVersionProperties withValue(String value) {
        this.value = value;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (value() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property value in model SchemaVersionProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemaVersionProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("value", this.value);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaVersionProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaVersionProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaVersionProperties.
     */
    public static SchemaVersionProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaVersionProperties deserializedSchemaVersionProperties = new SchemaVersionProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("value".equals(fieldName)) {
                    deserializedSchemaVersionProperties.value = reader.getString();
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedSchemaVersionProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaVersionProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SchemaVersions.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of SchemaVersions.
 */
public interface SchemaVersions {
    /**
     * Get a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource along with {@link Response}.
     */
    Response<SchemaVersion> getWithResponse(String resourceGroupName, String schemaName, String schemaVersionName,
        Context context);

    /**
     * Get a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource.
     */
    SchemaVersion get(String resourceGroupName, String schemaName, String schemaVersionName);

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String schemaName, String schemaVersionName);

    /**
     * Delete a Schema Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param schemaVersionName The name of the SchemaVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String schemaName, String schemaVersionName, Context context);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SchemaVersion> listBySchema(String resourceGroupName, String schemaName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param schemaName The name of the Schema.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SchemaVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SchemaVersion> listBySchema(String resourceGroupName, String schemaName, Context context);

    /**
     * Get a Schema Version Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource along with {@link Response}.
     */
    SchemaVersion getById(String id);

    /**
     * Get a Schema Version Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Schema Version Resource along with {@link Response}.
     */
    Response<SchemaVersion> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Schema Version Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Schema Version Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new SchemaVersion resource.
     * 
     * @param name resource name.
     * @return the first stage of the new SchemaVersion definition.
     */
    SchemaVersion.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SchemaVersionWithUpdateType.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;

/**
 * An immutable client-side representation of SchemaVersionWithUpdateType.
 */
public interface SchemaVersionWithUpdateType {
    /**
     * Gets the updateType property: Update type.
     * 
     * @return the updateType value.
     */
    UpdateType updateType();

    /**
     * Gets the version property: Version to create.
     * 
     * @return the version value.
     */
    String version();

    /**
     * Gets the schemaVersion property: Schema Version.
     * 
     * @return the schemaVersion value.
     */
    SchemaVersion schemaVersion();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner
     * object.
     * 
     * @return the inner object.
     */
    SchemaVersionWithUpdateTypeInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SiteReference.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner;

/**
 * An immutable client-side representation of SiteReference.
 */
public interface SiteReference {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    SiteReferenceProperties properties();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner object.
     * 
     * @return the inner object.
     */
    SiteReferenceInner innerModel();

    /**
     * The entirety of the SiteReference definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The SiteReference definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the SiteReference definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the SiteReference definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, contextName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param contextName The name of the Context.
             * @return the next definition stage.
             */
            WithCreate withExistingContext(String resourceGroupName, String contextName);
        }

        /**
         * The stage of the SiteReference definition which contains all the minimum required properties for the resource
         * to be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            SiteReference create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            SiteReference create(Context context);
        }

        /**
         * The stage of the SiteReference definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(SiteReferenceProperties properties);
        }
    }

    /**
     * Begins update for the SiteReference resource.
     * 
     * @return the stage of resource update.
     */
    SiteReference.Update update();

    /**
     * The template for SiteReference update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        SiteReference apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        SiteReference apply(Context context);
    }

    /**
     * The SiteReference update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the SiteReference update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(SiteReferenceProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    SiteReference refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    SiteReference refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SiteReferenceProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Site Reference Properties.
 */
@Fluent
public final class SiteReferenceProperties implements JsonSerializable<SiteReferenceProperties> {
    /*
     * Azure Resource ID for Site
     */
    private String siteId;

    /*
     * Provisioning State
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of SiteReferenceProperties class.
     */
    public SiteReferenceProperties() {
    }

    /**
     * Get the siteId property: Azure Resource ID for Site.
     * 
     * @return the siteId value.
     */
    public String siteId() {
        return this.siteId;
    }

    /**
     * Set the siteId property: Azure Resource ID for Site.
     * 
     * @param siteId the siteId value to set.
     * @return the SiteReferenceProperties object itself.
     */
    public SiteReferenceProperties withSiteId(String siteId) {
        this.siteId = siteId;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning State.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (siteId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property siteId in model SiteReferenceProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SiteReferenceProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("siteId", this.siteId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SiteReferenceProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SiteReferenceProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SiteReferenceProperties.
     */
    public static SiteReferenceProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SiteReferenceProperties deserializedSiteReferenceProperties = new SiteReferenceProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("siteId".equals(fieldName)) {
                    deserializedSiteReferenceProperties.siteId = reader.getString();
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedSiteReferenceProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSiteReferenceProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SiteReferences.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of SiteReferences.
 */
public interface SiteReferences {
    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    Response<SiteReference> getWithResponse(String resourceGroupName, String contextName, String siteReferenceName,
        Context context);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource.
     */
    SiteReference get(String resourceGroupName, String contextName, String siteReferenceName);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String contextName, String siteReferenceName);

    /**
     * Get Site Reference Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param siteReferenceName The name of the SiteReference.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String contextName, String siteReferenceName, Context context);

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SiteReference> listByContext(String resourceGroupName, String contextName);

    /**
     * List Site Reference Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SiteReference list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SiteReference> listByContext(String resourceGroupName, String contextName, Context context);

    /**
     * Get Site Reference Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    SiteReference getById(String id);

    /**
     * Get Site Reference Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return site Reference Resource along with {@link Response}.
     */
    Response<SiteReference> getByIdWithResponse(String id, Context context);

    /**
     * Get Site Reference Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Get Site Reference Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new SiteReference resource.
     * 
     * @param name resource name.
     * @return the first stage of the new SiteReference definition.
     */
    SiteReference.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Solution.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner;

/**
 * An immutable client-side representation of Solution.
 */
public interface Solution {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    SolutionProperties properties();

    /**
     * Gets the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    ExtendedLocation extendedLocation();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner object.
     * 
     * @return the inner object.
     */
    SolutionInner innerModel();

    /**
     * The entirety of the Solution definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The Solution definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the Solution definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the Solution definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, targetName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param targetName Name of the target.
             * @return the next definition stage.
             */
            WithCreate withExistingTarget(String resourceGroupName, String targetName);
        }

        /**
         * The stage of the Solution definition which contains all the minimum required properties for the resource to
         * be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties, DefinitionStages.WithExtendedLocation {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            Solution create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            Solution create(Context context);
        }

        /**
         * The stage of the Solution definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(SolutionProperties properties);
        }

        /**
         * The stage of the Solution definition allowing to specify extendedLocation.
         */
        interface WithExtendedLocation {
            /**
             * Specifies the extendedLocation property: The extendedLocation property..
             * 
             * @param extendedLocation The extendedLocation property.
             * @return the next definition stage.
             */
            WithCreate withExtendedLocation(ExtendedLocation extendedLocation);
        }
    }

    /**
     * Begins update for the Solution resource.
     * 
     * @return the stage of resource update.
     */
    Solution.Update update();

    /**
     * The template for Solution update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        Solution apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        Solution apply(Context context);
    }

    /**
     * The Solution update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the Solution update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(SolutionProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    Solution refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    Solution refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionDependency.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Solution Dependency Context.
 */
@Immutable
public final class SolutionDependency implements JsonSerializable<SolutionDependency> {
    /*
     * Solution Version Id
     */
    private String solutionVersionId;

    /*
     * Solution Instance Name
     */
    private String solutionInstanceName;

    /*
     * Solution Template Version Id
     */
    private String solutionTemplateVersionId;

    /*
     * Target Id
     */
    private String targetId;

    /*
     * Solution dependencies
     */
    private List<SolutionDependency> dependencies;

    /**
     * Creates an instance of SolutionDependency class.
     */
    private SolutionDependency() {
    }

    /**
     * Get the solutionVersionId property: Solution Version Id.
     * 
     * @return the solutionVersionId value.
     */
    public String solutionVersionId() {
        return this.solutionVersionId;
    }

    /**
     * Get the solutionInstanceName property: Solution Instance Name.
     * 
     * @return the solutionInstanceName value.
     */
    public String solutionInstanceName() {
        return this.solutionInstanceName;
    }

    /**
     * Get the solutionTemplateVersionId property: Solution Template Version Id.
     * 
     * @return the solutionTemplateVersionId value.
     */
    public String solutionTemplateVersionId() {
        return this.solutionTemplateVersionId;
    }

    /**
     * Get the targetId property: Target Id.
     * 
     * @return the targetId value.
     */
    public String targetId() {
        return this.targetId;
    }

    /**
     * Get the dependencies property: Solution dependencies.
     * 
     * @return the dependencies value.
     */
    public List<SolutionDependency> dependencies() {
        return this.dependencies;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionVersionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionVersionId in model SolutionDependency"));
        }
        if (solutionTemplateVersionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionTemplateVersionId in model SolutionDependency"));
        }
        if (targetId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property targetId in model SolutionDependency"));
        }
        if (dependencies() != null) {
            dependencies().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionDependency.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionVersionId", this.solutionVersionId);
        jsonWriter.writeStringField("solutionTemplateVersionId", this.solutionTemplateVersionId);
        jsonWriter.writeStringField("targetId", this.targetId);
        jsonWriter.writeStringField("solutionInstanceName", this.solutionInstanceName);
        jsonWriter.writeArrayField("dependencies", this.dependencies, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionDependency from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionDependency if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionDependency.
     */
    public static SolutionDependency fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionDependency deserializedSolutionDependency = new SolutionDependency();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionVersionId".equals(fieldName)) {
                    deserializedSolutionDependency.solutionVersionId = reader.getString();
                } else if ("solutionTemplateVersionId".equals(fieldName)) {
                    deserializedSolutionDependency.solutionTemplateVersionId = reader.getString();
                } else if ("targetId".equals(fieldName)) {
                    deserializedSolutionDependency.targetId = reader.getString();
                } else if ("solutionInstanceName".equals(fieldName)) {
                    deserializedSolutionDependency.solutionInstanceName = reader.getString();
                } else if ("dependencies".equals(fieldName)) {
                    List<SolutionDependency> dependencies
                        = reader.readArray(reader1 -> SolutionDependency.fromJson(reader1));
                    deserializedSolutionDependency.dependencies = dependencies;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionDependency;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionDependencyParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Solution Dependency Context.
 */
@Fluent
public final class SolutionDependencyParameter implements JsonSerializable<SolutionDependencyParameter> {
    /*
     * Solution Version Id
     */
    private String solutionVersionId;

    /*
     * Solution Template Id
     */
    private String solutionTemplateId;

    /*
     * Solution Template Version
     */
    private String solutionTemplateVersion;

    /*
     * Solution Instance Name
     */
    private String solutionInstanceName;

    /*
     * Target Id
     */
    private String targetId;

    /*
     * Solution dependencies
     */
    private List<SolutionDependencyParameter> dependencies;

    /**
     * Creates an instance of SolutionDependencyParameter class.
     */
    public SolutionDependencyParameter() {
    }

    /**
     * Get the solutionVersionId property: Solution Version Id.
     * 
     * @return the solutionVersionId value.
     */
    public String solutionVersionId() {
        return this.solutionVersionId;
    }

    /**
     * Set the solutionVersionId property: Solution Version Id.
     * 
     * @param solutionVersionId the solutionVersionId value to set.
     * @return the SolutionDependencyParameter object itself.
     */
    public SolutionDependencyParameter withSolutionVersionId(String solutionVersionId) {
        this.solutionVersionId = solutionVersionId;
        return this;
    }

    /**
     * Get the solutionTemplateId property: Solution Template Id.
     * 
     * @return the solutionTemplateId value.
     */
    public String solutionTemplateId() {
        return this.solutionTemplateId;
    }

    /**
     * Set the solutionTemplateId property: Solution Template Id.
     * 
     * @param solutionTemplateId the solutionTemplateId value to set.
     * @return the SolutionDependencyParameter object itself.
     */
    public SolutionDependencyParameter withSolutionTemplateId(String solutionTemplateId) {
        this.solutionTemplateId = solutionTemplateId;
        return this;
    }

    /**
     * Get the solutionTemplateVersion property: Solution Template Version.
     * 
     * @return the solutionTemplateVersion value.
     */
    public String solutionTemplateVersion() {
        return this.solutionTemplateVersion;
    }

    /**
     * Set the solutionTemplateVersion property: Solution Template Version.
     * 
     * @param solutionTemplateVersion the solutionTemplateVersion value to set.
     * @return the SolutionDependencyParameter object itself.
     */
    public SolutionDependencyParameter withSolutionTemplateVersion(String solutionTemplateVersion) {
        this.solutionTemplateVersion = solutionTemplateVersion;
        return this;
    }

    /**
     * Get the solutionInstanceName property: Solution Instance Name.
     * 
     * @return the solutionInstanceName value.
     */
    public String solutionInstanceName() {
        return this.solutionInstanceName;
    }

    /**
     * Set the solutionInstanceName property: Solution Instance Name.
     * 
     * @param solutionInstanceName the solutionInstanceName value to set.
     * @return the SolutionDependencyParameter object itself.
     */
    public SolutionDependencyParameter withSolutionInstanceName(String solutionInstanceName) {
        this.solutionInstanceName = solutionInstanceName;
        return this;
    }

    /**
     * Get the targetId property: Target Id.
     * 
     * @return the targetId value.
     */
    public String targetId() {
        return this.targetId;
    }

    /**
     * Set the targetId property: Target Id.
     * 
     * @param targetId the targetId value to set.
     * @return the SolutionDependencyParameter object itself.
     */
    public SolutionDependencyParameter withTargetId(String targetId) {
        this.targetId = targetId;
        return this;
    }

    /**
     * Get the dependencies property: Solution dependencies.
     * 
     * @return the dependencies value.
     */
    public List<SolutionDependencyParameter> dependencies() {
        return this.dependencies;
    }

    /**
     * Set the dependencies property: Solution dependencies.
     * 
     * @param dependencies the dependencies value to set.
     * @return the SolutionDependencyParameter object itself.
     */
    public SolutionDependencyParameter withDependencies(List<SolutionDependencyParameter> dependencies) {
        this.dependencies = dependencies;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (dependencies() != null) {
            dependencies().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionVersionId", this.solutionVersionId);
        jsonWriter.writeStringField("solutionTemplateId", this.solutionTemplateId);
        jsonWriter.writeStringField("solutionTemplateVersion", this.solutionTemplateVersion);
        jsonWriter.writeStringField("solutionInstanceName", this.solutionInstanceName);
        jsonWriter.writeStringField("targetId", this.targetId);
        jsonWriter.writeArrayField("dependencies", this.dependencies, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionDependencyParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionDependencyParameter if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the SolutionDependencyParameter.
     */
    public static SolutionDependencyParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionDependencyParameter deserializedSolutionDependencyParameter = new SolutionDependencyParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionVersionId".equals(fieldName)) {
                    deserializedSolutionDependencyParameter.solutionVersionId = reader.getString();
                } else if ("solutionTemplateId".equals(fieldName)) {
                    deserializedSolutionDependencyParameter.solutionTemplateId = reader.getString();
                } else if ("solutionTemplateVersion".equals(fieldName)) {
                    deserializedSolutionDependencyParameter.solutionTemplateVersion = reader.getString();
                } else if ("solutionInstanceName".equals(fieldName)) {
                    deserializedSolutionDependencyParameter.solutionInstanceName = reader.getString();
                } else if ("targetId".equals(fieldName)) {
                    deserializedSolutionDependencyParameter.targetId = reader.getString();
                } else if ("dependencies".equals(fieldName)) {
                    List<SolutionDependencyParameter> dependencies
                        = reader.readArray(reader1 -> SolutionDependencyParameter.fromJson(reader1));
                    deserializedSolutionDependencyParameter.dependencies = dependencies;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionDependencyParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Solution Properties.
 */
@Immutable
public final class SolutionProperties implements JsonSerializable<SolutionProperties> {
    /*
     * Solution template Id
     */
    private String solutionTemplateId;

    /*
     * List of latest revisions for available solution template versions
     */
    private List<AvailableSolutionTemplateVersion> availableSolutionTemplateVersions;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of SolutionProperties class.
     */
    public SolutionProperties() {
    }

    /**
     * Get the solutionTemplateId property: Solution template Id.
     * 
     * @return the solutionTemplateId value.
     */
    public String solutionTemplateId() {
        return this.solutionTemplateId;
    }

    /**
     * Get the availableSolutionTemplateVersions property: List of latest revisions for available solution template
     * versions.
     * 
     * @return the availableSolutionTemplateVersions value.
     */
    public List<AvailableSolutionTemplateVersion> availableSolutionTemplateVersions() {
        return this.availableSolutionTemplateVersions;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (availableSolutionTemplateVersions() != null) {
            availableSolutionTemplateVersions().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the SolutionProperties.
     */
    public static SolutionProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionProperties deserializedSolutionProperties = new SolutionProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionTemplateId".equals(fieldName)) {
                    deserializedSolutionProperties.solutionTemplateId = reader.getString();
                } else if ("availableSolutionTemplateVersions".equals(fieldName)) {
                    List<AvailableSolutionTemplateVersion> availableSolutionTemplateVersions
                        = reader.readArray(reader1 -> AvailableSolutionTemplateVersion.fromJson(reader1));
                    deserializedSolutionProperties.availableSolutionTemplateVersions
                        = availableSolutionTemplateVersions;
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedSolutionProperties.provisioningState = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Solutions.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of Solutions.
 */
public interface Solutions {
    /**
     * Get a Solution resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource along with {@link Response}.
     */
    Response<Solution> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        Context context);

    /**
     * Get a Solution resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource.
     */
    Solution get(String resourceGroupName, String targetName, String solutionName);

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String targetName, String solutionName);

    /**
     * Delete a Solution Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String targetName, String solutionName, Context context);

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Solution> listByTarget(String resourceGroupName, String targetName);

    /**
     * List Solution resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Solution list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Solution> listByTarget(String resourceGroupName, String targetName, Context context);

    /**
     * Get a Solution resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource along with {@link Response}.
     */
    Solution getById(String id);

    /**
     * Get a Solution resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution resource along with {@link Response}.
     */
    Response<Solution> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Solution Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Solution Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new Solution resource.
     * 
     * @param name resource name.
     * @return the first stage of the new Solution definition.
     */
    Solution.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionTemplate.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import java.util.Map;

/**
 * An immutable client-side representation of SolutionTemplate.
 */
public interface SolutionTemplate {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the location property: The geo-location where the resource lives.
     * 
     * @return the location value.
     */
    String location();

    /**
     * Gets the tags property: Resource tags.
     * 
     * @return the tags value.
     */
    Map<String, String> tags();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    SolutionTemplateProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the region of the resource.
     * 
     * @return the region of the resource.
     */
    Region region();

    /**
     * Gets the name of the resource region.
     * 
     * @return the name of the resource region.
     */
    String regionName();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner object.
     * 
     * @return the inner object.
     */
    SolutionTemplateInner innerModel();

    /**
     * The entirety of the SolutionTemplate definition.
     */
    interface Definition extends DefinitionStages.Blank, DefinitionStages.WithLocation,
        DefinitionStages.WithResourceGroup, DefinitionStages.WithCreate {
    }

    /**
     * The SolutionTemplate definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the SolutionTemplate definition.
         */
        interface Blank extends WithLocation {
        }

        /**
         * The stage of the SolutionTemplate definition allowing to specify location.
         */
        interface WithLocation {
            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(Region location);

            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(String location);
        }

        /**
         * The stage of the SolutionTemplate definition allowing to specify parent resource.
         */
        interface WithResourceGroup {
            /**
             * Specifies resourceGroupName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @return the next definition stage.
             */
            WithCreate withExistingResourceGroup(String resourceGroupName);
        }

        /**
         * The stage of the SolutionTemplate definition which contains all the minimum required properties for the
         * resource to be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithTags, DefinitionStages.WithProperties {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            SolutionTemplate create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            SolutionTemplate create(Context context);
        }

        /**
         * The stage of the SolutionTemplate definition allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            WithCreate withTags(Map<String, String> tags);
        }

        /**
         * The stage of the SolutionTemplate definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(SolutionTemplateProperties properties);
        }
    }

    /**
     * Begins update for the SolutionTemplate resource.
     * 
     * @return the stage of resource update.
     */
    SolutionTemplate.Update update();

    /**
     * The template for SolutionTemplate update.
     */
    interface Update extends UpdateStages.WithTags, UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        SolutionTemplate apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        SolutionTemplate apply(Context context);
    }

    /**
     * The SolutionTemplate update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the SolutionTemplate update allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            Update withTags(Map<String, String> tags);
        }

        /**
         * The stage of the SolutionTemplate update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(SolutionTemplateProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    SolutionTemplate refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    SolutionTemplate refresh(Context context);

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionTemplateVersion createVersion(SolutionTemplateVersionWithUpdateTypeInner body);

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionTemplateVersion createVersion(SolutionTemplateVersionWithUpdateTypeInner body, Context context);

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void removeVersion(VersionParameter body);

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void removeVersion(VersionParameter body, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionTemplateParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Solution Template Parameter.
 */
@Fluent
public final class SolutionTemplateParameter implements JsonSerializable<SolutionTemplateParameter> {
    /*
     * Solution Template Version ARM Id
     */
    private String solutionTemplateVersionId;

    /*
     * Solution Instance Name
     */
    private String solutionInstanceName;

    /*
     * Solution Dependencies
     */
    private List<SolutionDependencyParameter> solutionDependencies;

    /**
     * Creates an instance of SolutionTemplateParameter class.
     */
    public SolutionTemplateParameter() {
    }

    /**
     * Get the solutionTemplateVersionId property: Solution Template Version ARM Id.
     * 
     * @return the solutionTemplateVersionId value.
     */
    public String solutionTemplateVersionId() {
        return this.solutionTemplateVersionId;
    }

    /**
     * Set the solutionTemplateVersionId property: Solution Template Version ARM Id.
     * 
     * @param solutionTemplateVersionId the solutionTemplateVersionId value to set.
     * @return the SolutionTemplateParameter object itself.
     */
    public SolutionTemplateParameter withSolutionTemplateVersionId(String solutionTemplateVersionId) {
        this.solutionTemplateVersionId = solutionTemplateVersionId;
        return this;
    }

    /**
     * Get the solutionInstanceName property: Solution Instance Name.
     * 
     * @return the solutionInstanceName value.
     */
    public String solutionInstanceName() {
        return this.solutionInstanceName;
    }

    /**
     * Set the solutionInstanceName property: Solution Instance Name.
     * 
     * @param solutionInstanceName the solutionInstanceName value to set.
     * @return the SolutionTemplateParameter object itself.
     */
    public SolutionTemplateParameter withSolutionInstanceName(String solutionInstanceName) {
        this.solutionInstanceName = solutionInstanceName;
        return this;
    }

    /**
     * Get the solutionDependencies property: Solution Dependencies.
     * 
     * @return the solutionDependencies value.
     */
    public List<SolutionDependencyParameter> solutionDependencies() {
        return this.solutionDependencies;
    }

    /**
     * Set the solutionDependencies property: Solution Dependencies.
     * 
     * @param solutionDependencies the solutionDependencies value to set.
     * @return the SolutionTemplateParameter object itself.
     */
    public SolutionTemplateParameter withSolutionDependencies(List<SolutionDependencyParameter> solutionDependencies) {
        this.solutionDependencies = solutionDependencies;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionTemplateVersionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionTemplateVersionId in model SolutionTemplateParameter"));
        }
        if (solutionDependencies() != null) {
            solutionDependencies().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplateParameter.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionTemplateVersionId", this.solutionTemplateVersionId);
        jsonWriter.writeStringField("solutionInstanceName", this.solutionInstanceName);
        jsonWriter.writeArrayField("solutionDependencies", this.solutionDependencies,
            (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionTemplateParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionTemplateParameter if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionTemplateParameter.
     */
    public static SolutionTemplateParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionTemplateParameter deserializedSolutionTemplateParameter = new SolutionTemplateParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionTemplateVersionId".equals(fieldName)) {
                    deserializedSolutionTemplateParameter.solutionTemplateVersionId = reader.getString();
                } else if ("solutionInstanceName".equals(fieldName)) {
                    deserializedSolutionTemplateParameter.solutionInstanceName = reader.getString();
                } else if ("solutionDependencies".equals(fieldName)) {
                    List<SolutionDependencyParameter> solutionDependencies
                        = reader.readArray(reader1 -> SolutionDependencyParameter.fromJson(reader1));
                    deserializedSolutionTemplateParameter.solutionDependencies = solutionDependencies;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionTemplateParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionTemplateProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Solution Template Properties.
 */
@Fluent
public final class SolutionTemplateProperties implements JsonSerializable<SolutionTemplateProperties> {
    /*
     * Description of Solution template
     */
    private String description;

    /*
     * List of capabilities
     */
    private List<String> capabilities;

    /*
     * Latest solution template version
     */
    private String latestVersion;

    /*
     * State of resource
     */
    private ResourceState state;

    /*
     * Flag to enable external validation
     */
    private Boolean enableExternalValidation;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of SolutionTemplateProperties class.
     */
    public SolutionTemplateProperties() {
    }

    /**
     * Get the description property: Description of Solution template.
     * 
     * @return the description value.
     */
    public String description() {
        return this.description;
    }

    /**
     * Set the description property: Description of Solution template.
     * 
     * @param description the description value to set.
     * @return the SolutionTemplateProperties object itself.
     */
    public SolutionTemplateProperties withDescription(String description) {
        this.description = description;
        return this;
    }

    /**
     * Get the capabilities property: List of capabilities.
     * 
     * @return the capabilities value.
     */
    public List<String> capabilities() {
        return this.capabilities;
    }

    /**
     * Set the capabilities property: List of capabilities.
     * 
     * @param capabilities the capabilities value to set.
     * @return the SolutionTemplateProperties object itself.
     */
    public SolutionTemplateProperties withCapabilities(List<String> capabilities) {
        this.capabilities = capabilities;
        return this;
    }

    /**
     * Get the latestVersion property: Latest solution template version.
     * 
     * @return the latestVersion value.
     */
    public String latestVersion() {
        return this.latestVersion;
    }

    /**
     * Get the state property: State of resource.
     * 
     * @return the state value.
     */
    public ResourceState state() {
        return this.state;
    }

    /**
     * Set the state property: State of resource.
     * 
     * @param state the state value to set.
     * @return the SolutionTemplateProperties object itself.
     */
    public SolutionTemplateProperties withState(ResourceState state) {
        this.state = state;
        return this;
    }

    /**
     * Get the enableExternalValidation property: Flag to enable external validation.
     * 
     * @return the enableExternalValidation value.
     */
    public Boolean enableExternalValidation() {
        return this.enableExternalValidation;
    }

    /**
     * Set the enableExternalValidation property: Flag to enable external validation.
     * 
     * @param enableExternalValidation the enableExternalValidation value to set.
     * @return the SolutionTemplateProperties object itself.
     */
    public SolutionTemplateProperties withEnableExternalValidation(Boolean enableExternalValidation) {
        this.enableExternalValidation = enableExternalValidation;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (description() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property description in model SolutionTemplateProperties"));
        }
        if (capabilities() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property capabilities in model SolutionTemplateProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplateProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("description", this.description);
        jsonWriter.writeArrayField("capabilities", this.capabilities, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("state", this.state == null ? null : this.state.toString());
        jsonWriter.writeBooleanField("enableExternalValidation", this.enableExternalValidation);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionTemplateProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionTemplateProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionTemplateProperties.
     */
    public static SolutionTemplateProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionTemplateProperties deserializedSolutionTemplateProperties = new SolutionTemplateProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("description".equals(fieldName)) {
                    deserializedSolutionTemplateProperties.description = reader.getString();
                } else if ("capabilities".equals(fieldName)) {
                    List<String> capabilities = reader.readArray(reader1 -> reader1.getString());
                    deserializedSolutionTemplateProperties.capabilities = capabilities;
                } else if ("latestVersion".equals(fieldName)) {
                    deserializedSolutionTemplateProperties.latestVersion = reader.getString();
                } else if ("state".equals(fieldName)) {
                    deserializedSolutionTemplateProperties.state = ResourceState.fromString(reader.getString());
                } else if ("enableExternalValidation".equals(fieldName)) {
                    deserializedSolutionTemplateProperties.enableExternalValidation
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedSolutionTemplateProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionTemplateProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionTemplates.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;

/**
 * Resource collection API of SolutionTemplates.
 */
public interface SolutionTemplates {
    /**
     * Get a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource along with {@link Response}.
     */
    Response<SolutionTemplate> getByResourceGroupWithResponse(String resourceGroupName, String solutionTemplateName,
        Context context);

    /**
     * Get a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource.
     */
    SolutionTemplate getByResourceGroup(String resourceGroupName, String solutionTemplateName);

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionTemplateVersion createVersion(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body);

    /**
     * Create a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionTemplateVersion createVersion(String resourceGroupName, String solutionTemplateName,
        SolutionTemplateVersionWithUpdateTypeInner body, Context context);

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void removeVersion(String resourceGroupName, String solutionTemplateName, VersionParameter body);

    /**
     * Remove Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void removeVersion(String resourceGroupName, String solutionTemplateName, VersionParameter body, Context context);

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByResourceGroup(String resourceGroupName, String solutionTemplateName);

    /**
     * Delete a Solution Template Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String solutionTemplateName, Context context);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SolutionTemplate> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SolutionTemplate> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SolutionTemplate> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplate list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SolutionTemplate> list(Context context);

    /**
     * Get a Solution Template Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource along with {@link Response}.
     */
    SolutionTemplate getById(String id);

    /**
     * Get a Solution Template Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Resource along with {@link Response}.
     */
    Response<SolutionTemplate> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Solution Template Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Solution Template Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new SolutionTemplate resource.
     * 
     * @param name resource name.
     * @return the first stage of the new SolutionTemplate definition.
     */
    SolutionTemplate.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionTemplateVersion.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;

/**
 * An immutable client-side representation of SolutionTemplateVersion.
 */
public interface SolutionTemplateVersion {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    SolutionTemplateVersionProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner object.
     * 
     * @return the inner object.
     */
    SolutionTemplateVersionInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionTemplateVersionProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.Map;

/**
 * Solution Template Version Properties.
 */
@Fluent
public final class SolutionTemplateVersionProperties implements JsonSerializable<SolutionTemplateVersionProperties> {
    /*
     * Config expressions for this solution version
     */
    private String configurations;

    /*
     * App components spec
     */
    private Map<String, BinaryData> specification;

    /*
     * Orchestrator type
     */
    private OrchestratorType orchestratorType;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of SolutionTemplateVersionProperties class.
     */
    public SolutionTemplateVersionProperties() {
    }

    /**
     * Get the configurations property: Config expressions for this solution version.
     * 
     * @return the configurations value.
     */
    public String configurations() {
        return this.configurations;
    }

    /**
     * Set the configurations property: Config expressions for this solution version.
     * 
     * @param configurations the configurations value to set.
     * @return the SolutionTemplateVersionProperties object itself.
     */
    public SolutionTemplateVersionProperties withConfigurations(String configurations) {
        this.configurations = configurations;
        return this;
    }

    /**
     * Get the specification property: App components spec.
     * 
     * @return the specification value.
     */
    public Map<String, BinaryData> specification() {
        return this.specification;
    }

    /**
     * Set the specification property: App components spec.
     * 
     * @param specification the specification value to set.
     * @return the SolutionTemplateVersionProperties object itself.
     */
    public SolutionTemplateVersionProperties withSpecification(Map<String, BinaryData> specification) {
        this.specification = specification;
        return this;
    }

    /**
     * Get the orchestratorType property: Orchestrator type.
     * 
     * @return the orchestratorType value.
     */
    public OrchestratorType orchestratorType() {
        return this.orchestratorType;
    }

    /**
     * Set the orchestratorType property: Orchestrator type.
     * 
     * @param orchestratorType the orchestratorType value to set.
     * @return the SolutionTemplateVersionProperties object itself.
     */
    public SolutionTemplateVersionProperties withOrchestratorType(OrchestratorType orchestratorType) {
        this.orchestratorType = orchestratorType;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (configurations() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property configurations in model SolutionTemplateVersionProperties"));
        }
        if (specification() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property specification in model SolutionTemplateVersionProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionTemplateVersionProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("configurations", this.configurations);
        jsonWriter.writeMapField("specification", this.specification,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        jsonWriter.writeStringField("orchestratorType",
            this.orchestratorType == null ? null : this.orchestratorType.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionTemplateVersionProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionTemplateVersionProperties if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionTemplateVersionProperties.
     */
    public static SolutionTemplateVersionProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionTemplateVersionProperties deserializedSolutionTemplateVersionProperties
                = new SolutionTemplateVersionProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("configurations".equals(fieldName)) {
                    deserializedSolutionTemplateVersionProperties.configurations = reader.getString();
                } else if ("specification".equals(fieldName)) {
                    Map<String, BinaryData> specification = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedSolutionTemplateVersionProperties.specification = specification;
                } else if ("orchestratorType".equals(fieldName)) {
                    deserializedSolutionTemplateVersionProperties.orchestratorType
                        = OrchestratorType.fromString(reader.getString());
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedSolutionTemplateVersionProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionTemplateVersionProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionTemplateVersions.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of SolutionTemplateVersions.
 */
public interface SolutionTemplateVersions {
    /**
     * Get a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Version Resource along with {@link Response}.
     */
    Response<SolutionTemplateVersion> getWithResponse(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName, Context context);

    /**
     * Get a Solution Template Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Template Version Resource.
     */
    SolutionTemplateVersion get(String resourceGroupName, String solutionTemplateName,
        String solutionTemplateVersionName);

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation as paginated response with
     * {@link PagedIterable}.
     */
    PagedIterable<SolutionTemplateVersion> listBySolutionTemplate(String resourceGroupName,
        String solutionTemplateName);

    /**
     * List Solution Template Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionTemplateVersion list operation as paginated response with
     * {@link PagedIterable}.
     */
    PagedIterable<SolutionTemplateVersion> listBySolutionTemplate(String resourceGroupName, String solutionTemplateName,
        Context context);

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void bulkDeploySolution(String resourceGroupName, String solutionTemplateName, String solutionTemplateVersionName,
        BulkDeploySolutionParameter body);

    /**
     * Post request for bulk deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void bulkDeploySolution(String resourceGroupName, String solutionTemplateName, String solutionTemplateVersionName,
        BulkDeploySolutionParameter body, Context context);

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void bulkPublishSolution(String resourceGroupName, String solutionTemplateName, String solutionTemplateVersionName,
        BulkPublishSolutionParameter body);

    /**
     * Post request for bulk publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param solutionTemplateName The name of the SolutionTemplate.
     * @param solutionTemplateVersionName The name of the SolutionTemplateVersion.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void bulkPublishSolution(String resourceGroupName, String solutionTemplateName, String solutionTemplateVersionName,
        BulkPublishSolutionParameter body, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionTemplateVersionWithUpdateType.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;

/**
 * An immutable client-side representation of SolutionTemplateVersionWithUpdateType.
 */
public interface SolutionTemplateVersionWithUpdateType {
    /**
     * Gets the updateType property: Update type.
     * 
     * @return the updateType value.
     */
    UpdateType updateType();

    /**
     * Gets the version property: Version to create.
     * 
     * @return the version value.
     */
    String version();

    /**
     * Gets the solutionTemplateVersion property: Solution Template Version.
     * 
     * @return the solutionTemplateVersion value.
     */
    SolutionTemplateVersion solutionTemplateVersion();

    /**
     * Gets the inner
     * com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner object.
     * 
     * @return the inner object.
     */
    SolutionTemplateVersionWithUpdateTypeInner innerModel();
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionVersion.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner;

/**
 * An immutable client-side representation of SolutionVersion.
 */
public interface SolutionVersion {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    SolutionVersionProperties properties();

    /**
     * Gets the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    ExtendedLocation extendedLocation();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner object.
     * 
     * @return the inner object.
     */
    SolutionVersionInner innerModel();

    /**
     * The entirety of the SolutionVersion definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The SolutionVersion definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the SolutionVersion definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the SolutionVersion definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, targetName, solutionName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param targetName Name of the target.
             * @param solutionName Name of the solution.
             * @return the next definition stage.
             */
            WithCreate withExistingSolution(String resourceGroupName, String targetName, String solutionName);
        }

        /**
         * The stage of the SolutionVersion definition which contains all the minimum required properties for the
         * resource to be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties, DefinitionStages.WithExtendedLocation {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            SolutionVersion create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            SolutionVersion create(Context context);
        }

        /**
         * The stage of the SolutionVersion definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(SolutionVersionProperties properties);
        }

        /**
         * The stage of the SolutionVersion definition allowing to specify extendedLocation.
         */
        interface WithExtendedLocation {
            /**
             * Specifies the extendedLocation property: The extendedLocation property..
             * 
             * @param extendedLocation The extendedLocation property.
             * @return the next definition stage.
             */
            WithCreate withExtendedLocation(ExtendedLocation extendedLocation);
        }
    }

    /**
     * Begins update for the SolutionVersion resource.
     * 
     * @return the stage of resource update.
     */
    SolutionVersion.Update update();

    /**
     * The template for SolutionVersion update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        SolutionVersion apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        SolutionVersion apply(Context context);
    }

    /**
     * The SolutionVersion update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the SolutionVersion update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(SolutionVersionProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    SolutionVersion refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    SolutionVersion refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionVersionParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Solution Version Parameter.
 */
@Fluent
public final class SolutionVersionParameter implements JsonSerializable<SolutionVersionParameter> {
    /*
     * Solution Version ARM Id
     */
    private String solutionVersionId;

    /**
     * Creates an instance of SolutionVersionParameter class.
     */
    public SolutionVersionParameter() {
    }

    /**
     * Get the solutionVersionId property: Solution Version ARM Id.
     * 
     * @return the solutionVersionId value.
     */
    public String solutionVersionId() {
        return this.solutionVersionId;
    }

    /**
     * Set the solutionVersionId property: Solution Version ARM Id.
     * 
     * @param solutionVersionId the solutionVersionId value to set.
     * @return the SolutionVersionParameter object itself.
     */
    public SolutionVersionParameter withSolutionVersionId(String solutionVersionId) {
        this.solutionVersionId = solutionVersionId;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionVersionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionVersionId in model SolutionVersionParameter"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionVersionParameter.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionVersionId", this.solutionVersionId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionVersionParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionVersionParameter if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionVersionParameter.
     */
    public static SolutionVersionParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionVersionParameter deserializedSolutionVersionParameter = new SolutionVersionParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionVersionId".equals(fieldName)) {
                    deserializedSolutionVersionParameter.solutionVersionId = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionVersionParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionVersionProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.exception.ManagementError;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Solution Version Properties.
 */
@Fluent
public final class SolutionVersionProperties implements JsonSerializable<SolutionVersionProperties> {
    /*
     * Solution Template Version Id
     */
    private String solutionTemplateVersionId;

    /*
     * Revision number of resolved config for this solution version
     */
    private Integer revision;

    /*
     * Name of applicable target's display name
     */
    private String targetDisplayName;

    /*
     * Resolved configuration values
     */
    private String configuration;

    /*
     * Configuration on the line level across all solution template versions
     */
    private String targetLevelConfiguration;

    /*
     * App components spec
     */
    private Map<String, BinaryData> specification;

    /*
     * Review id of resolved config for this solution version
     */
    private String reviewId;

    /*
     * External validation id
     */
    private String externalValidationId;

    /*
     * State of solution instance
     */
    private State state;

    /*
     * Solution instance name
     */
    private String solutionInstanceName;

    /*
     * Solution Dependency Context
     */
    private List<SolutionDependency> solutionDependencies;

    /*
     * Error Details if any failure is there
     */
    private ManagementError errorDetails;

    /*
     * The URI for tracking the latest action performed on this solution version.
     */
    private String latestActionTrackingUri;

    /*
     * The type of the latest action performed on this solution version.
     */
    private JobType actionType;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of SolutionVersionProperties class.
     */
    public SolutionVersionProperties() {
    }

    /**
     * Get the solutionTemplateVersionId property: Solution Template Version Id.
     * 
     * @return the solutionTemplateVersionId value.
     */
    public String solutionTemplateVersionId() {
        return this.solutionTemplateVersionId;
    }

    /**
     * Get the revision property: Revision number of resolved config for this solution version.
     * 
     * @return the revision value.
     */
    public Integer revision() {
        return this.revision;
    }

    /**
     * Get the targetDisplayName property: Name of applicable target's display name.
     * 
     * @return the targetDisplayName value.
     */
    public String targetDisplayName() {
        return this.targetDisplayName;
    }

    /**
     * Get the configuration property: Resolved configuration values.
     * 
     * @return the configuration value.
     */
    public String configuration() {
        return this.configuration;
    }

    /**
     * Get the targetLevelConfiguration property: Configuration on the line level across all solution template versions.
     * 
     * @return the targetLevelConfiguration value.
     */
    public String targetLevelConfiguration() {
        return this.targetLevelConfiguration;
    }

    /**
     * Get the specification property: App components spec.
     * 
     * @return the specification value.
     */
    public Map<String, BinaryData> specification() {
        return this.specification;
    }

    /**
     * Set the specification property: App components spec.
     * 
     * @param specification the specification value to set.
     * @return the SolutionVersionProperties object itself.
     */
    public SolutionVersionProperties withSpecification(Map<String, BinaryData> specification) {
        this.specification = specification;
        return this;
    }

    /**
     * Get the reviewId property: Review id of resolved config for this solution version.
     * 
     * @return the reviewId value.
     */
    public String reviewId() {
        return this.reviewId;
    }

    /**
     * Get the externalValidationId property: External validation id.
     * 
     * @return the externalValidationId value.
     */
    public String externalValidationId() {
        return this.externalValidationId;
    }

    /**
     * Get the state property: State of solution instance.
     * 
     * @return the state value.
     */
    public State state() {
        return this.state;
    }

    /**
     * Get the solutionInstanceName property: Solution instance name.
     * 
     * @return the solutionInstanceName value.
     */
    public String solutionInstanceName() {
        return this.solutionInstanceName;
    }

    /**
     * Get the solutionDependencies property: Solution Dependency Context.
     * 
     * @return the solutionDependencies value.
     */
    public List<SolutionDependency> solutionDependencies() {
        return this.solutionDependencies;
    }

    /**
     * Get the errorDetails property: Error Details if any failure is there.
     * 
     * @return the errorDetails value.
     */
    public ManagementError errorDetails() {
        return this.errorDetails;
    }

    /**
     * Get the latestActionTrackingUri property: The URI for tracking the latest action performed on this solution
     * version.
     * 
     * @return the latestActionTrackingUri value.
     */
    public String latestActionTrackingUri() {
        return this.latestActionTrackingUri;
    }

    /**
     * Get the actionType property: The type of the latest action performed on this solution version.
     * 
     * @return the actionType value.
     */
    public JobType actionType() {
        return this.actionType;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (specification() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property specification in model SolutionVersionProperties"));
        }
        if (solutionDependencies() != null) {
            solutionDependencies().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SolutionVersionProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeMapField("specification", this.specification,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionVersionProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionVersionProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SolutionVersionProperties.
     */
    public static SolutionVersionProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionVersionProperties deserializedSolutionVersionProperties = new SolutionVersionProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("specification".equals(fieldName)) {
                    Map<String, BinaryData> specification = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedSolutionVersionProperties.specification = specification;
                } else if ("solutionTemplateVersionId".equals(fieldName)) {
                    deserializedSolutionVersionProperties.solutionTemplateVersionId = reader.getString();
                } else if ("revision".equals(fieldName)) {
                    deserializedSolutionVersionProperties.revision = reader.getNullable(JsonReader::getInt);
                } else if ("targetDisplayName".equals(fieldName)) {
                    deserializedSolutionVersionProperties.targetDisplayName = reader.getString();
                } else if ("configuration".equals(fieldName)) {
                    deserializedSolutionVersionProperties.configuration = reader.getString();
                } else if ("targetLevelConfiguration".equals(fieldName)) {
                    deserializedSolutionVersionProperties.targetLevelConfiguration = reader.getString();
                } else if ("reviewId".equals(fieldName)) {
                    deserializedSolutionVersionProperties.reviewId = reader.getString();
                } else if ("externalValidationId".equals(fieldName)) {
                    deserializedSolutionVersionProperties.externalValidationId = reader.getString();
                } else if ("state".equals(fieldName)) {
                    deserializedSolutionVersionProperties.state = State.fromString(reader.getString());
                } else if ("solutionInstanceName".equals(fieldName)) {
                    deserializedSolutionVersionProperties.solutionInstanceName = reader.getString();
                } else if ("solutionDependencies".equals(fieldName)) {
                    List<SolutionDependency> solutionDependencies
                        = reader.readArray(reader1 -> SolutionDependency.fromJson(reader1));
                    deserializedSolutionVersionProperties.solutionDependencies = solutionDependencies;
                } else if ("errorDetails".equals(fieldName)) {
                    deserializedSolutionVersionProperties.errorDetails = ManagementError.fromJson(reader);
                } else if ("latestActionTrackingUri".equals(fieldName)) {
                    deserializedSolutionVersionProperties.latestActionTrackingUri = reader.getString();
                } else if ("actionType".equals(fieldName)) {
                    deserializedSolutionVersionProperties.actionType = JobType.fromString(reader.getString());
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedSolutionVersionProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionVersionProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionVersions.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of SolutionVersions.
 */
public interface SolutionVersions {
    /**
     * Get a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource along with {@link Response}.
     */
    Response<SolutionVersion> getWithResponse(String resourceGroupName, String targetName, String solutionName,
        String solutionVersionName, Context context);

    /**
     * Get a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource.
     */
    SolutionVersion get(String resourceGroupName, String targetName, String solutionName, String solutionVersionName);

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String targetName, String solutionName, String solutionVersionName);

    /**
     * Delete a Solution Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param solutionVersionName Name of the solution version.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String targetName, String solutionName, String solutionVersionName,
        Context context);

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SolutionVersion> listBySolution(String resourceGroupName, String targetName, String solutionName);

    /**
     * List Solution Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param solutionName Name of the solution.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a SolutionVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<SolutionVersion> listBySolution(String resourceGroupName, String targetName, String solutionName,
        Context context);

    /**
     * Get a Solution Version Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource along with {@link Response}.
     */
    SolutionVersion getById(String id);

    /**
     * Get a Solution Version Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Solution Version Resource along with {@link Response}.
     */
    Response<SolutionVersion> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Solution Version Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Solution Version Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new SolutionVersion resource.
     * 
     * @param name resource name.
     * @return the first stage of the new SolutionVersion definition.
     */
    SolutionVersion.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/SolutionVersionSnapshot.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.BinaryData;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.Map;

/**
 * Solution Version Snapshot.
 */
@Immutable
public final class SolutionVersionSnapshot implements JsonSerializable<SolutionVersionSnapshot> {
    /*
     * Solution version of instance
     */
    private String solutionVersionId;

    /*
     * App components spec
     */
    private Map<String, BinaryData> specification;

    /**
     * Creates an instance of SolutionVersionSnapshot class.
     */
    private SolutionVersionSnapshot() {
    }

    /**
     * Get the solutionVersionId property: Solution version of instance.
     * 
     * @return the solutionVersionId value.
     */
    public String solutionVersionId() {
        return this.solutionVersionId;
    }

    /**
     * Get the specification property: App components spec.
     * 
     * @return the specification value.
     */
    public Map<String, BinaryData> specification() {
        return this.specification;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionVersionId", this.solutionVersionId);
        jsonWriter.writeMapField("specification", this.specification,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SolutionVersionSnapshot from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SolutionVersionSnapshot if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the SolutionVersionSnapshot.
     */
    public static SolutionVersionSnapshot fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SolutionVersionSnapshot deserializedSolutionVersionSnapshot = new SolutionVersionSnapshot();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionVersionId".equals(fieldName)) {
                    deserializedSolutionVersionSnapshot.solutionVersionId = reader.getString();
                } else if ("specification".equals(fieldName)) {
                    Map<String, BinaryData> specification = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedSolutionVersionSnapshot.specification = specification;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSolutionVersionSnapshot;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/StageSpec.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Stage Properties.
 */
@Fluent
public final class StageSpec implements JsonSerializable<StageSpec> {
    /*
     * Name of Stage
     */
    private String name;

    /*
     * Stage specification
     */
    private Map<String, BinaryData> specification;

    /*
     * List of tasks in the stage
     */
    private List<TaskSpec> tasks;

    /*
     * Task option for the stage
     */
    private TaskOption taskOption;

    /**
     * Creates an instance of StageSpec class.
     */
    public StageSpec() {
    }

    /**
     * Get the name property: Name of Stage.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Set the name property: Name of Stage.
     * 
     * @param name the name value to set.
     * @return the StageSpec object itself.
     */
    public StageSpec withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the specification property: Stage specification.
     * 
     * @return the specification value.
     */
    public Map<String, BinaryData> specification() {
        return this.specification;
    }

    /**
     * Set the specification property: Stage specification.
     * 
     * @param specification the specification value to set.
     * @return the StageSpec object itself.
     */
    public StageSpec withSpecification(Map<String, BinaryData> specification) {
        this.specification = specification;
        return this;
    }

    /**
     * Get the tasks property: List of tasks in the stage.
     * 
     * @return the tasks value.
     */
    public List<TaskSpec> tasks() {
        return this.tasks;
    }

    /**
     * Set the tasks property: List of tasks in the stage.
     * 
     * @param tasks the tasks value to set.
     * @return the StageSpec object itself.
     */
    public StageSpec withTasks(List<TaskSpec> tasks) {
        this.tasks = tasks;
        return this;
    }

    /**
     * Get the taskOption property: Task option for the stage.
     * 
     * @return the taskOption value.
     */
    public TaskOption taskOption() {
        return this.taskOption;
    }

    /**
     * Set the taskOption property: Task option for the stage.
     * 
     * @param taskOption the taskOption value to set.
     * @return the StageSpec object itself.
     */
    public StageSpec withTaskOption(TaskOption taskOption) {
        this.taskOption = taskOption;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (name() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property name in model StageSpec"));
        }
        if (tasks() != null) {
            tasks().forEach(e -> e.validate());
        }
        if (taskOption() != null) {
            taskOption().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(StageSpec.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeMapField("specification", this.specification,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        jsonWriter.writeArrayField("tasks", this.tasks, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("taskOption", this.taskOption);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of StageSpec from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of StageSpec if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the StageSpec.
     */
    public static StageSpec fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            StageSpec deserializedStageSpec = new StageSpec();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedStageSpec.name = reader.getString();
                } else if ("specification".equals(fieldName)) {
                    Map<String, BinaryData> specification = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedStageSpec.specification = specification;
                } else if ("tasks".equals(fieldName)) {
                    List<TaskSpec> tasks = reader.readArray(reader1 -> TaskSpec.fromJson(reader1));
                    deserializedStageSpec.tasks = tasks;
                } else if ("taskOption".equals(fieldName)) {
                    deserializedStageSpec.taskOption = TaskOption.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedStageSpec;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/StageStatus.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.BinaryData;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.Map;

/**
 * Result of Stage execution.
 */
@Immutable
public final class StageStatus implements JsonSerializable<StageStatus> {
    /*
     * Deployment status
     */
    private Integer status;

    /*
     * Status message
     */
    private String statusMessage;

    /*
     * Current stage
     */
    private String stage;

    /*
     * Next stage
     */
    private String nextstage;

    /*
     * Error message
     */
    private String errorMessage;

    /*
     * whether this stage is active or inactive
     */
    private ActiveState isActive;

    /*
     * The inputs of the StageHistory, Inputs holds a key-value map of user-defined parameters for the initial stage
     */
    private Map<String, BinaryData> inputs;

    /*
     * The outputs of the StageHistory, it is different as the different input stages.
     */
    private Map<String, BinaryData> outputs;

    /**
     * Creates an instance of StageStatus class.
     */
    private StageStatus() {
    }

    /**
     * Get the status property: Deployment status.
     * 
     * @return the status value.
     */
    public Integer status() {
        return this.status;
    }

    /**
     * Get the statusMessage property: Status message.
     * 
     * @return the statusMessage value.
     */
    public String statusMessage() {
        return this.statusMessage;
    }

    /**
     * Get the stage property: Current stage.
     * 
     * @return the stage value.
     */
    public String stage() {
        return this.stage;
    }

    /**
     * Get the nextstage property: Next stage.
     * 
     * @return the nextstage value.
     */
    public String nextstage() {
        return this.nextstage;
    }

    /**
     * Get the errorMessage property: Error message.
     * 
     * @return the errorMessage value.
     */
    public String errorMessage() {
        return this.errorMessage;
    }

    /**
     * Get the isActive property: whether this stage is active or inactive.
     * 
     * @return the isActive value.
     */
    public ActiveState isActive() {
        return this.isActive;
    }

    /**
     * Get the inputs property: The inputs of the StageHistory, Inputs holds a key-value map of user-defined parameters
     * for the initial stage.
     * 
     * @return the inputs value.
     */
    public Map<String, BinaryData> inputs() {
        return this.inputs;
    }

    /**
     * Get the outputs property: The outputs of the StageHistory, it is different as the different input stages.
     * 
     * @return the outputs value.
     */
    public Map<String, BinaryData> outputs() {
        return this.outputs;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeNumberField("status", this.status);
        jsonWriter.writeStringField("statusMessage", this.statusMessage);
        jsonWriter.writeStringField("stage", this.stage);
        jsonWriter.writeStringField("nextstage", this.nextstage);
        jsonWriter.writeStringField("errorMessage", this.errorMessage);
        jsonWriter.writeStringField("isActive", this.isActive == null ? null : this.isActive.toString());
        jsonWriter.writeMapField("inputs", this.inputs,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        jsonWriter.writeMapField("outputs", this.outputs,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of StageStatus from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of StageStatus if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the StageStatus.
     */
    public static StageStatus fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            StageStatus deserializedStageStatus = new StageStatus();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("status".equals(fieldName)) {
                    deserializedStageStatus.status = reader.getNullable(JsonReader::getInt);
                } else if ("statusMessage".equals(fieldName)) {
                    deserializedStageStatus.statusMessage = reader.getString();
                } else if ("stage".equals(fieldName)) {
                    deserializedStageStatus.stage = reader.getString();
                } else if ("nextstage".equals(fieldName)) {
                    deserializedStageStatus.nextstage = reader.getString();
                } else if ("errorMessage".equals(fieldName)) {
                    deserializedStageStatus.errorMessage = reader.getString();
                } else if ("isActive".equals(fieldName)) {
                    deserializedStageStatus.isActive = ActiveState.fromString(reader.getString());
                } else if ("inputs".equals(fieldName)) {
                    Map<String, BinaryData> inputs = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedStageStatus.inputs = inputs;
                } else if ("outputs".equals(fieldName)) {
                    Map<String, BinaryData> outputs = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedStageStatus.outputs = outputs;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedStageStatus;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/State.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Solution Instance State.
 */
public final class State extends ExpandableStringEnum<State> {
    /**
     * Solution Instance is in review.
     */
    public static final State IN_REVIEW = fromString("InReview");

    /**
     * Solution Instance upgrade is in review.
     */
    public static final State UPGRADE_IN_REVIEW = fromString("UpgradeInReview");

    /**
     * Solution Instance is ready to deploy.
     */
    public static final State READY_TO_DEPLOY = fromString("ReadyToDeploy");

    /**
     * Solution Instance is ready to upgrade.
     */
    public static final State READY_TO_UPGRADE = fromString("ReadyToUpgrade");

    /**
     * Solution Instance is deploying.
     */
    public static final State DEPLOYING = fromString("Deploying");

    /**
     * Solution Instance is deployed.
     */
    public static final State DEPLOYED = fromString("Deployed");

    /**
     * Solution Instance failed to deploy.
     */
    public static final State FAILED = fromString("Failed");

    /**
     * Solution Instance is undeployed.
     */
    public static final State UNDEPLOYED = fromString("Undeployed");

    /**
     * Solution Instance is pending external validation.
     */
    public static final State PENDING_EXTERNAL_VALIDATION = fromString("PendingExternalValidation");

    /**
     * Solution Instance failed external validation.
     */
    public static final State EXTERNAL_VALIDATION_FAILED = fromString("ExternalValidationFailed");

    /**
     * Solution Instance is staging the images.
     */
    public static final State STAGING = fromString("Staging");

    /**
     * Creates a new instance of State value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public State() {
    }

    /**
     * Creates or finds a State from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding State.
     */
    public static State fromString(String name) {
        return fromString(name, State.class);
    }

    /**
     * Gets known State values.
     * 
     * @return known State values.
     */
    public static Collection<State> values() {
        return values(State.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Target.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.Region;
import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner;
import java.util.Map;

/**
 * An immutable client-side representation of Target.
 */
public interface Target {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the location property: The geo-location where the resource lives.
     * 
     * @return the location value.
     */
    String location();

    /**
     * Gets the tags property: Resource tags.
     * 
     * @return the tags value.
     */
    Map<String, String> tags();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    TargetProperties properties();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    ExtendedLocation extendedLocation();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the region of the resource.
     * 
     * @return the region of the resource.
     */
    Region region();

    /**
     * Gets the name of the resource region.
     * 
     * @return the name of the resource region.
     */
    String regionName();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner object.
     * 
     * @return the inner object.
     */
    TargetInner innerModel();

    /**
     * The entirety of the Target definition.
     */
    interface Definition extends DefinitionStages.Blank, DefinitionStages.WithLocation,
        DefinitionStages.WithResourceGroup, DefinitionStages.WithCreate {
    }

    /**
     * The Target definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the Target definition.
         */
        interface Blank extends WithLocation {
        }

        /**
         * The stage of the Target definition allowing to specify location.
         */
        interface WithLocation {
            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(Region location);

            /**
             * Specifies the region for the resource.
             * 
             * @param location The geo-location where the resource lives.
             * @return the next definition stage.
             */
            WithResourceGroup withRegion(String location);
        }

        /**
         * The stage of the Target definition allowing to specify parent resource.
         */
        interface WithResourceGroup {
            /**
             * Specifies resourceGroupName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @return the next definition stage.
             */
            WithCreate withExistingResourceGroup(String resourceGroupName);
        }

        /**
         * The stage of the Target definition which contains all the minimum required properties for the resource to be
         * created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate
            extends DefinitionStages.WithTags, DefinitionStages.WithProperties, DefinitionStages.WithExtendedLocation {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            Target create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            Target create(Context context);
        }

        /**
         * The stage of the Target definition allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            WithCreate withTags(Map<String, String> tags);
        }

        /**
         * The stage of the Target definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(TargetProperties properties);
        }

        /**
         * The stage of the Target definition allowing to specify extendedLocation.
         */
        interface WithExtendedLocation {
            /**
             * Specifies the extendedLocation property: The extendedLocation property..
             * 
             * @param extendedLocation The extendedLocation property.
             * @return the next definition stage.
             */
            WithCreate withExtendedLocation(ExtendedLocation extendedLocation);
        }
    }

    /**
     * Begins update for the Target resource.
     * 
     * @return the stage of resource update.
     */
    Target.Update update();

    /**
     * The template for Target update.
     */
    interface Update extends UpdateStages.WithTags, UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        Target apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        Target apply(Context context);
    }

    /**
     * The Target update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the Target update allowing to specify tags.
         */
        interface WithTags {
            /**
             * Specifies the tags property: Resource tags..
             * 
             * @param tags Resource tags.
             * @return the next definition stage.
             */
            Update withTags(Map<String, String> tags);
        }

        /**
         * The stage of the Target update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(TargetProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    Target refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    Target refresh(Context context);

    /**
     * Post request to deploy.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void installSolution(InstallSolutionParameter body);

    /**
     * Post request to deploy.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void installSolution(InstallSolutionParameter body, Context context);

    /**
     * Post request to uninstall.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void uninstallSolution(UninstallSolutionParameter body);

    /**
     * Post request to uninstall.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void uninstallSolution(UninstallSolutionParameter body, Context context);

    /**
     * Post request to remove solution version revision.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void removeRevision(RemoveRevisionParameter body);

    /**
     * Post request to remove solution version revision.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void removeRevision(RemoveRevisionParameter body, Context context);

    /**
     * Post request to resolve configuration.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    ResolvedConfiguration resolveConfiguration(SolutionTemplateParameter body);

    /**
     * Post request to resolve configuration.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    ResolvedConfiguration resolveConfiguration(SolutionTemplateParameter body, Context context);

    /**
     * Post request to review configuration.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion reviewSolutionVersion(SolutionTemplateParameter body);

    /**
     * Post request to review configuration.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion reviewSolutionVersion(SolutionTemplateParameter body, Context context);

    /**
     * Post request to publish.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion publishSolutionVersion(SolutionVersionParameter body);

    /**
     * Post request to publish.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion publishSolutionVersion(SolutionVersionParameter body, Context context);

    /**
     * Post request to update external validation status.
     * 
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion updateExternalValidationStatus(UpdateExternalValidationStatusParameter body);

    /**
     * Post request to update external validation status.
     * 
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion updateExternalValidationStatus(UpdateExternalValidationStatusParameter body, Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/TargetProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Target Properties.
 */
@Fluent
public final class TargetProperties implements JsonSerializable<TargetProperties> {
    /*
     * Description of target
     */
    private String description;

    /*
     * Display name of target
     */
    private String displayName;

    /*
     * ArmId of Context
     */
    private String contextId;

    /*
     * target spec
     */
    private Map<String, BinaryData> targetSpecification;

    /*
     * List of capabilities
     */
    private List<String> capabilities;

    /*
     * Hierarchy Level
     */
    private String hierarchyLevel;

    /*
     * Status of target
     */
    private DeploymentStatus status;

    /*
     * Scope of the target resource
     */
    private String solutionScope;

    /*
     * State of resource
     */
    private ResourceState state;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of TargetProperties class.
     */
    public TargetProperties() {
    }

    /**
     * Get the description property: Description of target.
     * 
     * @return the description value.
     */
    public String description() {
        return this.description;
    }

    /**
     * Set the description property: Description of target.
     * 
     * @param description the description value to set.
     * @return the TargetProperties object itself.
     */
    public TargetProperties withDescription(String description) {
        this.description = description;
        return this;
    }

    /**
     * Get the displayName property: Display name of target.
     * 
     * @return the displayName value.
     */
    public String displayName() {
        return this.displayName;
    }

    /**
     * Set the displayName property: Display name of target.
     * 
     * @param displayName the displayName value to set.
     * @return the TargetProperties object itself.
     */
    public TargetProperties withDisplayName(String displayName) {
        this.displayName = displayName;
        return this;
    }

    /**
     * Get the contextId property: ArmId of Context.
     * 
     * @return the contextId value.
     */
    public String contextId() {
        return this.contextId;
    }

    /**
     * Set the contextId property: ArmId of Context.
     * 
     * @param contextId the contextId value to set.
     * @return the TargetProperties object itself.
     */
    public TargetProperties withContextId(String contextId) {
        this.contextId = contextId;
        return this;
    }

    /**
     * Get the targetSpecification property: target spec.
     * 
     * @return the targetSpecification value.
     */
    public Map<String, BinaryData> targetSpecification() {
        return this.targetSpecification;
    }

    /**
     * Set the targetSpecification property: target spec.
     * 
     * @param targetSpecification the targetSpecification value to set.
     * @return the TargetProperties object itself.
     */
    public TargetProperties withTargetSpecification(Map<String, BinaryData> targetSpecification) {
        this.targetSpecification = targetSpecification;
        return this;
    }

    /**
     * Get the capabilities property: List of capabilities.
     * 
     * @return the capabilities value.
     */
    public List<String> capabilities() {
        return this.capabilities;
    }

    /**
     * Set the capabilities property: List of capabilities.
     * 
     * @param capabilities the capabilities value to set.
     * @return the TargetProperties object itself.
     */
    public TargetProperties withCapabilities(List<String> capabilities) {
        this.capabilities = capabilities;
        return this;
    }

    /**
     * Get the hierarchyLevel property: Hierarchy Level.
     * 
     * @return the hierarchyLevel value.
     */
    public String hierarchyLevel() {
        return this.hierarchyLevel;
    }

    /**
     * Set the hierarchyLevel property: Hierarchy Level.
     * 
     * @param hierarchyLevel the hierarchyLevel value to set.
     * @return the TargetProperties object itself.
     */
    public TargetProperties withHierarchyLevel(String hierarchyLevel) {
        this.hierarchyLevel = hierarchyLevel;
        return this;
    }

    /**
     * Get the status property: Status of target.
     * 
     * @return the status value.
     */
    public DeploymentStatus status() {
        return this.status;
    }

    /**
     * Get the solutionScope property: Scope of the target resource.
     * 
     * @return the solutionScope value.
     */
    public String solutionScope() {
        return this.solutionScope;
    }

    /**
     * Set the solutionScope property: Scope of the target resource.
     * 
     * @param solutionScope the solutionScope value to set.
     * @return the TargetProperties object itself.
     */
    public TargetProperties withSolutionScope(String solutionScope) {
        this.solutionScope = solutionScope;
        return this;
    }

    /**
     * Get the state property: State of resource.
     * 
     * @return the state value.
     */
    public ResourceState state() {
        return this.state;
    }

    /**
     * Set the state property: State of resource.
     * 
     * @param state the state value to set.
     * @return the TargetProperties object itself.
     */
    public TargetProperties withState(ResourceState state) {
        this.state = state;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (description() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property description in model TargetProperties"));
        }
        if (displayName() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property displayName in model TargetProperties"));
        }
        if (contextId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property contextId in model TargetProperties"));
        }
        if (targetSpecification() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property targetSpecification in model TargetProperties"));
        }
        if (capabilities() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property capabilities in model TargetProperties"));
        }
        if (hierarchyLevel() == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Missing required property hierarchyLevel in model TargetProperties"));
        }
        if (status() != null) {
            status().validate();
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(TargetProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("description", this.description);
        jsonWriter.writeStringField("displayName", this.displayName);
        jsonWriter.writeStringField("contextId", this.contextId);
        jsonWriter.writeMapField("targetSpecification", this.targetSpecification,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        jsonWriter.writeArrayField("capabilities", this.capabilities, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("hierarchyLevel", this.hierarchyLevel);
        jsonWriter.writeStringField("solutionScope", this.solutionScope);
        jsonWriter.writeStringField("state", this.state == null ? null : this.state.toString());
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TargetProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TargetProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TargetProperties.
     */
    public static TargetProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TargetProperties deserializedTargetProperties = new TargetProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("description".equals(fieldName)) {
                    deserializedTargetProperties.description = reader.getString();
                } else if ("displayName".equals(fieldName)) {
                    deserializedTargetProperties.displayName = reader.getString();
                } else if ("contextId".equals(fieldName)) {
                    deserializedTargetProperties.contextId = reader.getString();
                } else if ("targetSpecification".equals(fieldName)) {
                    Map<String, BinaryData> targetSpecification = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedTargetProperties.targetSpecification = targetSpecification;
                } else if ("capabilities".equals(fieldName)) {
                    List<String> capabilities = reader.readArray(reader1 -> reader1.getString());
                    deserializedTargetProperties.capabilities = capabilities;
                } else if ("hierarchyLevel".equals(fieldName)) {
                    deserializedTargetProperties.hierarchyLevel = reader.getString();
                } else if ("status".equals(fieldName)) {
                    deserializedTargetProperties.status = DeploymentStatus.fromJson(reader);
                } else if ("solutionScope".equals(fieldName)) {
                    deserializedTargetProperties.solutionScope = reader.getString();
                } else if ("state".equals(fieldName)) {
                    deserializedTargetProperties.state = ResourceState.fromString(reader.getString());
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedTargetProperties.provisioningState = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTargetProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Targets.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of Targets.
 */
public interface Targets {
    /**
     * Get a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource along with {@link Response}.
     */
    Response<Target> getByResourceGroupWithResponse(String resourceGroupName, String targetName, Context context);

    /**
     * Get a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource.
     */
    Target getByResourceGroup(String resourceGroupName, String targetName);

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String targetName);

    /**
     * Delete a Target Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param forceDelete Force delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String targetName, Boolean forceDelete, Context context);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Target> listByResourceGroup(String resourceGroupName);

    /**
     * List by specified resource group.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Target> listByResourceGroup(String resourceGroupName, Context context);

    /**
     * List by subscription.
     * 
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Target> list();

    /**
     * List by subscription.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Target list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Target> list(Context context);

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void installSolution(String resourceGroupName, String targetName, InstallSolutionParameter body);

    /**
     * Post request to deploy.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void installSolution(String resourceGroupName, String targetName, InstallSolutionParameter body, Context context);

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void uninstallSolution(String resourceGroupName, String targetName, UninstallSolutionParameter body);

    /**
     * Post request to uninstall.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void uninstallSolution(String resourceGroupName, String targetName, UninstallSolutionParameter body,
        Context context);

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void removeRevision(String resourceGroupName, String targetName, RemoveRevisionParameter body);

    /**
     * Post request to remove solution version revision.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void removeRevision(String resourceGroupName, String targetName, RemoveRevisionParameter body, Context context);

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    ResolvedConfiguration resolveConfiguration(String resourceGroupName, String targetName,
        SolutionTemplateParameter body);

    /**
     * Post request to resolve configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    ResolvedConfiguration resolveConfiguration(String resourceGroupName, String targetName,
        SolutionTemplateParameter body, Context context);

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion reviewSolutionVersion(String resourceGroupName, String targetName, SolutionTemplateParameter body);

    /**
     * Post request to review configuration.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion reviewSolutionVersion(String resourceGroupName, String targetName, SolutionTemplateParameter body,
        Context context);

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion publishSolutionVersion(String resourceGroupName, String targetName, SolutionVersionParameter body);

    /**
     * Post request to publish.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion publishSolutionVersion(String resourceGroupName, String targetName, SolutionVersionParameter body,
        Context context);

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion updateExternalValidationStatus(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body);

    /**
     * Post request to update external validation status.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param targetName Name of the target.
     * @param body The content of the action request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    SolutionVersion updateExternalValidationStatus(String resourceGroupName, String targetName,
        UpdateExternalValidationStatusParameter body, Context context);

    /**
     * Get a Target Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource along with {@link Response}.
     */
    Target getById(String id);

    /**
     * Get a Target Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Target Resource along with {@link Response}.
     */
    Response<Target> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Target Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Target Resource.
     * 
     * @param id the resource ID.
     * @param forceDelete Force delete.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Boolean forceDelete, Context context);

    /**
     * Begins definition for a new Target resource.
     * 
     * @param name resource name.
     * @return the first stage of the new Target definition.
     */
    Target.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/TargetSnapshot.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.core.util.BinaryData;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.Map;

/**
 * Target Snapshot.
 */
@Immutable
public final class TargetSnapshot implements JsonSerializable<TargetSnapshot> {
    /*
     * Target of instance
     */
    private String targetId;

    /*
     * target spec
     */
    private Map<String, BinaryData> targetSpecification;

    /*
     * Scope of the target resource
     */
    private String solutionScope;

    /**
     * Creates an instance of TargetSnapshot class.
     */
    private TargetSnapshot() {
    }

    /**
     * Get the targetId property: Target of instance.
     * 
     * @return the targetId value.
     */
    public String targetId() {
        return this.targetId;
    }

    /**
     * Get the targetSpecification property: target spec.
     * 
     * @return the targetSpecification value.
     */
    public Map<String, BinaryData> targetSpecification() {
        return this.targetSpecification;
    }

    /**
     * Get the solutionScope property: Scope of the target resource.
     * 
     * @return the solutionScope value.
     */
    public String solutionScope() {
        return this.solutionScope;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("targetId", this.targetId);
        jsonWriter.writeMapField("targetSpecification", this.targetSpecification,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        jsonWriter.writeStringField("solutionScope", this.solutionScope);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TargetSnapshot from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TargetSnapshot if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the TargetSnapshot.
     */
    public static TargetSnapshot fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TargetSnapshot deserializedTargetSnapshot = new TargetSnapshot();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("targetId".equals(fieldName)) {
                    deserializedTargetSnapshot.targetId = reader.getString();
                } else if ("targetSpecification".equals(fieldName)) {
                    Map<String, BinaryData> targetSpecification = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedTargetSnapshot.targetSpecification = targetSpecification;
                } else if ("solutionScope".equals(fieldName)) {
                    deserializedTargetSnapshot.solutionScope = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTargetSnapshot;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/TargetStatus.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Target Status.
 */
@Immutable
public final class TargetStatus implements JsonSerializable<TargetStatus> {
    /*
     * Target name
     */
    private String name;

    /*
     * Target status
     */
    private String status;

    /*
     * Component statuses
     */
    private List<ComponentStatus> componentStatuses;

    /**
     * Creates an instance of TargetStatus class.
     */
    private TargetStatus() {
    }

    /**
     * Get the name property: Target name.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Get the status property: Target status.
     * 
     * @return the status value.
     */
    public String status() {
        return this.status;
    }

    /**
     * Get the componentStatuses property: Component statuses.
     * 
     * @return the componentStatuses value.
     */
    public List<ComponentStatus> componentStatuses() {
        return this.componentStatuses;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (componentStatuses() != null) {
            componentStatuses().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeStringField("status", this.status);
        jsonWriter.writeArrayField("componentStatuses", this.componentStatuses,
            (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TargetStatus from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TargetStatus if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the TargetStatus.
     */
    public static TargetStatus fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TargetStatus deserializedTargetStatus = new TargetStatus();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedTargetStatus.name = reader.getString();
                } else if ("status".equals(fieldName)) {
                    deserializedTargetStatus.status = reader.getString();
                } else if ("componentStatuses".equals(fieldName)) {
                    List<ComponentStatus> componentStatuses
                        = reader.readArray(reader1 -> ComponentStatus.fromJson(reader1));
                    deserializedTargetStatus.componentStatuses = componentStatuses;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTargetStatus;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/TaskOption.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Task Option Properties.
 */
@Fluent
public final class TaskOption implements JsonSerializable<TaskOption> {
    /*
     * Parallel worker numbers of the tasks
     */
    private Integer concurrency;

    /*
     * Error action for the tasks
     */
    private ErrorAction errorAction;

    /**
     * Creates an instance of TaskOption class.
     */
    public TaskOption() {
    }

    /**
     * Get the concurrency property: Parallel worker numbers of the tasks.
     * 
     * @return the concurrency value.
     */
    public Integer concurrency() {
        return this.concurrency;
    }

    /**
     * Set the concurrency property: Parallel worker numbers of the tasks.
     * 
     * @param concurrency the concurrency value to set.
     * @return the TaskOption object itself.
     */
    public TaskOption withConcurrency(Integer concurrency) {
        this.concurrency = concurrency;
        return this;
    }

    /**
     * Get the errorAction property: Error action for the tasks.
     * 
     * @return the errorAction value.
     */
    public ErrorAction errorAction() {
        return this.errorAction;
    }

    /**
     * Set the errorAction property: Error action for the tasks.
     * 
     * @param errorAction the errorAction value to set.
     * @return the TaskOption object itself.
     */
    public TaskOption withErrorAction(ErrorAction errorAction) {
        this.errorAction = errorAction;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (errorAction() != null) {
            errorAction().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeNumberField("concurrency", this.concurrency);
        jsonWriter.writeJsonField("errorAction", this.errorAction);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TaskOption from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TaskOption if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IOException If an error occurs while reading the TaskOption.
     */
    public static TaskOption fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TaskOption deserializedTaskOption = new TaskOption();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("concurrency".equals(fieldName)) {
                    deserializedTaskOption.concurrency = reader.getNullable(JsonReader::getInt);
                } else if ("errorAction".equals(fieldName)) {
                    deserializedTaskOption.errorAction = ErrorAction.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTaskOption;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/TaskSpec.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.Map;

/**
 * Task Spec.
 */
@Fluent
public final class TaskSpec implements JsonSerializable<TaskSpec> {
    /*
     * Name of Task
     */
    private String name;

    /*
     * Target ARM id
     */
    private String targetId;

    /*
     * Task specification
     */
    private Map<String, BinaryData> specification;

    /**
     * Creates an instance of TaskSpec class.
     */
    public TaskSpec() {
    }

    /**
     * Get the name property: Name of Task.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Set the name property: Name of Task.
     * 
     * @param name the name value to set.
     * @return the TaskSpec object itself.
     */
    public TaskSpec withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the targetId property: Target ARM id.
     * 
     * @return the targetId value.
     */
    public String targetId() {
        return this.targetId;
    }

    /**
     * Set the targetId property: Target ARM id.
     * 
     * @param targetId the targetId value to set.
     * @return the TaskSpec object itself.
     */
    public TaskSpec withTargetId(String targetId) {
        this.targetId = targetId;
        return this;
    }

    /**
     * Get the specification property: Task specification.
     * 
     * @return the specification value.
     */
    public Map<String, BinaryData> specification() {
        return this.specification;
    }

    /**
     * Set the specification property: Task specification.
     * 
     * @param specification the specification value to set.
     * @return the TaskSpec object itself.
     */
    public TaskSpec withSpecification(Map<String, BinaryData> specification) {
        this.specification = specification;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (name() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property name in model TaskSpec"));
        }
        if (specification() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property specification in model TaskSpec"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(TaskSpec.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeMapField("specification", this.specification,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        jsonWriter.writeStringField("targetId", this.targetId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TaskSpec from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TaskSpec if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TaskSpec.
     */
    public static TaskSpec fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TaskSpec deserializedTaskSpec = new TaskSpec();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("name".equals(fieldName)) {
                    deserializedTaskSpec.name = reader.getString();
                } else if ("specification".equals(fieldName)) {
                    Map<String, BinaryData> specification = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedTaskSpec.specification = specification;
                } else if ("targetId".equals(fieldName)) {
                    deserializedTaskSpec.targetId = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTaskSpec;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/UninstallSolutionParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Uninstall Solution Parameter.
 */
@Fluent
public final class UninstallSolutionParameter implements JsonSerializable<UninstallSolutionParameter> {
    /*
     * Solution Template ARM Id
     */
    private String solutionTemplateId;

    /*
     * Solution Instance Name
     */
    private String solutionInstanceName;

    /**
     * Creates an instance of UninstallSolutionParameter class.
     */
    public UninstallSolutionParameter() {
    }

    /**
     * Get the solutionTemplateId property: Solution Template ARM Id.
     * 
     * @return the solutionTemplateId value.
     */
    public String solutionTemplateId() {
        return this.solutionTemplateId;
    }

    /**
     * Set the solutionTemplateId property: Solution Template ARM Id.
     * 
     * @param solutionTemplateId the solutionTemplateId value to set.
     * @return the UninstallSolutionParameter object itself.
     */
    public UninstallSolutionParameter withSolutionTemplateId(String solutionTemplateId) {
        this.solutionTemplateId = solutionTemplateId;
        return this;
    }

    /**
     * Get the solutionInstanceName property: Solution Instance Name.
     * 
     * @return the solutionInstanceName value.
     */
    public String solutionInstanceName() {
        return this.solutionInstanceName;
    }

    /**
     * Set the solutionInstanceName property: Solution Instance Name.
     * 
     * @param solutionInstanceName the solutionInstanceName value to set.
     * @return the UninstallSolutionParameter object itself.
     */
    public UninstallSolutionParameter withSolutionInstanceName(String solutionInstanceName) {
        this.solutionInstanceName = solutionInstanceName;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionTemplateId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionTemplateId in model UninstallSolutionParameter"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(UninstallSolutionParameter.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionTemplateId", this.solutionTemplateId);
        jsonWriter.writeStringField("solutionInstanceName", this.solutionInstanceName);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of UninstallSolutionParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of UninstallSolutionParameter if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the UninstallSolutionParameter.
     */
    public static UninstallSolutionParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            UninstallSolutionParameter deserializedUninstallSolutionParameter = new UninstallSolutionParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionTemplateId".equals(fieldName)) {
                    deserializedUninstallSolutionParameter.solutionTemplateId = reader.getString();
                } else if ("solutionInstanceName".equals(fieldName)) {
                    deserializedUninstallSolutionParameter.solutionInstanceName = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedUninstallSolutionParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/UpdateExternalValidationStatusParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.management.exception.ManagementError;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Update External Validation Status Parameter.
 */
@Fluent
public final class UpdateExternalValidationStatusParameter
    implements JsonSerializable<UpdateExternalValidationStatusParameter> {
    /*
     * Solution Version Id
     */
    private String solutionVersionId;

    /*
     * Error Details if any failure is there
     */
    private ManagementError errorDetails;

    /*
     * External validation id
     */
    private String externalValidationId;

    /*
     * Validation Status of external validation
     */
    private ValidationStatus validationStatus;

    /**
     * Creates an instance of UpdateExternalValidationStatusParameter class.
     */
    public UpdateExternalValidationStatusParameter() {
    }

    /**
     * Get the solutionVersionId property: Solution Version Id.
     * 
     * @return the solutionVersionId value.
     */
    public String solutionVersionId() {
        return this.solutionVersionId;
    }

    /**
     * Set the solutionVersionId property: Solution Version Id.
     * 
     * @param solutionVersionId the solutionVersionId value to set.
     * @return the UpdateExternalValidationStatusParameter object itself.
     */
    public UpdateExternalValidationStatusParameter withSolutionVersionId(String solutionVersionId) {
        this.solutionVersionId = solutionVersionId;
        return this;
    }

    /**
     * Get the errorDetails property: Error Details if any failure is there.
     * 
     * @return the errorDetails value.
     */
    public ManagementError errorDetails() {
        return this.errorDetails;
    }

    /**
     * Set the errorDetails property: Error Details if any failure is there.
     * 
     * @param errorDetails the errorDetails value to set.
     * @return the UpdateExternalValidationStatusParameter object itself.
     */
    public UpdateExternalValidationStatusParameter withErrorDetails(ManagementError errorDetails) {
        this.errorDetails = errorDetails;
        return this;
    }

    /**
     * Get the externalValidationId property: External validation id.
     * 
     * @return the externalValidationId value.
     */
    public String externalValidationId() {
        return this.externalValidationId;
    }

    /**
     * Set the externalValidationId property: External validation id.
     * 
     * @param externalValidationId the externalValidationId value to set.
     * @return the UpdateExternalValidationStatusParameter object itself.
     */
    public UpdateExternalValidationStatusParameter withExternalValidationId(String externalValidationId) {
        this.externalValidationId = externalValidationId;
        return this;
    }

    /**
     * Get the validationStatus property: Validation Status of external validation.
     * 
     * @return the validationStatus value.
     */
    public ValidationStatus validationStatus() {
        return this.validationStatus;
    }

    /**
     * Set the validationStatus property: Validation Status of external validation.
     * 
     * @param validationStatus the validationStatus value to set.
     * @return the UpdateExternalValidationStatusParameter object itself.
     */
    public UpdateExternalValidationStatusParameter withValidationStatus(ValidationStatus validationStatus) {
        this.validationStatus = validationStatus;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (solutionVersionId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property solutionVersionId in model UpdateExternalValidationStatusParameter"));
        }
        if (externalValidationId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property externalValidationId in model UpdateExternalValidationStatusParameter"));
        }
        if (validationStatus() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property validationStatus in model UpdateExternalValidationStatusParameter"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(UpdateExternalValidationStatusParameter.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("solutionVersionId", this.solutionVersionId);
        jsonWriter.writeStringField("externalValidationId", this.externalValidationId);
        jsonWriter.writeStringField("validationStatus",
            this.validationStatus == null ? null : this.validationStatus.toString());
        jsonWriter.writeJsonField("errorDetails", this.errorDetails);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of UpdateExternalValidationStatusParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of UpdateExternalValidationStatusParameter if the JsonReader was pointing to an instance of
     * it, or null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the UpdateExternalValidationStatusParameter.
     */
    public static UpdateExternalValidationStatusParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            UpdateExternalValidationStatusParameter deserializedUpdateExternalValidationStatusParameter
                = new UpdateExternalValidationStatusParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("solutionVersionId".equals(fieldName)) {
                    deserializedUpdateExternalValidationStatusParameter.solutionVersionId = reader.getString();
                } else if ("externalValidationId".equals(fieldName)) {
                    deserializedUpdateExternalValidationStatusParameter.externalValidationId = reader.getString();
                } else if ("validationStatus".equals(fieldName)) {
                    deserializedUpdateExternalValidationStatusParameter.validationStatus
                        = ValidationStatus.fromString(reader.getString());
                } else if ("errorDetails".equals(fieldName)) {
                    deserializedUpdateExternalValidationStatusParameter.errorDetails = ManagementError.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedUpdateExternalValidationStatusParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/UpdateType.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Denotes which part of the version number will be updated.
 */
public final class UpdateType extends ExpandableStringEnum<UpdateType> {
    /**
     * Major version.
     */
    public static final UpdateType MAJOR = fromString("Major");

    /**
     * Minor version.
     */
    public static final UpdateType MINOR = fromString("Minor");

    /**
     * Patch version.
     */
    public static final UpdateType PATCH = fromString("Patch");

    /**
     * Creates a new instance of UpdateType value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public UpdateType() {
    }

    /**
     * Creates or finds a UpdateType from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding UpdateType.
     */
    public static UpdateType fromString(String name) {
        return fromString(name, UpdateType.class);
    }

    /**
     * Gets known UpdateType values.
     * 
     * @return known UpdateType values.
     */
    public static Collection<UpdateType> values() {
        return values(UpdateType.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/ValidationStatus.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.util.ExpandableStringEnum;
import java.util.Collection;

/**
 * Solution Instance Validation Status.
 */
public final class ValidationStatus extends ExpandableStringEnum<ValidationStatus> {
    /**
     * Solution Instance is valid.
     */
    public static final ValidationStatus VALID = fromString("Valid");

    /**
     * Solution Instance is invalid.
     */
    public static final ValidationStatus INVALID = fromString("Invalid");

    /**
     * Creates a new instance of ValidationStatus value.
     * 
     * @deprecated Use the {@link #fromString(String)} factory method.
     */
    @Deprecated
    public ValidationStatus() {
    }

    /**
     * Creates or finds a ValidationStatus from its string representation.
     * 
     * @param name a name to look for.
     * @return the corresponding ValidationStatus.
     */
    public static ValidationStatus fromString(String name) {
        return fromString(name, ValidationStatus.class);
    }

    /**
     * Gets known ValidationStatus values.
     * 
     * @return known ValidationStatus values.
     */
    public static Collection<ValidationStatus> values() {
        return values(ValidationStatus.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/VersionParameter.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Version Parameter.
 */
@Fluent
public final class VersionParameter implements JsonSerializable<VersionParameter> {
    /*
     * Version of the Resource
     */
    private String version;

    /**
     * Creates an instance of VersionParameter class.
     */
    public VersionParameter() {
    }

    /**
     * Get the version property: Version of the Resource.
     * 
     * @return the version value.
     */
    public String version() {
        return this.version;
    }

    /**
     * Set the version property: Version of the Resource.
     * 
     * @param version the version value to set.
     * @return the VersionParameter object itself.
     */
    public VersionParameter withVersion(String version) {
        this.version = version;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (version() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property version in model VersionParameter"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(VersionParameter.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("version", this.version);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of VersionParameter from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of VersionParameter if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the VersionParameter.
     */
    public static VersionParameter fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            VersionParameter deserializedVersionParameter = new VersionParameter();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("version".equals(fieldName)) {
                    deserializedVersionParameter.version = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedVersionParameter;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Workflow.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner;

/**
 * An immutable client-side representation of Workflow.
 */
public interface Workflow {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    WorkflowProperties properties();

    /**
     * Gets the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    ExtendedLocation extendedLocation();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner object.
     * 
     * @return the inner object.
     */
    WorkflowInner innerModel();

    /**
     * The entirety of the Workflow definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The Workflow definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the Workflow definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the Workflow definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, contextName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param contextName The name of the Context.
             * @return the next definition stage.
             */
            WithCreate withExistingContext(String resourceGroupName, String contextName);
        }

        /**
         * The stage of the Workflow definition which contains all the minimum required properties for the resource to
         * be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties, DefinitionStages.WithExtendedLocation {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            Workflow create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            Workflow create(Context context);
        }

        /**
         * The stage of the Workflow definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(WorkflowProperties properties);
        }

        /**
         * The stage of the Workflow definition allowing to specify extendedLocation.
         */
        interface WithExtendedLocation {
            /**
             * Specifies the extendedLocation property: The extendedLocation property..
             * 
             * @param extendedLocation The extendedLocation property.
             * @return the next definition stage.
             */
            WithCreate withExtendedLocation(ExtendedLocation extendedLocation);
        }
    }

    /**
     * Begins update for the Workflow resource.
     * 
     * @return the stage of resource update.
     */
    Workflow.Update update();

    /**
     * The template for Workflow update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        Workflow apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        Workflow apply(Context context);
    }

    /**
     * The Workflow update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the Workflow update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(WorkflowProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    Workflow refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    Workflow refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/WorkflowProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Workflow Properties.
 */
@Immutable
public final class WorkflowProperties implements JsonSerializable<WorkflowProperties> {
    /*
     * Workflow template Id
     */
    private String workflowTemplateId;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of WorkflowProperties class.
     */
    public WorkflowProperties() {
    }

    /**
     * Get the workflowTemplateId property: Workflow template Id.
     * 
     * @return the workflowTemplateId value.
     */
    public String workflowTemplateId() {
        return this.workflowTemplateId;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of WorkflowProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of WorkflowProperties if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the WorkflowProperties.
     */
    public static WorkflowProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            WorkflowProperties deserializedWorkflowProperties = new WorkflowProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("workflowTemplateId".equals(fieldName)) {
                    deserializedWorkflowProperties.workflowTemplateId = reader.getString();
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedWorkflowProperties.provisioningState = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedWorkflowProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/Workflows.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of Workflows.
 */
public interface Workflows {
    /**
     * Get a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource along with {@link Response}.
     */
    Response<Workflow> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        Context context);

    /**
     * Get a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource.
     */
    Workflow get(String resourceGroupName, String contextName, String workflowName);

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String contextName, String workflowName);

    /**
     * Delete a Workflow resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String contextName, String workflowName, Context context);

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Workflow> listByContext(String resourceGroupName, String contextName);

    /**
     * List Workflow resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a Workflow list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<Workflow> listByContext(String resourceGroupName, String contextName, Context context);

    /**
     * Get a Workflow resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource along with {@link Response}.
     */
    Workflow getById(String id);

    /**
     * Get a Workflow resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow resource along with {@link Response}.
     */
    Response<Workflow> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Workflow resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Workflow resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new Workflow resource.
     * 
     * @param name resource name.
     * @return the first stage of the new Workflow definition.
     */
    Workflow.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/WorkflowVersion.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.management.SystemData;
import com.azure.core.util.Context;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner;

/**
 * An immutable client-side representation of WorkflowVersion.
 */
public interface WorkflowVersion {
    /**
     * Gets the id property: Fully qualified resource Id for the resource.
     * 
     * @return the id value.
     */
    String id();

    /**
     * Gets the name property: The name of the resource.
     * 
     * @return the name value.
     */
    String name();

    /**
     * Gets the type property: The type of the resource.
     * 
     * @return the type value.
     */
    String type();

    /**
     * Gets the properties property: The resource-specific properties for this resource.
     * 
     * @return the properties value.
     */
    WorkflowVersionProperties properties();

    /**
     * Gets the extendedLocation property: The extendedLocation property.
     * 
     * @return the extendedLocation value.
     */
    ExtendedLocation extendedLocation();

    /**
     * Gets the eTag property: If eTag is provided in the response body, it may also be provided as a header per the
     * normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource.
     * HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26),
     * and If-Range (section 14.27) header fields.
     * 
     * @return the eTag value.
     */
    String eTag();

    /**
     * Gets the systemData property: Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * 
     * @return the systemData value.
     */
    SystemData systemData();

    /**
     * Gets the name of the resource group.
     * 
     * @return the name of the resource group.
     */
    String resourceGroupName();

    /**
     * Gets the inner com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner object.
     * 
     * @return the inner object.
     */
    WorkflowVersionInner innerModel();

    /**
     * The entirety of the WorkflowVersion definition.
     */
    interface Definition
        extends DefinitionStages.Blank, DefinitionStages.WithParentResource, DefinitionStages.WithCreate {
    }

    /**
     * The WorkflowVersion definition stages.
     */
    interface DefinitionStages {
        /**
         * The first stage of the WorkflowVersion definition.
         */
        interface Blank extends WithParentResource {
        }

        /**
         * The stage of the WorkflowVersion definition allowing to specify parent resource.
         */
        interface WithParentResource {
            /**
             * Specifies resourceGroupName, contextName, workflowName.
             * 
             * @param resourceGroupName The name of the resource group. The name is case insensitive.
             * @param contextName The name of the Context.
             * @param workflowName Name of the workflow.
             * @return the next definition stage.
             */
            WithCreate withExistingWorkflow(String resourceGroupName, String contextName, String workflowName);
        }

        /**
         * The stage of the WorkflowVersion definition which contains all the minimum required properties for the
         * resource to be created, but also allows for any other optional properties to be specified.
         */
        interface WithCreate extends DefinitionStages.WithProperties, DefinitionStages.WithExtendedLocation {
            /**
             * Executes the create request.
             * 
             * @return the created resource.
             */
            WorkflowVersion create();

            /**
             * Executes the create request.
             * 
             * @param context The context to associate with this operation.
             * @return the created resource.
             */
            WorkflowVersion create(Context context);
        }

        /**
         * The stage of the WorkflowVersion definition allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            WithCreate withProperties(WorkflowVersionProperties properties);
        }

        /**
         * The stage of the WorkflowVersion definition allowing to specify extendedLocation.
         */
        interface WithExtendedLocation {
            /**
             * Specifies the extendedLocation property: The extendedLocation property..
             * 
             * @param extendedLocation The extendedLocation property.
             * @return the next definition stage.
             */
            WithCreate withExtendedLocation(ExtendedLocation extendedLocation);
        }
    }

    /**
     * Begins update for the WorkflowVersion resource.
     * 
     * @return the stage of resource update.
     */
    WorkflowVersion.Update update();

    /**
     * The template for WorkflowVersion update.
     */
    interface Update extends UpdateStages.WithProperties {
        /**
         * Executes the update request.
         * 
         * @return the updated resource.
         */
        WorkflowVersion apply();

        /**
         * Executes the update request.
         * 
         * @param context The context to associate with this operation.
         * @return the updated resource.
         */
        WorkflowVersion apply(Context context);
    }

    /**
     * The WorkflowVersion update stages.
     */
    interface UpdateStages {
        /**
         * The stage of the WorkflowVersion update allowing to specify properties.
         */
        interface WithProperties {
            /**
             * Specifies the properties property: The resource-specific properties for this resource..
             * 
             * @param properties The resource-specific properties for this resource.
             * @return the next definition stage.
             */
            Update withProperties(WorkflowVersionProperties properties);
        }
    }

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @return the refreshed resource.
     */
    WorkflowVersion refresh();

    /**
     * Refreshes the resource to sync with Azure.
     * 
     * @param context The context to associate with this operation.
     * @return the refreshed resource.
     */
    WorkflowVersion refresh(Context context);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/WorkflowVersionProperties.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Workflow Version Properties.
 */
@Fluent
public final class WorkflowVersionProperties implements JsonSerializable<WorkflowVersionProperties> {
    /*
     * Revision number of resolved config for this workflow version
     */
    private Integer revision;

    /*
     * Resolved configuration values
     */
    private String configuration;

    /*
     * A list of stage specs
     */
    private List<StageSpec> stageSpec;

    /*
     * Review id of resolved config for this workflow version
     */
    private String reviewId;

    /*
     * State of workflow version
     */
    private State state;

    /*
     * Execution specification
     */
    private Map<String, BinaryData> specification;

    /*
     * Provisioning state of resource
     */
    private ProvisioningState provisioningState;

    /**
     * Creates an instance of WorkflowVersionProperties class.
     */
    public WorkflowVersionProperties() {
    }

    /**
     * Get the revision property: Revision number of resolved config for this workflow version.
     * 
     * @return the revision value.
     */
    public Integer revision() {
        return this.revision;
    }

    /**
     * Get the configuration property: Resolved configuration values.
     * 
     * @return the configuration value.
     */
    public String configuration() {
        return this.configuration;
    }

    /**
     * Get the stageSpec property: A list of stage specs.
     * 
     * @return the stageSpec value.
     */
    public List<StageSpec> stageSpec() {
        return this.stageSpec;
    }

    /**
     * Set the stageSpec property: A list of stage specs.
     * 
     * @param stageSpec the stageSpec value to set.
     * @return the WorkflowVersionProperties object itself.
     */
    public WorkflowVersionProperties withStageSpec(List<StageSpec> stageSpec) {
        this.stageSpec = stageSpec;
        return this;
    }

    /**
     * Get the reviewId property: Review id of resolved config for this workflow version.
     * 
     * @return the reviewId value.
     */
    public String reviewId() {
        return this.reviewId;
    }

    /**
     * Get the state property: State of workflow version.
     * 
     * @return the state value.
     */
    public State state() {
        return this.state;
    }

    /**
     * Get the specification property: Execution specification.
     * 
     * @return the specification value.
     */
    public Map<String, BinaryData> specification() {
        return this.specification;
    }

    /**
     * Set the specification property: Execution specification.
     * 
     * @param specification the specification value to set.
     * @return the WorkflowVersionProperties object itself.
     */
    public WorkflowVersionProperties withSpecification(Map<String, BinaryData> specification) {
        this.specification = specification;
        return this;
    }

    /**
     * Get the provisioningState property: Provisioning state of resource.
     * 
     * @return the provisioningState value.
     */
    public ProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (stageSpec() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property stageSpec in model WorkflowVersionProperties"));
        } else {
            stageSpec().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(WorkflowVersionProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("stageSpec", this.stageSpec, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeMapField("specification", this.specification,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of WorkflowVersionProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of WorkflowVersionProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the WorkflowVersionProperties.
     */
    public static WorkflowVersionProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            WorkflowVersionProperties deserializedWorkflowVersionProperties = new WorkflowVersionProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("stageSpec".equals(fieldName)) {
                    List<StageSpec> stageSpec = reader.readArray(reader1 -> StageSpec.fromJson(reader1));
                    deserializedWorkflowVersionProperties.stageSpec = stageSpec;
                } else if ("revision".equals(fieldName)) {
                    deserializedWorkflowVersionProperties.revision = reader.getNullable(JsonReader::getInt);
                } else if ("configuration".equals(fieldName)) {
                    deserializedWorkflowVersionProperties.configuration = reader.getString();
                } else if ("reviewId".equals(fieldName)) {
                    deserializedWorkflowVersionProperties.reviewId = reader.getString();
                } else if ("state".equals(fieldName)) {
                    deserializedWorkflowVersionProperties.state = State.fromString(reader.getString());
                } else if ("specification".equals(fieldName)) {
                    Map<String, BinaryData> specification = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedWorkflowVersionProperties.specification = specification;
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedWorkflowVersionProperties.provisioningState
                        = ProvisioningState.fromString(reader.getString());
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedWorkflowVersionProperties;
        });
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/java/com/azure/resourcemanager/workloadorchestration/models/WorkflowVersions.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.models;

import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.Response;
import com.azure.core.util.Context;

/**
 * Resource collection API of WorkflowVersions.
 */
public interface WorkflowVersions {
    /**
     * Get a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource along with {@link Response}.
     */
    Response<WorkflowVersion> getWithResponse(String resourceGroupName, String contextName, String workflowName,
        String versionName, Context context);

    /**
     * Get a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource.
     */
    WorkflowVersion get(String resourceGroupName, String contextName, String workflowName, String versionName);

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String contextName, String workflowName, String versionName);

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param versionName The name of the workflowVersion.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void delete(String resourceGroupName, String contextName, String workflowName, String versionName, Context context);

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<WorkflowVersion> listByWorkflow(String resourceGroupName, String contextName, String workflowName);

    /**
     * List Workflow Version Resources.
     * 
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param contextName The name of the Context.
     * @param workflowName Name of the workflow.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response of a WorkflowVersion list operation as paginated response with {@link PagedIterable}.
     */
    PagedIterable<WorkflowVersion> listByWorkflow(String resourceGroupName, String contextName, String workflowName,
        Context context);

    /**
     * Get a Workflow Version Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource along with {@link Response}.
     */
    WorkflowVersion getById(String id);

    /**
     * Get a Workflow Version Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a Workflow Version Resource along with {@link Response}.
     */
    Response<WorkflowVersion> getByIdWithResponse(String id, Context context);

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param id the resource ID.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteById(String id);

    /**
     * Delete a Workflow Version Resource.
     * 
     * @param id the resource ID.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    void deleteByIdWithResponse(String id, Context context);

    /**
     * Begins definition for a new WorkflowVersion resource.
     * 
     * @param name resource name.
     * @return the first stage of the new WorkflowVersion definition.
     */
    WorkflowVersion.DefinitionStages.Blank define(String name);
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/resources/azure-resourcemanager-workloadorchestration.properties
================================================
version=${project.version}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/resources/META-INF/azure-resourcemanager-workloadorchestration_apiview_properties.json
================================================
{
  "flavor": "azure", 
  "CrossLanguageDefinitionId": {
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient": "Microsoft.Edge.ConfigTemplateVersions",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient.get": "Microsoft.Edge.ConfigTemplateVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient.getWithResponse": "Microsoft.Edge.ConfigTemplateVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient.listByConfigTemplate": "Microsoft.Edge.ConfigTemplateVersions.listByConfigTemplate",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient": "Microsoft.Edge.ConfigTemplates",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.beginCreateOrUpdate": "Microsoft.Edge.ConfigTemplates.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.beginCreateVersion": "Microsoft.Edge.ConfigTemplates.createVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.beginDelete": "Microsoft.Edge.ConfigTemplates.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.createOrUpdate": "Microsoft.Edge.ConfigTemplates.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.createVersion": "Microsoft.Edge.ConfigTemplates.createVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.delete": "Microsoft.Edge.ConfigTemplates.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.getByResourceGroup": "Microsoft.Edge.ConfigTemplates.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.getByResourceGroupWithResponse": "Microsoft.Edge.ConfigTemplates.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.list": "Microsoft.Edge.ConfigTemplates.listBySubscription",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.listByResourceGroup": "Microsoft.Edge.ConfigTemplates.listByResourceGroup",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.removeVersion": "Microsoft.Edge.ConfigTemplates.removeVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.removeVersionWithResponse": "Microsoft.Edge.ConfigTemplates.removeVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.update": "Microsoft.Edge.ConfigTemplates.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.updateWithResponse": "Microsoft.Edge.ConfigTemplates.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient": "Microsoft.Edge.Contexts",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.beginCreateOrUpdate": "Microsoft.Edge.Contexts.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.beginDelete": "Microsoft.Edge.Contexts.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.beginUpdate": "Microsoft.Edge.Contexts.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.createOrUpdate": "Microsoft.Edge.Contexts.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.delete": "Microsoft.Edge.Contexts.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.getByResourceGroup": "Microsoft.Edge.Contexts.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.getByResourceGroupWithResponse": "Microsoft.Edge.Contexts.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.list": "Microsoft.Edge.Contexts.listBySubscription",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.listByResourceGroup": "Microsoft.Edge.Contexts.listByResourceGroup",
    "com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.update": "Microsoft.Edge.Contexts.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient": "Microsoft.Edge.Diagnostics",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.beginCreateOrUpdate": "Microsoft.Edge.Diagnostics.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.beginDelete": "Microsoft.Edge.Diagnostics.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.beginUpdate": "Microsoft.Edge.Diagnostics.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.createOrUpdate": "Microsoft.Edge.Diagnostics.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.delete": "Microsoft.Edge.Diagnostics.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.getByResourceGroup": "Microsoft.Edge.Diagnostics.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.getByResourceGroupWithResponse": "Microsoft.Edge.Diagnostics.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.list": "Microsoft.Edge.Diagnostics.listBySubscription",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.listByResourceGroup": "Microsoft.Edge.Diagnostics.listByResourceGroup",
    "com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.update": "Microsoft.Edge.Diagnostics.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient": "Microsoft.Edge.DynamicSchemaVersions",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.beginCreateOrUpdate": "Microsoft.Edge.DynamicSchemaVersions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.beginDelete": "Microsoft.Edge.DynamicSchemaVersions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.createOrUpdate": "Microsoft.Edge.DynamicSchemaVersions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.delete": "Microsoft.Edge.DynamicSchemaVersions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.get": "Microsoft.Edge.DynamicSchemaVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.getWithResponse": "Microsoft.Edge.DynamicSchemaVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.listByDynamicSchema": "Microsoft.Edge.DynamicSchemaVersions.listByDynamicSchema",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.update": "Microsoft.Edge.DynamicSchemaVersions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.updateWithResponse": "Microsoft.Edge.DynamicSchemaVersions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient": "Microsoft.Edge.DynamicSchemas",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.beginCreateOrUpdate": "Microsoft.Edge.DynamicSchemas.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.beginDelete": "Microsoft.Edge.DynamicSchemas.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.createOrUpdate": "Microsoft.Edge.DynamicSchemas.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.delete": "Microsoft.Edge.DynamicSchemas.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.get": "Microsoft.Edge.DynamicSchemas.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.getWithResponse": "Microsoft.Edge.DynamicSchemas.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.listBySchema": "Microsoft.Edge.DynamicSchemas.listBySchema",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.update": "Microsoft.Edge.DynamicSchemas.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.updateWithResponse": "Microsoft.Edge.DynamicSchemas.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient": "Microsoft.Edge.Executions",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.beginCreateOrUpdate": "Microsoft.Edge.Executions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.beginDelete": "Microsoft.Edge.Executions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.beginUpdate": "Microsoft.Edge.Executions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.createOrUpdate": "Microsoft.Edge.Executions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.delete": "Microsoft.Edge.Executions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.get": "Microsoft.Edge.Executions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.getWithResponse": "Microsoft.Edge.Executions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.listByWorkflowVersion": "Microsoft.Edge.Executions.listByWorkflowVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.update": "Microsoft.Edge.Executions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient": "Microsoft.Edge.InstanceHistories",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient.get": "Microsoft.Edge.InstanceHistories.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient.getWithResponse": "Microsoft.Edge.InstanceHistories.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient.listByInstance": "Microsoft.Edge.InstanceHistories.listByInstance",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient": "Microsoft.Edge.Instances",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.beginCreateOrUpdate": "Microsoft.Edge.Instances.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.beginDelete": "Microsoft.Edge.Instances.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.beginUpdate": "Microsoft.Edge.Instances.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.createOrUpdate": "Microsoft.Edge.Instances.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.delete": "Microsoft.Edge.Instances.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.get": "Microsoft.Edge.Instances.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.getWithResponse": "Microsoft.Edge.Instances.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.listBySolution": "Microsoft.Edge.Instances.listBySolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.update": "Microsoft.Edge.Instances.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.JobsClient": "Microsoft.Edge.Jobs",
    "com.azure.resourcemanager.workloadorchestration.fluent.JobsClient.get": "Microsoft.Edge.Jobs.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.JobsClient.getWithResponse": "Microsoft.Edge.Jobs.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.JobsClient.listByTarget": "Microsoft.Edge.Jobs.listByTarget",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient": "Microsoft.Edge.SchemaReferences",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient.get": "Microsoft.Edge.SchemaReferences.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient.getWithResponse": "Microsoft.Edge.SchemaReferences.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient.listByResourceGroup": "Microsoft.Edge.SchemaReferences.listByResourceGroup",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient": "Microsoft.Edge.SchemaVersions",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.beginCreateOrUpdate": "Microsoft.Edge.SchemaVersions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.beginDelete": "Microsoft.Edge.SchemaVersions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.createOrUpdate": "Microsoft.Edge.SchemaVersions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.delete": "Microsoft.Edge.SchemaVersions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.get": "Microsoft.Edge.SchemaVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.getWithResponse": "Microsoft.Edge.SchemaVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.listBySchema": "Microsoft.Edge.SchemaVersions.listBySchema",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.update": "Microsoft.Edge.SchemaVersions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.updateWithResponse": "Microsoft.Edge.SchemaVersions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient": "Microsoft.Edge.Schemas",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.beginCreateOrUpdate": "Microsoft.Edge.Schemas.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.beginCreateVersion": "Microsoft.Edge.Schemas.createVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.beginDelete": "Microsoft.Edge.Schemas.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.createOrUpdate": "Microsoft.Edge.Schemas.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.createVersion": "Microsoft.Edge.Schemas.createVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.delete": "Microsoft.Edge.Schemas.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.getByResourceGroup": "Microsoft.Edge.Schemas.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.getByResourceGroupWithResponse": "Microsoft.Edge.Schemas.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.list": "Microsoft.Edge.Schemas.listBySubscription",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.listByResourceGroup": "Microsoft.Edge.Schemas.listByResourceGroup",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.removeVersion": "Microsoft.Edge.Schemas.removeVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.removeVersionWithResponse": "Microsoft.Edge.Schemas.removeVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.update": "Microsoft.Edge.Schemas.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.updateWithResponse": "Microsoft.Edge.Schemas.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient": "Microsoft.Edge.SiteReferences",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.beginCreateOrUpdate": "Microsoft.Edge.SiteReferences.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.beginDelete": "Microsoft.Edge.SiteReferences.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.beginUpdate": "Microsoft.Edge.SiteReferences.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.createOrUpdate": "Microsoft.Edge.SiteReferences.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.delete": "Microsoft.Edge.SiteReferences.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.get": "Microsoft.Edge.SiteReferences.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.getWithResponse": "Microsoft.Edge.SiteReferences.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.listByContext": "Microsoft.Edge.SiteReferences.listByContext",
    "com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.update": "Microsoft.Edge.SiteReferences.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient": "Microsoft.Edge.SolutionTemplateVersions",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.beginBulkDeploySolution": "Microsoft.Edge.SolutionTemplateVersions.bulkDeploySolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.beginBulkPublishSolution": "Microsoft.Edge.SolutionTemplateVersions.bulkPublishSolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.bulkDeploySolution": "Microsoft.Edge.SolutionTemplateVersions.bulkDeploySolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.bulkPublishSolution": "Microsoft.Edge.SolutionTemplateVersions.bulkPublishSolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.get": "Microsoft.Edge.SolutionTemplateVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.getWithResponse": "Microsoft.Edge.SolutionTemplateVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.listBySolutionTemplate": "Microsoft.Edge.SolutionTemplateVersions.listBySolutionTemplate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient": "Microsoft.Edge.SolutionTemplates",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.beginCreateOrUpdate": "Microsoft.Edge.SolutionTemplates.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.beginCreateVersion": "Microsoft.Edge.SolutionTemplates.createVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.beginDelete": "Microsoft.Edge.SolutionTemplates.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.beginRemoveVersion": "Microsoft.Edge.SolutionTemplates.removeVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.createOrUpdate": "Microsoft.Edge.SolutionTemplates.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.createVersion": "Microsoft.Edge.SolutionTemplates.createVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.delete": "Microsoft.Edge.SolutionTemplates.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.getByResourceGroup": "Microsoft.Edge.SolutionTemplates.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.getByResourceGroupWithResponse": "Microsoft.Edge.SolutionTemplates.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.list": "Microsoft.Edge.SolutionTemplates.listBySubscription",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.listByResourceGroup": "Microsoft.Edge.SolutionTemplates.listByResourceGroup",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.removeVersion": "Microsoft.Edge.SolutionTemplates.removeVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.update": "Microsoft.Edge.SolutionTemplates.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.updateWithResponse": "Microsoft.Edge.SolutionTemplates.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient": "Microsoft.Edge.SolutionVersions",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.beginCreateOrUpdate": "Microsoft.Edge.SolutionVersions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.beginDelete": "Microsoft.Edge.SolutionVersions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.beginUpdate": "Microsoft.Edge.SolutionVersions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.createOrUpdate": "Microsoft.Edge.SolutionVersions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.delete": "Microsoft.Edge.SolutionVersions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.get": "Microsoft.Edge.SolutionVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.getWithResponse": "Microsoft.Edge.SolutionVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.listBySolution": "Microsoft.Edge.SolutionVersions.listBySolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.update": "Microsoft.Edge.SolutionVersions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient": "Microsoft.Edge.Solutions",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.beginCreateOrUpdate": "Microsoft.Edge.Solutions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.beginDelete": "Microsoft.Edge.Solutions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.beginUpdate": "Microsoft.Edge.Solutions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.createOrUpdate": "Microsoft.Edge.Solutions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.delete": "Microsoft.Edge.Solutions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.get": "Microsoft.Edge.Solutions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.getWithResponse": "Microsoft.Edge.Solutions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.listByTarget": "Microsoft.Edge.Solutions.listByTarget",
    "com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.update": "Microsoft.Edge.Solutions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient": "Microsoft.Edge.Targets",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginCreateOrUpdate": "Microsoft.Edge.Targets.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginDelete": "Microsoft.Edge.Targets.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginInstallSolution": "Microsoft.Edge.Targets.installSolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginPublishSolutionVersion": "Microsoft.Edge.Targets.publishSolutionVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginRemoveRevision": "Microsoft.Edge.Targets.removeRevision",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginResolveConfiguration": "Microsoft.Edge.Targets.resolveConfiguration",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginReviewSolutionVersion": "Microsoft.Edge.Targets.reviewSolutionVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginUninstallSolution": "Microsoft.Edge.Targets.uninstallSolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginUpdate": "Microsoft.Edge.Targets.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginUpdateExternalValidationStatus": "Microsoft.Edge.Targets.updateExternalValidationStatus",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.createOrUpdate": "Microsoft.Edge.Targets.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.delete": "Microsoft.Edge.Targets.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.getByResourceGroup": "Microsoft.Edge.Targets.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.getByResourceGroupWithResponse": "Microsoft.Edge.Targets.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.installSolution": "Microsoft.Edge.Targets.installSolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.list": "Microsoft.Edge.Targets.listBySubscription",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.listByResourceGroup": "Microsoft.Edge.Targets.listByResourceGroup",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.publishSolutionVersion": "Microsoft.Edge.Targets.publishSolutionVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.removeRevision": "Microsoft.Edge.Targets.removeRevision",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.resolveConfiguration": "Microsoft.Edge.Targets.resolveConfiguration",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.reviewSolutionVersion": "Microsoft.Edge.Targets.reviewSolutionVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.uninstallSolution": "Microsoft.Edge.Targets.uninstallSolution",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.update": "Microsoft.Edge.Targets.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.updateExternalValidationStatus": "Microsoft.Edge.Targets.updateExternalValidationStatus",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient": "Microsoft.Edge.WorkflowVersions",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.beginCreateOrUpdate": "Microsoft.Edge.WorkflowVersions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.beginDelete": "Microsoft.Edge.WorkflowVersions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.beginUpdate": "Microsoft.Edge.WorkflowVersions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.createOrUpdate": "Microsoft.Edge.WorkflowVersions.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.delete": "Microsoft.Edge.WorkflowVersions.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.get": "Microsoft.Edge.WorkflowVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.getWithResponse": "Microsoft.Edge.WorkflowVersions.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.listByWorkflow": "Microsoft.Edge.WorkflowVersions.listByWorkflow",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.update": "Microsoft.Edge.WorkflowVersions.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient": "Microsoft.Edge.Workflows",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.beginCreateOrUpdate": "Microsoft.Edge.Workflows.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.beginDelete": "Microsoft.Edge.Workflows.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.beginUpdate": "Microsoft.Edge.Workflows.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.createOrUpdate": "Microsoft.Edge.Workflows.createOrUpdate",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.delete": "Microsoft.Edge.Workflows.delete",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.get": "Microsoft.Edge.Workflows.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.getWithResponse": "Microsoft.Edge.Workflows.get",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.listByContext": "Microsoft.Edge.Workflows.listByContext",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.update": "Microsoft.Edge.Workflows.update",
    "com.azure.resourcemanager.workloadorchestration.fluent.WorkloadOrchestrationManagementClient": "Microsoft.Edge",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner": "Microsoft.Edge.ConfigTemplate",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner": "Microsoft.Edge.ConfigTemplateVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner": "Microsoft.Edge.ConfigTemplateVersionWithUpdateType",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner": "Microsoft.Edge.Context",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner": "Microsoft.Edge.Diagnostic",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner": "Microsoft.Edge.DynamicSchema",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner": "Microsoft.Edge.DynamicSchemaVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner": "Microsoft.Edge.Execution",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner": "Microsoft.Edge.InstanceHistory",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner": "Microsoft.Edge.Instance",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.JobInner": "Microsoft.Edge.Job",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner": "Microsoft.Edge.RemoveVersionResponse",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.ResolvedConfigurationInner": "Microsoft.Edge.ResolvedConfiguration",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner": "Microsoft.Edge.Schema",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner": "Microsoft.Edge.SchemaReference",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner": "Microsoft.Edge.SchemaVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner": "Microsoft.Edge.SchemaVersionWithUpdateType",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner": "Microsoft.Edge.SiteReference",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner": "Microsoft.Edge.Solution",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner": "Microsoft.Edge.SolutionTemplate",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner": "Microsoft.Edge.SolutionTemplateVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner": "Microsoft.Edge.SolutionTemplateVersionWithUpdateType",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner": "Microsoft.Edge.SolutionVersion",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner": "Microsoft.Edge.Target",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner": "Microsoft.Edge.Workflow",
    "com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner": "Microsoft.Edge.WorkflowVersion",
    "com.azure.resourcemanager.workloadorchestration.implementation.WorkloadOrchestrationManagementClientBuilder": "Microsoft.Edge",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.ConfigTemplateListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.ConfigTemplateVersionListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.ContextListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.DiagnosticListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.DynamicSchemaListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.DynamicSchemaVersionListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.ExecutionListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.InstanceHistoryListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.InstanceListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.JobListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaReferenceListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaVersionListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.SiteReferenceListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionTemplateListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionTemplateVersionListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionVersionListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.TargetListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.WorkflowListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.implementation.models.WorkflowVersionListResult": "Azure.ResourceManager.ResourceListResult",
    "com.azure.resourcemanager.workloadorchestration.models.ActiveState": "Microsoft.Edge.ActiveState",
    "com.azure.resourcemanager.workloadorchestration.models.AvailableSolutionTemplateVersion": "Microsoft.Edge.AvailableSolutionTemplateVersion",
    "com.azure.resourcemanager.workloadorchestration.models.BulkDeploySolutionParameter": "Microsoft.Edge.BulkDeploySolutionParameter",
    "com.azure.resourcemanager.workloadorchestration.models.BulkDeployTargetDetails": "Microsoft.Edge.BulkDeployTargetDetails",
    "com.azure.resourcemanager.workloadorchestration.models.BulkPublishSolutionParameter": "Microsoft.Edge.BulkPublishSolutionParameter",
    "com.azure.resourcemanager.workloadorchestration.models.BulkPublishTargetDetails": "Microsoft.Edge.BulkPublishTargetDetails",
    "com.azure.resourcemanager.workloadorchestration.models.Capability": "Microsoft.Edge.Capability",
    "com.azure.resourcemanager.workloadorchestration.models.ComponentStatus": "Microsoft.Edge.ComponentStatus",
    "com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties": "Microsoft.Edge.ConfigTemplateProperties",
    "com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties": "Microsoft.Edge.ConfigTemplateVersionProperties",
    "com.azure.resourcemanager.workloadorchestration.models.ConfigurationModel": "Microsoft.Edge.ConfigurationModel",
    "com.azure.resourcemanager.workloadorchestration.models.ConfigurationType": "Microsoft.Edge.ConfigurationType",
    "com.azure.resourcemanager.workloadorchestration.models.ContextProperties": "Microsoft.Edge.ContextProperties",
    "com.azure.resourcemanager.workloadorchestration.models.DeployJobParameter": "Microsoft.Edge.DeployJobParameter",
    "com.azure.resourcemanager.workloadorchestration.models.DeployJobStepStatistics": "Microsoft.Edge.DeployJobStepStatistics",
    "com.azure.resourcemanager.workloadorchestration.models.DeploymentStatus": "Microsoft.Edge.DeploymentStatus",
    "com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties": "Microsoft.Edge.DiagnosticProperties",
    "com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties": "Microsoft.Edge.DynamicSchemaProperties",
    "com.azure.resourcemanager.workloadorchestration.models.ErrorAction": "Microsoft.Edge.ErrorAction",
    "com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode": "Microsoft.Edge.ErrorActionMode",
    "com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties": "Microsoft.Edge.ExecutionProperties",
    "com.azure.resourcemanager.workloadorchestration.models.ExecutionStatus": "Microsoft.Edge.ExecutionStatus",
    "com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation": "Azure.ResourceManager.CommonTypes.ExtendedLocation",
    "com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType": "Azure.ResourceManager.CommonTypes.ExtendedLocationType",
    "com.azure.resourcemanager.workloadorchestration.models.Hierarchy": "Microsoft.Edge.Hierarchy",
    "com.azure.resourcemanager.workloadorchestration.models.InstallSolutionParameter": "Microsoft.Edge.InstallSolutionParameter",
    "com.azure.resourcemanager.workloadorchestration.models.InstanceHistoryProperties": "Microsoft.Edge.InstanceHistoryProperties",
    "com.azure.resourcemanager.workloadorchestration.models.InstanceProperties": "Microsoft.Edge.InstanceProperties",
    "com.azure.resourcemanager.workloadorchestration.models.JobParameterBase": "Microsoft.Edge.JobParameterBase",
    "com.azure.resourcemanager.workloadorchestration.models.JobProperties": "Microsoft.Edge.JobProperties",
    "com.azure.resourcemanager.workloadorchestration.models.JobStatus": "Microsoft.Edge.JobStatus",
    "com.azure.resourcemanager.workloadorchestration.models.JobStep": "Microsoft.Edge.JobStep",
    "com.azure.resourcemanager.workloadorchestration.models.JobStepStatisticsBase": "Microsoft.Edge.JobStepStatisticsBase",
    "com.azure.resourcemanager.workloadorchestration.models.JobType": "Microsoft.Edge.JobType",
    "com.azure.resourcemanager.workloadorchestration.models.OrchestratorType": "Microsoft.Edge.OrchestratorType",
    "com.azure.resourcemanager.workloadorchestration.models.ProvisioningState": "Microsoft.Edge.ProvisioningState",
    "com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties": "Microsoft.Edge.ReconciliationPolicyProperties",
    "com.azure.resourcemanager.workloadorchestration.models.ReconciliationState": "Microsoft.Edge.ReconciliationState",
    "com.azure.resourcemanager.workloadorchestration.models.RemoveRevisionParameter": "Microsoft.Edge.RemoveRevisionParameter",
    "com.azure.resourcemanager.workloadorchestration.models.ResourceState": "Microsoft.Edge.ResourceState",
    "com.azure.resourcemanager.workloadorchestration.models.SchemaProperties": "Microsoft.Edge.SchemaProperties",
    "com.azure.resourcemanager.workloadorchestration.models.SchemaReferenceProperties": "Microsoft.Edge.SchemaReferenceProperties",
    "com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties": "Microsoft.Edge.SchemaVersionProperties",
    "com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties": "Microsoft.Edge.SiteReferenceProperties",
    "com.azure.resourcemanager.workloadorchestration.models.SolutionDependency": "Microsoft.Edge.SolutionDependency",
    "com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter": "Microsoft.Edge.SolutionDependencyParameter",
    "com.azure.resourcemanager.workloadorchestration.models.SolutionProperties": "Microsoft.Edge.SolutionProperties",
    "com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter": "Microsoft.Edge.SolutionTemplateParameter",
    "com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties": "Microsoft.Edge.SolutionTemplateProperties",
    "com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties": "Microsoft.Edge.SolutionTemplateVersionProperties",
    "com.azure.resourcemanager.workloadorchestration.models.SolutionVersionParameter": "Microsoft.Edge.SolutionVersionParameter",
    "com.azure.resourcemanager.workloadorchestration.models.SolutionVersionProperties": "Microsoft.Edge.SolutionVersionProperties",
    "com.azure.resourcemanager.workloadorchestration.models.SolutionVersionSnapshot": "Microsoft.Edge.SolutionVersionSnapshot",
    "com.azure.resourcemanager.workloadorchestration.models.StageSpec": "Microsoft.Edge.StageSpec",
    "com.azure.resourcemanager.workloadorchestration.models.StageStatus": "Microsoft.Edge.StageStatus",
    "com.azure.resourcemanager.workloadorchestration.models.State": "Microsoft.Edge.State",
    "com.azure.resourcemanager.workloadorchestration.models.TargetProperties": "Microsoft.Edge.TargetProperties",
    "com.azure.resourcemanager.workloadorchestration.models.TargetSnapshot": "Microsoft.Edge.TargetSnapshot",
    "com.azure.resourcemanager.workloadorchestration.models.TargetStatus": "Microsoft.Edge.TargetStatus",
    "com.azure.resourcemanager.workloadorchestration.models.TaskOption": "Microsoft.Edge.TaskOption",
    "com.azure.resourcemanager.workloadorchestration.models.TaskSpec": "Microsoft.Edge.TaskSpec",
    "com.azure.resourcemanager.workloadorchestration.models.UninstallSolutionParameter": "Microsoft.Edge.UninstallSolutionParameter",
    "com.azure.resourcemanager.workloadorchestration.models.UpdateExternalValidationStatusParameter": "Microsoft.Edge.UpdateExternalValidationStatusParameter",
    "com.azure.resourcemanager.workloadorchestration.models.UpdateType": "Microsoft.Edge.UpdateType",
    "com.azure.resourcemanager.workloadorchestration.models.ValidationStatus": "Microsoft.Edge.ValidationStatus",
    "com.azure.resourcemanager.workloadorchestration.models.VersionParameter": "Microsoft.Edge.VersionParameter",
    "com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties": "Microsoft.Edge.WorkflowProperties",
    "com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties": "Microsoft.Edge.WorkflowVersionProperties"
  }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/main/resources/META-INF/azure-resourcemanager-workloadorchestration_metadata.json
================================================
{"flavor":"azure","apiVersion":"2025-06-01","crossLanguageDefinitions":{"com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient":"Microsoft.Edge.ConfigTemplateVersions","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient.get":"Microsoft.Edge.ConfigTemplateVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient.getWithResponse":"Microsoft.Edge.ConfigTemplateVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplateVersionsClient.listByConfigTemplate":"Microsoft.Edge.ConfigTemplateVersions.listByConfigTemplate","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient":"Microsoft.Edge.ConfigTemplates","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.beginCreateOrUpdate":"Microsoft.Edge.ConfigTemplates.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.beginCreateVersion":"Microsoft.Edge.ConfigTemplates.createVersion","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.beginDelete":"Microsoft.Edge.ConfigTemplates.delete","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.createOrUpdate":"Microsoft.Edge.ConfigTemplates.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.createVersion":"Microsoft.Edge.ConfigTemplates.createVersion","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.delete":"Microsoft.Edge.ConfigTemplates.delete","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.getByResourceGroup":"Microsoft.Edge.ConfigTemplates.get","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.getByResourceGroupWithResponse":"Microsoft.Edge.ConfigTemplates.get","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.list":"Microsoft.Edge.ConfigTemplates.listBySubscription","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.listByResourceGroup":"Microsoft.Edge.ConfigTemplates.listByResourceGroup","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.removeVersion":"Microsoft.Edge.ConfigTemplates.removeVersion","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.removeVersionWithResponse":"Microsoft.Edge.ConfigTemplates.removeVersion","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.update":"Microsoft.Edge.ConfigTemplates.update","com.azure.resourcemanager.workloadorchestration.fluent.ConfigTemplatesClient.updateWithResponse":"Microsoft.Edge.ConfigTemplates.update","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient":"Microsoft.Edge.Contexts","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.beginCreateOrUpdate":"Microsoft.Edge.Contexts.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.beginDelete":"Microsoft.Edge.Contexts.delete","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.beginUpdate":"Microsoft.Edge.Contexts.update","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.createOrUpdate":"Microsoft.Edge.Contexts.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.delete":"Microsoft.Edge.Contexts.delete","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.getByResourceGroup":"Microsoft.Edge.Contexts.get","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.getByResourceGroupWithResponse":"Microsoft.Edge.Contexts.get","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.list":"Microsoft.Edge.Contexts.listBySubscription","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.listByResourceGroup":"Microsoft.Edge.Contexts.listByResourceGroup","com.azure.resourcemanager.workloadorchestration.fluent.ContextsClient.update":"Microsoft.Edge.Contexts.update","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient":"Microsoft.Edge.Diagnostics","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.beginCreateOrUpdate":"Microsoft.Edge.Diagnostics.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.beginDelete":"Microsoft.Edge.Diagnostics.delete","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.beginUpdate":"Microsoft.Edge.Diagnostics.update","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.createOrUpdate":"Microsoft.Edge.Diagnostics.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.delete":"Microsoft.Edge.Diagnostics.delete","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.getByResourceGroup":"Microsoft.Edge.Diagnostics.get","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.getByResourceGroupWithResponse":"Microsoft.Edge.Diagnostics.get","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.list":"Microsoft.Edge.Diagnostics.listBySubscription","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.listByResourceGroup":"Microsoft.Edge.Diagnostics.listByResourceGroup","com.azure.resourcemanager.workloadorchestration.fluent.DiagnosticsClient.update":"Microsoft.Edge.Diagnostics.update","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient":"Microsoft.Edge.DynamicSchemaVersions","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.beginCreateOrUpdate":"Microsoft.Edge.DynamicSchemaVersions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.beginDelete":"Microsoft.Edge.DynamicSchemaVersions.delete","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.createOrUpdate":"Microsoft.Edge.DynamicSchemaVersions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.delete":"Microsoft.Edge.DynamicSchemaVersions.delete","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.get":"Microsoft.Edge.DynamicSchemaVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.getWithResponse":"Microsoft.Edge.DynamicSchemaVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.listByDynamicSchema":"Microsoft.Edge.DynamicSchemaVersions.listByDynamicSchema","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.update":"Microsoft.Edge.DynamicSchemaVersions.update","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemaVersionsClient.updateWithResponse":"Microsoft.Edge.DynamicSchemaVersions.update","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient":"Microsoft.Edge.DynamicSchemas","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.beginCreateOrUpdate":"Microsoft.Edge.DynamicSchemas.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.beginDelete":"Microsoft.Edge.DynamicSchemas.delete","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.createOrUpdate":"Microsoft.Edge.DynamicSchemas.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.delete":"Microsoft.Edge.DynamicSchemas.delete","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.get":"Microsoft.Edge.DynamicSchemas.get","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.getWithResponse":"Microsoft.Edge.DynamicSchemas.get","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.listBySchema":"Microsoft.Edge.DynamicSchemas.listBySchema","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.update":"Microsoft.Edge.DynamicSchemas.update","com.azure.resourcemanager.workloadorchestration.fluent.DynamicSchemasClient.updateWithResponse":"Microsoft.Edge.DynamicSchemas.update","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient":"Microsoft.Edge.Executions","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.beginCreateOrUpdate":"Microsoft.Edge.Executions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.beginDelete":"Microsoft.Edge.Executions.delete","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.beginUpdate":"Microsoft.Edge.Executions.update","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.createOrUpdate":"Microsoft.Edge.Executions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.delete":"Microsoft.Edge.Executions.delete","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.get":"Microsoft.Edge.Executions.get","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.getWithResponse":"Microsoft.Edge.Executions.get","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.listByWorkflowVersion":"Microsoft.Edge.Executions.listByWorkflowVersion","com.azure.resourcemanager.workloadorchestration.fluent.ExecutionsClient.update":"Microsoft.Edge.Executions.update","com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient":"Microsoft.Edge.InstanceHistories","com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient.get":"Microsoft.Edge.InstanceHistories.get","com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient.getWithResponse":"Microsoft.Edge.InstanceHistories.get","com.azure.resourcemanager.workloadorchestration.fluent.InstanceHistoriesClient.listByInstance":"Microsoft.Edge.InstanceHistories.listByInstance","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient":"Microsoft.Edge.Instances","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.beginCreateOrUpdate":"Microsoft.Edge.Instances.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.beginDelete":"Microsoft.Edge.Instances.delete","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.beginUpdate":"Microsoft.Edge.Instances.update","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.createOrUpdate":"Microsoft.Edge.Instances.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.delete":"Microsoft.Edge.Instances.delete","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.get":"Microsoft.Edge.Instances.get","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.getWithResponse":"Microsoft.Edge.Instances.get","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.listBySolution":"Microsoft.Edge.Instances.listBySolution","com.azure.resourcemanager.workloadorchestration.fluent.InstancesClient.update":"Microsoft.Edge.Instances.update","com.azure.resourcemanager.workloadorchestration.fluent.JobsClient":"Microsoft.Edge.Jobs","com.azure.resourcemanager.workloadorchestration.fluent.JobsClient.get":"Microsoft.Edge.Jobs.get","com.azure.resourcemanager.workloadorchestration.fluent.JobsClient.getWithResponse":"Microsoft.Edge.Jobs.get","com.azure.resourcemanager.workloadorchestration.fluent.JobsClient.listByTarget":"Microsoft.Edge.Jobs.listByTarget","com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient":"Microsoft.Edge.SchemaReferences","com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient.get":"Microsoft.Edge.SchemaReferences.get","com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient.getWithResponse":"Microsoft.Edge.SchemaReferences.get","com.azure.resourcemanager.workloadorchestration.fluent.SchemaReferencesClient.listByResourceGroup":"Microsoft.Edge.SchemaReferences.listByResourceGroup","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient":"Microsoft.Edge.SchemaVersions","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.beginCreateOrUpdate":"Microsoft.Edge.SchemaVersions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.beginDelete":"Microsoft.Edge.SchemaVersions.delete","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.createOrUpdate":"Microsoft.Edge.SchemaVersions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.delete":"Microsoft.Edge.SchemaVersions.delete","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.get":"Microsoft.Edge.SchemaVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.getWithResponse":"Microsoft.Edge.SchemaVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.listBySchema":"Microsoft.Edge.SchemaVersions.listBySchema","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.update":"Microsoft.Edge.SchemaVersions.update","com.azure.resourcemanager.workloadorchestration.fluent.SchemaVersionsClient.updateWithResponse":"Microsoft.Edge.SchemaVersions.update","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient":"Microsoft.Edge.Schemas","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.beginCreateOrUpdate":"Microsoft.Edge.Schemas.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.beginCreateVersion":"Microsoft.Edge.Schemas.createVersion","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.beginDelete":"Microsoft.Edge.Schemas.delete","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.createOrUpdate":"Microsoft.Edge.Schemas.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.createVersion":"Microsoft.Edge.Schemas.createVersion","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.delete":"Microsoft.Edge.Schemas.delete","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.getByResourceGroup":"Microsoft.Edge.Schemas.get","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.getByResourceGroupWithResponse":"Microsoft.Edge.Schemas.get","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.list":"Microsoft.Edge.Schemas.listBySubscription","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.listByResourceGroup":"Microsoft.Edge.Schemas.listByResourceGroup","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.removeVersion":"Microsoft.Edge.Schemas.removeVersion","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.removeVersionWithResponse":"Microsoft.Edge.Schemas.removeVersion","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.update":"Microsoft.Edge.Schemas.update","com.azure.resourcemanager.workloadorchestration.fluent.SchemasClient.updateWithResponse":"Microsoft.Edge.Schemas.update","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient":"Microsoft.Edge.SiteReferences","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.beginCreateOrUpdate":"Microsoft.Edge.SiteReferences.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.beginDelete":"Microsoft.Edge.SiteReferences.delete","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.beginUpdate":"Microsoft.Edge.SiteReferences.update","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.createOrUpdate":"Microsoft.Edge.SiteReferences.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.delete":"Microsoft.Edge.SiteReferences.delete","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.get":"Microsoft.Edge.SiteReferences.get","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.getWithResponse":"Microsoft.Edge.SiteReferences.get","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.listByContext":"Microsoft.Edge.SiteReferences.listByContext","com.azure.resourcemanager.workloadorchestration.fluent.SiteReferencesClient.update":"Microsoft.Edge.SiteReferences.update","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient":"Microsoft.Edge.SolutionTemplateVersions","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.beginBulkDeploySolution":"Microsoft.Edge.SolutionTemplateVersions.bulkDeploySolution","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.beginBulkPublishSolution":"Microsoft.Edge.SolutionTemplateVersions.bulkPublishSolution","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.bulkDeploySolution":"Microsoft.Edge.SolutionTemplateVersions.bulkDeploySolution","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.bulkPublishSolution":"Microsoft.Edge.SolutionTemplateVersions.bulkPublishSolution","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.get":"Microsoft.Edge.SolutionTemplateVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.getWithResponse":"Microsoft.Edge.SolutionTemplateVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplateVersionsClient.listBySolutionTemplate":"Microsoft.Edge.SolutionTemplateVersions.listBySolutionTemplate","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient":"Microsoft.Edge.SolutionTemplates","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.beginCreateOrUpdate":"Microsoft.Edge.SolutionTemplates.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.beginCreateVersion":"Microsoft.Edge.SolutionTemplates.createVersion","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.beginDelete":"Microsoft.Edge.SolutionTemplates.delete","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.beginRemoveVersion":"Microsoft.Edge.SolutionTemplates.removeVersion","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.createOrUpdate":"Microsoft.Edge.SolutionTemplates.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.createVersion":"Microsoft.Edge.SolutionTemplates.createVersion","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.delete":"Microsoft.Edge.SolutionTemplates.delete","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.getByResourceGroup":"Microsoft.Edge.SolutionTemplates.get","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.getByResourceGroupWithResponse":"Microsoft.Edge.SolutionTemplates.get","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.list":"Microsoft.Edge.SolutionTemplates.listBySubscription","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.listByResourceGroup":"Microsoft.Edge.SolutionTemplates.listByResourceGroup","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.removeVersion":"Microsoft.Edge.SolutionTemplates.removeVersion","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.update":"Microsoft.Edge.SolutionTemplates.update","com.azure.resourcemanager.workloadorchestration.fluent.SolutionTemplatesClient.updateWithResponse":"Microsoft.Edge.SolutionTemplates.update","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient":"Microsoft.Edge.SolutionVersions","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.beginCreateOrUpdate":"Microsoft.Edge.SolutionVersions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.beginDelete":"Microsoft.Edge.SolutionVersions.delete","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.beginUpdate":"Microsoft.Edge.SolutionVersions.update","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.createOrUpdate":"Microsoft.Edge.SolutionVersions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.delete":"Microsoft.Edge.SolutionVersions.delete","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.get":"Microsoft.Edge.SolutionVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.getWithResponse":"Microsoft.Edge.SolutionVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.listBySolution":"Microsoft.Edge.SolutionVersions.listBySolution","com.azure.resourcemanager.workloadorchestration.fluent.SolutionVersionsClient.update":"Microsoft.Edge.SolutionVersions.update","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient":"Microsoft.Edge.Solutions","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.beginCreateOrUpdate":"Microsoft.Edge.Solutions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.beginDelete":"Microsoft.Edge.Solutions.delete","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.beginUpdate":"Microsoft.Edge.Solutions.update","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.createOrUpdate":"Microsoft.Edge.Solutions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.delete":"Microsoft.Edge.Solutions.delete","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.get":"Microsoft.Edge.Solutions.get","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.getWithResponse":"Microsoft.Edge.Solutions.get","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.listByTarget":"Microsoft.Edge.Solutions.listByTarget","com.azure.resourcemanager.workloadorchestration.fluent.SolutionsClient.update":"Microsoft.Edge.Solutions.update","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient":"Microsoft.Edge.Targets","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginCreateOrUpdate":"Microsoft.Edge.Targets.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginDelete":"Microsoft.Edge.Targets.delete","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginInstallSolution":"Microsoft.Edge.Targets.installSolution","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginPublishSolutionVersion":"Microsoft.Edge.Targets.publishSolutionVersion","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginRemoveRevision":"Microsoft.Edge.Targets.removeRevision","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginResolveConfiguration":"Microsoft.Edge.Targets.resolveConfiguration","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginReviewSolutionVersion":"Microsoft.Edge.Targets.reviewSolutionVersion","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginUninstallSolution":"Microsoft.Edge.Targets.uninstallSolution","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginUpdate":"Microsoft.Edge.Targets.update","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.beginUpdateExternalValidationStatus":"Microsoft.Edge.Targets.updateExternalValidationStatus","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.createOrUpdate":"Microsoft.Edge.Targets.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.delete":"Microsoft.Edge.Targets.delete","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.getByResourceGroup":"Microsoft.Edge.Targets.get","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.getByResourceGroupWithResponse":"Microsoft.Edge.Targets.get","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.installSolution":"Microsoft.Edge.Targets.installSolution","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.list":"Microsoft.Edge.Targets.listBySubscription","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.listByResourceGroup":"Microsoft.Edge.Targets.listByResourceGroup","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.publishSolutionVersion":"Microsoft.Edge.Targets.publishSolutionVersion","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.removeRevision":"Microsoft.Edge.Targets.removeRevision","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.resolveConfiguration":"Microsoft.Edge.Targets.resolveConfiguration","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.reviewSolutionVersion":"Microsoft.Edge.Targets.reviewSolutionVersion","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.uninstallSolution":"Microsoft.Edge.Targets.uninstallSolution","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.update":"Microsoft.Edge.Targets.update","com.azure.resourcemanager.workloadorchestration.fluent.TargetsClient.updateExternalValidationStatus":"Microsoft.Edge.Targets.updateExternalValidationStatus","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient":"Microsoft.Edge.WorkflowVersions","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.beginCreateOrUpdate":"Microsoft.Edge.WorkflowVersions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.beginDelete":"Microsoft.Edge.WorkflowVersions.delete","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.beginUpdate":"Microsoft.Edge.WorkflowVersions.update","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.createOrUpdate":"Microsoft.Edge.WorkflowVersions.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.delete":"Microsoft.Edge.WorkflowVersions.delete","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.get":"Microsoft.Edge.WorkflowVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.getWithResponse":"Microsoft.Edge.WorkflowVersions.get","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.listByWorkflow":"Microsoft.Edge.WorkflowVersions.listByWorkflow","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowVersionsClient.update":"Microsoft.Edge.WorkflowVersions.update","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient":"Microsoft.Edge.Workflows","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.beginCreateOrUpdate":"Microsoft.Edge.Workflows.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.beginDelete":"Microsoft.Edge.Workflows.delete","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.beginUpdate":"Microsoft.Edge.Workflows.update","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.createOrUpdate":"Microsoft.Edge.Workflows.createOrUpdate","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.delete":"Microsoft.Edge.Workflows.delete","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.get":"Microsoft.Edge.Workflows.get","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.getWithResponse":"Microsoft.Edge.Workflows.get","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.listByContext":"Microsoft.Edge.Workflows.listByContext","com.azure.resourcemanager.workloadorchestration.fluent.WorkflowsClient.update":"Microsoft.Edge.Workflows.update","com.azure.resourcemanager.workloadorchestration.fluent.WorkloadOrchestrationManagementClient":"Microsoft.Edge","com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner":"Microsoft.Edge.ConfigTemplate","com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner":"Microsoft.Edge.ConfigTemplateVersion","com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner":"Microsoft.Edge.ConfigTemplateVersionWithUpdateType","com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner":"Microsoft.Edge.Context","com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner":"Microsoft.Edge.Diagnostic","com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner":"Microsoft.Edge.DynamicSchema","com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner":"Microsoft.Edge.DynamicSchemaVersion","com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner":"Microsoft.Edge.Execution","com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner":"Microsoft.Edge.InstanceHistory","com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner":"Microsoft.Edge.Instance","com.azure.resourcemanager.workloadorchestration.fluent.models.JobInner":"Microsoft.Edge.Job","com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner":"Microsoft.Edge.RemoveVersionResponse","com.azure.resourcemanager.workloadorchestration.fluent.models.ResolvedConfigurationInner":"Microsoft.Edge.ResolvedConfiguration","com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner":"Microsoft.Edge.Schema","com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner":"Microsoft.Edge.SchemaReference","com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner":"Microsoft.Edge.SchemaVersion","com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner":"Microsoft.Edge.SchemaVersionWithUpdateType","com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner":"Microsoft.Edge.SiteReference","com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner":"Microsoft.Edge.Solution","com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner":"Microsoft.Edge.SolutionTemplate","com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner":"Microsoft.Edge.SolutionTemplateVersion","com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner":"Microsoft.Edge.SolutionTemplateVersionWithUpdateType","com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionVersionInner":"Microsoft.Edge.SolutionVersion","com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner":"Microsoft.Edge.Target","com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner":"Microsoft.Edge.Workflow","com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner":"Microsoft.Edge.WorkflowVersion","com.azure.resourcemanager.workloadorchestration.implementation.WorkloadOrchestrationManagementClientBuilder":"Microsoft.Edge","com.azure.resourcemanager.workloadorchestration.implementation.models.ConfigTemplateListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.ConfigTemplateVersionListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.ContextListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.DiagnosticListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.DynamicSchemaListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.DynamicSchemaVersionListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.ExecutionListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.InstanceHistoryListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.InstanceListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.JobListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaReferenceListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaVersionListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.SiteReferenceListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionTemplateListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionTemplateVersionListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionVersionListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.TargetListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.WorkflowListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.implementation.models.WorkflowVersionListResult":"Azure.ResourceManager.ResourceListResult","com.azure.resourcemanager.workloadorchestration.models.ActiveState":"Microsoft.Edge.ActiveState","com.azure.resourcemanager.workloadorchestration.models.AvailableSolutionTemplateVersion":"Microsoft.Edge.AvailableSolutionTemplateVersion","com.azure.resourcemanager.workloadorchestration.models.BulkDeploySolutionParameter":"Microsoft.Edge.BulkDeploySolutionParameter","com.azure.resourcemanager.workloadorchestration.models.BulkDeployTargetDetails":"Microsoft.Edge.BulkDeployTargetDetails","com.azure.resourcemanager.workloadorchestration.models.BulkPublishSolutionParameter":"Microsoft.Edge.BulkPublishSolutionParameter","com.azure.resourcemanager.workloadorchestration.models.BulkPublishTargetDetails":"Microsoft.Edge.BulkPublishTargetDetails","com.azure.resourcemanager.workloadorchestration.models.Capability":"Microsoft.Edge.Capability","com.azure.resourcemanager.workloadorchestration.models.ComponentStatus":"Microsoft.Edge.ComponentStatus","com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties":"Microsoft.Edge.ConfigTemplateProperties","com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties":"Microsoft.Edge.ConfigTemplateVersionProperties","com.azure.resourcemanager.workloadorchestration.models.ConfigurationModel":"Microsoft.Edge.ConfigurationModel","com.azure.resourcemanager.workloadorchestration.models.ConfigurationType":"Microsoft.Edge.ConfigurationType","com.azure.resourcemanager.workloadorchestration.models.ContextProperties":"Microsoft.Edge.ContextProperties","com.azure.resourcemanager.workloadorchestration.models.DeployJobParameter":"Microsoft.Edge.DeployJobParameter","com.azure.resourcemanager.workloadorchestration.models.DeployJobStepStatistics":"Microsoft.Edge.DeployJobStepStatistics","com.azure.resourcemanager.workloadorchestration.models.DeploymentStatus":"Microsoft.Edge.DeploymentStatus","com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties":"Microsoft.Edge.DiagnosticProperties","com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties":"Microsoft.Edge.DynamicSchemaProperties","com.azure.resourcemanager.workloadorchestration.models.ErrorAction":"Microsoft.Edge.ErrorAction","com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode":"Microsoft.Edge.ErrorActionMode","com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties":"Microsoft.Edge.ExecutionProperties","com.azure.resourcemanager.workloadorchestration.models.ExecutionStatus":"Microsoft.Edge.ExecutionStatus","com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation":"Azure.ResourceManager.CommonTypes.ExtendedLocation","com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType":"Azure.ResourceManager.CommonTypes.ExtendedLocationType","com.azure.resourcemanager.workloadorchestration.models.Hierarchy":"Microsoft.Edge.Hierarchy","com.azure.resourcemanager.workloadorchestration.models.InstallSolutionParameter":"Microsoft.Edge.InstallSolutionParameter","com.azure.resourcemanager.workloadorchestration.models.InstanceHistoryProperties":"Microsoft.Edge.InstanceHistoryProperties","com.azure.resourcemanager.workloadorchestration.models.InstanceProperties":"Microsoft.Edge.InstanceProperties","com.azure.resourcemanager.workloadorchestration.models.JobParameterBase":"Microsoft.Edge.JobParameterBase","com.azure.resourcemanager.workloadorchestration.models.JobProperties":"Microsoft.Edge.JobProperties","com.azure.resourcemanager.workloadorchestration.models.JobStatus":"Microsoft.Edge.JobStatus","com.azure.resourcemanager.workloadorchestration.models.JobStep":"Microsoft.Edge.JobStep","com.azure.resourcemanager.workloadorchestration.models.JobStepStatisticsBase":"Microsoft.Edge.JobStepStatisticsBase","com.azure.resourcemanager.workloadorchestration.models.JobType":"Microsoft.Edge.JobType","com.azure.resourcemanager.workloadorchestration.models.OrchestratorType":"Microsoft.Edge.OrchestratorType","com.azure.resourcemanager.workloadorchestration.models.ProvisioningState":"Microsoft.Edge.ProvisioningState","com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties":"Microsoft.Edge.ReconciliationPolicyProperties","com.azure.resourcemanager.workloadorchestration.models.ReconciliationState":"Microsoft.Edge.ReconciliationState","com.azure.resourcemanager.workloadorchestration.models.RemoveRevisionParameter":"Microsoft.Edge.RemoveRevisionParameter","com.azure.resourcemanager.workloadorchestration.models.ResourceState":"Microsoft.Edge.ResourceState","com.azure.resourcemanager.workloadorchestration.models.SchemaProperties":"Microsoft.Edge.SchemaProperties","com.azure.resourcemanager.workloadorchestration.models.SchemaReferenceProperties":"Microsoft.Edge.SchemaReferenceProperties","com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties":"Microsoft.Edge.SchemaVersionProperties","com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties":"Microsoft.Edge.SiteReferenceProperties","com.azure.resourcemanager.workloadorchestration.models.SolutionDependency":"Microsoft.Edge.SolutionDependency","com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter":"Microsoft.Edge.SolutionDependencyParameter","com.azure.resourcemanager.workloadorchestration.models.SolutionProperties":"Microsoft.Edge.SolutionProperties","com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter":"Microsoft.Edge.SolutionTemplateParameter","com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties":"Microsoft.Edge.SolutionTemplateProperties","com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties":"Microsoft.Edge.SolutionTemplateVersionProperties","com.azure.resourcemanager.workloadorchestration.models.SolutionVersionParameter":"Microsoft.Edge.SolutionVersionParameter","com.azure.resourcemanager.workloadorchestration.models.SolutionVersionProperties":"Microsoft.Edge.SolutionVersionProperties","com.azure.resourcemanager.workloadorchestration.models.SolutionVersionSnapshot":"Microsoft.Edge.SolutionVersionSnapshot","com.azure.resourcemanager.workloadorchestration.models.StageSpec":"Microsoft.Edge.StageSpec","com.azure.resourcemanager.workloadorchestration.models.StageStatus":"Microsoft.Edge.StageStatus","com.azure.resourcemanager.workloadorchestration.models.State":"Microsoft.Edge.State","com.azure.resourcemanager.workloadorchestration.models.TargetProperties":"Microsoft.Edge.TargetProperties","com.azure.resourcemanager.workloadorchestration.models.TargetSnapshot":"Microsoft.Edge.TargetSnapshot","com.azure.resourcemanager.workloadorchestration.models.TargetStatus":"Microsoft.Edge.TargetStatus","com.azure.resourcemanager.workloadorchestration.models.TaskOption":"Microsoft.Edge.TaskOption","com.azure.resourcemanager.workloadorchestration.models.TaskSpec":"Microsoft.Edge.TaskSpec","com.azure.resourcemanager.workloadorchestration.models.UninstallSolutionParameter":"Microsoft.Edge.UninstallSolutionParameter","com.azure.resourcemanager.workloadorchestration.models.UpdateExternalValidationStatusParameter":"Microsoft.Edge.UpdateExternalValidationStatusParameter","com.azure.resourcemanager.workloadorchestration.models.UpdateType":"Microsoft.Edge.UpdateType","com.azure.resourcemanager.workloadorchestration.models.ValidationStatus":"Microsoft.Edge.ValidationStatus","com.azure.resourcemanager.workloadorchestration.models.VersionParameter":"Microsoft.Edge.VersionParameter","com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties":"Microsoft.Edge.WorkflowProperties","com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties":"Microsoft.Edge.WorkflowVersionProperties"}}


================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for ConfigTemplates CreateOrUpdate.
 */
public final class ConfigTemplatesCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates()
            .define("testname")
            .withRegion("egqjo")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key6936", "fakeTokenPlaceholder"))
            .withProperties(new ConfigTemplateProperties().withDescription("ccdyggozwmhyvemlcwlsnhijwg"))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesCreateVersionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;

/**
 * Samples for ConfigTemplates CreateVersion.
 */
public final class ConfigTemplatesCreateVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_CreateVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_CreateVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesCreateVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates()
            .createVersion("rgconfigurationmanager", "testname",
                new ConfigTemplateVersionWithUpdateTypeInner().withUpdateType(UpdateType.MAJOR)
                    .withVersion("1.0.0")
                    .withConfigTemplateVersion(new ConfigTemplateVersionInner()
                        .withProperties(new ConfigTemplateVersionProperties().withConfigurations("rgricnhvcbqykc"))),
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for ConfigTemplates Delete.
 */
public final class ConfigTemplatesDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesGetByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for ConfigTemplates GetByResourceGroup.
 */
public final class ConfigTemplatesGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesListByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for ConfigTemplates ListByResourceGroup.
 */
public final class ConfigTemplatesListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesListSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for ConfigTemplates List.
 */
public final class ConfigTemplatesListSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates().list(com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesRemoveVersionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

/**
 * Samples for ConfigTemplates RemoveVersion.
 */
public final class ConfigTemplatesRemoveVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_RemoveVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_RemoveVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesRemoveVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplates()
            .removeVersionWithResponse("rgconfigurationmanager", "testname",
                new VersionParameter().withVersion("ghtvdzgmzncaifrnuumg"), com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplate;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for ConfigTemplates Update.
 */
public final class ConfigTemplatesUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplates_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplates_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplatesUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        ConfigTemplate resource = manager.configTemplates()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key7701", "fakeTokenPlaceholder"))
            .withProperties(new ConfigTemplateProperties().withDescription("cavjiqnrbzsvedicrixhwnfj"))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplateVersionsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for ConfigTemplateVersions Get.
 */
public final class ConfigTemplateVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/ConfigTemplateVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: ConfigTemplateVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void configTemplateVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.configTemplateVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.Capability;
import com.azure.resourcemanager.workloadorchestration.models.ContextProperties;
import com.azure.resourcemanager.workloadorchestration.models.Hierarchy;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Contexts CreateOrUpdate.
 */
public final class ContextsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void contextsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts()
            .define("testname")
            .withRegion("pkquwbplcp")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key3046", "fakeTokenPlaceholder"))
            .withProperties(new ContextProperties()
                .withCapabilities(Arrays.asList(new Capability().withName("tpylinjcmlnycfpofpxjtqmt")
                    .withDescription("banbenutsngwytoqh")
                    .withState(ResourceState.ACTIVE)))
                .withHierarchies(Arrays.asList(new Hierarchy().withName("upqe").withDescription("vg"))))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Contexts Delete.
 */
public final class ContextsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        contextsDeleteMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsGetByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Contexts GetByResourceGroup.
 */
public final class ContextsGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        contextsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsListByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Contexts ListByResourceGroup.
 */
public final class ContextsListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void contextsListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsListSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Contexts List.
 */
public final class ContextsListSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void contextsListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.contexts().list(com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.Capability;
import com.azure.resourcemanager.workloadorchestration.models.ContextModel;
import com.azure.resourcemanager.workloadorchestration.models.ContextProperties;
import com.azure.resourcemanager.workloadorchestration.models.Hierarchy;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Contexts Update.
 */
public final class ContextsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Contexts_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Contexts_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        contextsUpdateMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        ContextModel resource = manager.contexts()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key9545", "fakeTokenPlaceholder"))
            .withProperties(new ContextProperties()
                .withCapabilities(Arrays.asList(new Capability().withName("tpylinjcmlnycfpofpxjtqmt")
                    .withDescription("banbenutsngwytoqh")
                    .withState(ResourceState.ACTIVE)))
                .withHierarchies(Arrays.asList(new Hierarchy().withName("upqe").withDescription("vg"))))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Diagnostics CreateOrUpdate.
 */
public final class DiagnosticsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics()
            .define("testname")
            .withRegion("ouwfvnokjvivmjzqpupwrbsmls")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key4304", "fakeTokenPlaceholder"))
            .withProperties(new DiagnosticProperties())
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Diagnostics Delete.
 */
public final class DiagnosticsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticsGetByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Diagnostics GetByResourceGroup.
 */
public final class DiagnosticsGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        diagnosticsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticsListByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Diagnostics ListByResourceGroup.
 */
public final class DiagnosticsListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticsListSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Diagnostics List.
 */
public final class DiagnosticsListSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.diagnostics().list(com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.Diagnostic;
import com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Diagnostics Update.
 */
public final class DiagnosticsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Diagnostics_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Diagnostics_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void diagnosticsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Diagnostic resource = manager.diagnostics()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key1922", "fakeTokenPlaceholder"))
            .withProperties(new DiagnosticProperties())
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemasCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties;

/**
 * Samples for DynamicSchemas CreateOrUpdate.
 */
public final class DynamicSchemasCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemas()
            .define("testname")
            .withExistingSchema("rgconfigurationmanager", "testname")
            .withProperties(new DynamicSchemaProperties())
            .create();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemasDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for DynamicSchemas Delete.
 */
public final class DynamicSchemasDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemas()
            .delete("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemasGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for DynamicSchemas Get.
 */
public final class DynamicSchemasGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemas()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemasListBySchemaSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for DynamicSchemas ListBySchema.
 */
public final class DynamicSchemasListBySchemaSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_ListBySchema_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_ListBySchema_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasListBySchemaMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemas().listBySchema("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemasUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.DynamicSchema;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties;

/**
 * Samples for DynamicSchemas Update.
 */
public final class DynamicSchemasUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemas_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemas_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemasUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        DynamicSchema resource = manager.dynamicSchemas()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new DynamicSchemaProperties()).apply();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaVersionsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

/**
 * Samples for DynamicSchemaVersions CreateOrUpdate.
 */
public final class DynamicSchemaVersionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemaVersions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemaVersions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemaVersionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemaVersions()
            .define("1.0.0")
            .withExistingDynamicSchema("rgconfigurationmanager", "testname", "testname")
            .withProperties(new SchemaVersionProperties().withValue("uiaqdwsi"))
            .create();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaVersionsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for DynamicSchemaVersions Delete.
 */
public final class DynamicSchemaVersionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemaVersions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemaVersions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemaVersionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemaVersions()
            .delete("rgconfigurationmanager", "testname", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaVersionsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for DynamicSchemaVersions Get.
 */
public final class DynamicSchemaVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemaVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemaVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemaVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.dynamicSchemaVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "1.0.0",
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaVersionsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

/**
 * Samples for DynamicSchemaVersions Update.
 */
public final class DynamicSchemaVersionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/DynamicSchemaVersions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: DynamicSchemaVersions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void dynamicSchemaVersionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        DynamicSchemaVersion resource = manager.dynamicSchemaVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "1.0.0",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SchemaVersionProperties().withValue("muezi")).apply();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Executions CreateOrUpdate.
 */
public final class ExecutionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_CreateOrUpdate_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsCreateOrUpdateMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.executions()
            .define("abcde")
            .withExistingVersion("rgconfigurationmanager", "abcde", "abcde", "abcde")
            .withProperties(
                new ExecutionProperties().withWorkflowVersionId("souenlqwltljsojdcbpc").withSpecification(mapOf()))
            .withExtendedLocation(new ExtendedLocation().withName("ugf").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Executions Delete.
 */
public final class ExecutionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_Delete_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsDeleteMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.executions()
            .delete("rgconfigurationmanager", "abcde", "abcde", "abcde", "abcde", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Executions Get.
 */
public final class ExecutionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_Get_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsGetMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.executions()
            .getWithResponse("rgconfigurationmanager", "abcde", "abcde", "abcde", "abcde",
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionsListByWorkflowVersionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Executions ListByWorkflowVersion.
 */
public final class ExecutionsListByWorkflowVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_ListByWorkflowVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_ListByWorkflowVersion_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsListByWorkflowVersionMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.executions()
            .listByWorkflowVersion("rgconfigurationmanager", "abcde", "abcde", "abcde",
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.Execution;
import com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Executions Update.
 */
public final class ExecutionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Executions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Executions_Update_MaximumSet - generated by [MaximumSet] rule.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void executionsUpdateMaximumSetGeneratedByMaximumSetRule(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Execution resource = manager.executions()
            .getWithResponse("rgconfigurationmanager", "abcde", "abcde", "abcde", "abcde",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withProperties(
                new ExecutionProperties().withWorkflowVersionId("xjsxzbfltzvbuvn").withSpecification(mapOf()))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/InstanceHistoriesGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for InstanceHistories Get.
 */
public final class InstanceHistoriesGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/InstanceHistories_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: InstanceHistories_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instanceHistoriesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instanceHistories()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/InstanceHistoriesListByInstanceSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for InstanceHistories ListByInstance.
 */
public final class InstanceHistoriesListByInstanceSamples {
    /*
     * x-ms-original-file: 2025-06-01/InstanceHistories_ListByInstance_MaximumSet_Gen.json
     */
    /**
     * Sample code: InstanceHistories_ListByInstance_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instanceHistoriesListByInstanceMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instanceHistories()
            .listByInstance("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/InstancesCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.InstanceProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;

/**
 * Samples for Instances CreateOrUpdate.
 */
public final class InstancesCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instancesCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instances()
            .define("testname")
            .withExistingSolution("rgconfigurationmanager", "testname", "testname")
            .withProperties(new InstanceProperties().withSolutionVersionId("acpddbkfclsgxg")
                .withTargetId("eguutiftuxrsavvckjrv")
                .withActiveState(ActiveState.ACTIVE)
                .withReconciliationPolicy(new ReconciliationPolicyProperties().withState(ReconciliationState.INACTIVE)
                    .withInterval("szucgzdbydcowvhprhx"))
                .withSolutionScope("testname"))
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/InstancesDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Instances Delete.
 */
public final class InstancesDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instancesDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instances()
            .delete("rgconfigurationmanager", "testname", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/InstancesGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Instances Get.
 */
public final class InstancesGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        instancesGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instances()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/InstancesListBySolutionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Instances ListBySolution.
 */
public final class InstancesListBySolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_ListBySolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_ListBySolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instancesListBySolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.instances()
            .listBySolution("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/InstancesUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.Instance;
import com.azure.resourcemanager.workloadorchestration.models.InstanceProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;

/**
 * Samples for Instances Update.
 */
public final class InstancesUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Instances_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Instances_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void instancesUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Instance resource = manager.instances()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withProperties(new InstanceProperties().withSolutionVersionId("vrpzlamkvanqibtjarpxit")
                .withTargetId("tqkdvc")
                .withActiveState(ActiveState.ACTIVE)
                .withReconciliationPolicy(new ReconciliationPolicyProperties().withState(ReconciliationState.INACTIVE)
                    .withInterval("cmzlrjwnlshnkgv"))
                .withSolutionScope("testname"))
            .apply();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/JobsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Jobs Get.
 */
public final class JobsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Jobs_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Jobs_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        jobsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.jobs().getWithResponse("gt", "jobsName", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/JobsListByTargetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Jobs ListByTarget.
 */
public final class JobsListByTargetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Jobs_ListByTarget_MaximumSet_Gen.json
     */
    /**
     * Sample code: Jobs_ListByTarget_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void jobsListByTargetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.jobs().listByTarget("gt", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaReferencesGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SchemaReferences Get.
 */
public final class SchemaReferencesGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaReferences_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaReferences_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaReferencesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaReferences().getWithResponse("jdvtghygpz", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaReferencesListByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SchemaReferences ListByResourceGroup.
 */
public final class SchemaReferencesListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaReferences_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaReferences_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaReferencesListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaReferences().listByResourceGroup("jdvtghygpz", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SchemaProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Schemas CreateOrUpdate.
 */
public final class SchemasCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas()
            .define("testname")
            .withRegion("alvi")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key7017", "fakeTokenPlaceholder"))
            .withProperties(new SchemaProperties())
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasCreateVersionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;

/**
 * Samples for Schemas CreateVersion.
 */
public final class SchemasCreateVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_CreateVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_CreateVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasCreateVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas()
            .createVersion("rgconfigurationmanager", "testname",
                new SchemaVersionWithUpdateTypeInner().withUpdateType(UpdateType.MAJOR)
                    .withVersion("1.0.0")
                    .withSchemaVersion(
                        new SchemaVersionInner().withProperties(new SchemaVersionProperties().withValue("uiaqdwsi"))),
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Schemas Delete.
 */
public final class SchemasDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        schemasDeleteMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasGetByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Schemas GetByResourceGroup.
 */
public final class SchemasGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        schemasGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasListByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Schemas ListByResourceGroup.
 */
public final class SchemasListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasListSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Schemas List.
 */
public final class SchemasListSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas().list(com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasRemoveVersionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

/**
 * Samples for Schemas RemoveVersion.
 */
public final class SchemasRemoveVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_RemoveVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_RemoveVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemasRemoveVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemas()
            .removeVersionWithResponse("rgconfigurationmanager", "testname",
                new VersionParameter().withVersion("ghtvdzgmzncaifrnuumg"), com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.Schema;
import com.azure.resourcemanager.workloadorchestration.models.SchemaProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Schemas Update.
 */
public final class SchemasUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Schemas_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Schemas_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        schemasUpdateMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Schema resource = manager.schemas()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key6760", "fakeTokenPlaceholder"))
            .withProperties(new SchemaProperties())
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

/**
 * Samples for SchemaVersions CreateOrUpdate.
 */
public final class SchemaVersionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaVersions()
            .define("1.0.0")
            .withExistingSchema("rgconfigurationmanager", "testname")
            .withProperties(new SchemaVersionProperties().withValue("uiaqdwsi"))
            .create();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SchemaVersions Delete.
 */
public final class SchemaVersionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaVersions()
            .delete("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SchemaVersions Get.
 */
public final class SchemaVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionsListBySchemaSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SchemaVersions ListBySchema.
 */
public final class SchemaVersionsListBySchemaSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_ListBySchema_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_ListBySchema_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsListBySchemaMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.schemaVersions().listBySchema("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;

/**
 * Samples for SchemaVersions Update.
 */
public final class SchemaVersionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SchemaVersions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: SchemaVersions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void schemaVersionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        SchemaVersion resource = manager.schemaVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SchemaVersionProperties().withValue("muezi")).apply();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferencesCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties;

/**
 * Samples for SiteReferences CreateOrUpdate.
 */
public final class SiteReferencesCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.siteReferences()
            .define("testname")
            .withExistingContext("rgconfigurationmanager", "testname")
            .withProperties(new SiteReferenceProperties().withSiteId("xxjpxdcaumewwgpbwzkcrgrcw"))
            .create();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferencesDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SiteReferences Delete.
 */
public final class SiteReferencesDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.siteReferences()
            .delete("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferencesGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SiteReferences Get.
 */
public final class SiteReferencesGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.siteReferences()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferencesListByContextSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SiteReferences ListByContext.
 */
public final class SiteReferencesListByContextSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_ListByContext_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_ListByContext_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesListByContextMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.siteReferences().listByContext("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferencesUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SiteReference;
import com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties;

/**
 * Samples for SiteReferences Update.
 */
public final class SiteReferencesUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SiteReferences_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: SiteReferences_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void siteReferencesUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        SiteReference resource = manager.siteReferences()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SiteReferenceProperties().withSiteId("nwiuyaro")).apply();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionProperties;

/**
 * Samples for Solutions CreateOrUpdate.
 */
public final class SolutionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutions()
            .define("testname")
            .withExistingTarget("rgconfigurationmanager", "testname")
            .withProperties(new SolutionProperties())
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Solutions Delete.
 */
public final class SolutionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutions().delete("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Solutions Get.
 */
public final class SolutionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        solutionsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionsListByTargetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Solutions ListByTarget.
 */
public final class SolutionsListByTargetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_ListByTarget_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_ListByTarget_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionsListByTargetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutions().listByTarget("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.Solution;
import com.azure.resourcemanager.workloadorchestration.models.SolutionProperties;

/**
 * Samples for Solutions Update.
 */
public final class SolutionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Solutions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Solutions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Solution resource = manager.solutions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SolutionProperties()).apply();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionTemplates CreateOrUpdate.
 */
public final class SolutionTemplatesCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates()
            .define("testname")
            .withRegion("zheaaqvadewftnctxzpinrgeproqs")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key5091", "fakeTokenPlaceholder"))
            .withProperties(new SolutionTemplateProperties().withDescription("psrftehgzngcdlccivhjmwsmiz")
                .withCapabilities(Arrays.asList("dfoyxbbknrhvlunhmuyyt"))
                .withState(ResourceState.ACTIVE)
                .withEnableExternalValidation(true))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesCreateVersionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.OrchestratorType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionTemplates CreateVersion.
 */
public final class SolutionTemplatesCreateVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_CreateVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_CreateVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesCreateVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates()
            .createVersion("rgconfigurationmanager", "testname",
                new SolutionTemplateVersionWithUpdateTypeInner().withUpdateType(UpdateType.MAJOR)
                    .withVersion("1.0.0")
                    .withSolutionTemplateVersion(new SolutionTemplateVersionInner().withProperties(
                        new SolutionTemplateVersionProperties().withConfigurations("ofqcsavwmeuwmvtjnqpoybtjvkmrlh")
                            .withSpecification(mapOf())
                            .withOrchestratorType(OrchestratorType.TO))),
                com.azure.core.util.Context.NONE);
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SolutionTemplates Delete.
 */
public final class SolutionTemplatesDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates().delete("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesGetByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SolutionTemplates GetByResourceGroup.
 */
public final class SolutionTemplatesGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesListByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SolutionTemplates ListByResourceGroup.
 */
public final class SolutionTemplatesListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesListSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SolutionTemplates List.
 */
public final class SolutionTemplatesListSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates().list(com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesRemoveVersionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;

/**
 * Samples for SolutionTemplates RemoveVersion.
 */
public final class SolutionTemplatesRemoveVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_RemoveVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_RemoveVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesRemoveVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplates()
            .removeVersion("rgconfigurationmanager", "testname",
                new VersionParameter().withVersion("ghtvdzgmzncaifrnuumg"), com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplate;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionTemplates Update.
 */
public final class SolutionTemplatesUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplates_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplates_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplatesUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        SolutionTemplate resource = manager.solutionTemplates()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key8772", "fakeTokenPlaceholder"))
            .withProperties(new SolutionTemplateProperties().withDescription("onqlteg")
                .withCapabilities(Arrays.asList("relsv"))
                .withState(ResourceState.ACTIVE)
                .withEnableExternalValidation(true))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplateVersionsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SolutionTemplateVersions Get.
 */
public final class SolutionTemplateVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionTemplateVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionTemplateVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionTemplateVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionTemplateVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "1.0.0", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionVersionsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionVersions CreateOrUpdate.
 */
public final class SolutionVersionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionVersions()
            .define("testname")
            .withExistingSolution("rgconfigurationmanager", "testname", "testname")
            .withProperties(new SolutionVersionProperties().withSpecification(mapOf()))
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionVersionsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SolutionVersions Delete.
 */
public final class SolutionVersionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionVersions()
            .delete("rgconfigurationmanager", "testname", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionVersionsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SolutionVersions Get.
 */
public final class SolutionVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionVersionsListBySolutionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for SolutionVersions ListBySolution.
 */
public final class SolutionVersionsListBySolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_ListBySolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_ListBySolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsListBySolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.solutionVersions()
            .listBySolution("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionVersionsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SolutionVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for SolutionVersions Update.
 */
public final class SolutionVersionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/SolutionVersions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: SolutionVersions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void solutionVersionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        SolutionVersion resource = manager.solutionVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new SolutionVersionProperties().withSpecification(mapOf())).apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.TargetProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Targets CreateOrUpdate.
 */
public final class TargetsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .define("testname")
            .withRegion("kckloegmwsjgwtcl")
            .withExistingResourceGroup("rgconfigurationmanager")
            .withTags(mapOf("key612", "fakeTokenPlaceholder"))
            .withProperties(new TargetProperties().withDescription("riabrxtvhlmizyhffdpjeyhvw")
                .withDisplayName("qjlbshhqzfmwxvvynibkoi")
                .withContextId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                .withTargetSpecification(mapOf())
                .withCapabilities(Arrays.asList("grjapghdidoao"))
                .withHierarchyLevel("octqptfirejhjfavlnfqeiikqx")
                .withSolutionScope("testname")
                .withState(ResourceState.ACTIVE))
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Targets Delete.
 */
public final class TargetsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        targetsDeleteMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets().delete("rgconfigurationmanager", "testname", true, com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsGetByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Targets GetByResourceGroup.
 */
public final class TargetsGetByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        targetsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsInstallSolutionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.InstallSolutionParameter;

/**
 * Samples for Targets InstallSolution.
 */
public final class TargetsInstallSolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_InstallSolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_InstallSolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsInstallSolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .installSolution("rgconfigurationmanager", "testname", new InstallSolutionParameter().withSolutionVersionId(
                "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"),
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsListByResourceGroupSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Targets ListByResourceGroup.
 */
public final class TargetsListByResourceGroupSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_ListByResourceGroup_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_ListByResourceGroup_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsListByResourceGroupMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets().listByResourceGroup("rgconfigurationmanager", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsListSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Targets List.
 */
public final class TargetsListSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_ListBySubscription_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_ListBySubscription_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsListBySubscriptionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets().list(com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsPublishSolutionVersionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionParameter;

/**
 * Samples for Targets PublishSolutionVersion.
 */
public final class TargetsPublishSolutionVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_PublishSolutionVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_PublishSolutionVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsPublishSolutionVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .publishSolutionVersion("rgconfigurationmanager", "testname",
                new SolutionVersionParameter().withSolutionVersionId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"),
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsRemoveRevisionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.RemoveRevisionParameter;

/**
 * Samples for Targets RemoveRevision.
 */
public final class TargetsRemoveRevisionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_RemoveRevision_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_RemoveRevision_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsRemoveRevisionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .removeRevision("rgconfigurationmanager", "testname", new RemoveRevisionParameter().withSolutionTemplateId(
                "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                .withSolutionVersion("tomwmqybqomwkfaeukjneva"), com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsResolveConfigurationSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import java.util.Arrays;

/**
 * Samples for Targets ResolveConfiguration.
 */
public final class TargetsResolveConfigurationSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_ResolveConfiguration_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_ResolveConfiguration_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsResolveConfigurationMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .resolveConfiguration("rgconfigurationmanager", "testname",
                new SolutionTemplateParameter().withSolutionTemplateVersionId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}/{resourceType}/{resourceName}")
                    .withSolutionInstanceName("testname")
                    .withSolutionDependencies(
                        Arrays.asList(new SolutionDependencyParameter().withSolutionVersionId("cydzqntmjlqtksbavjwteru")
                            .withSolutionTemplateId("liqauthxnscodbiwktwfwrrsg")
                            .withSolutionTemplateVersion("gordjasyxxrj")
                            .withSolutionInstanceName("testname")
                            .withTargetId("steadvphxtyhjokqicrtg")
                            .withDependencies(Arrays.asList()))),
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsReviewSolutionVersionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import java.util.Arrays;

/**
 * Samples for Targets ReviewSolutionVersion.
 */
public final class TargetsReviewSolutionVersionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_ReviewSolutionVersion_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_ReviewSolutionVersion_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsReviewSolutionVersionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .reviewSolutionVersion("rgconfigurationmanager", "testname",
                new SolutionTemplateParameter().withSolutionTemplateVersionId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}/{resourceType}/{resourceName}")
                    .withSolutionInstanceName("testname")
                    .withSolutionDependencies(
                        Arrays.asList(new SolutionDependencyParameter().withSolutionVersionId("cydzqntmjlqtksbavjwteru")
                            .withSolutionTemplateId("liqauthxnscodbiwktwfwrrsg")
                            .withSolutionTemplateVersion("gordjasyxxrj")
                            .withSolutionInstanceName("testname")
                            .withTargetId("steadvphxtyhjokqicrtg")
                            .withDependencies(Arrays.asList()))),
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsUninstallSolutionSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.UninstallSolutionParameter;

/**
 * Samples for Targets UninstallSolution.
 */
public final class TargetsUninstallSolutionSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_UninstallSolution_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_UninstallSolution_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsUninstallSolutionMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .uninstallSolution("rgconfigurationmanager", "testname",
                new UninstallSolutionParameter().withSolutionTemplateId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                    .withSolutionInstanceName("lzihiumrcxbolmkqktvtuqyhg"),
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsUpdateExternalValidationStatusSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.management.exception.ManagementError;
import com.azure.resourcemanager.workloadorchestration.models.UpdateExternalValidationStatusParameter;
import com.azure.resourcemanager.workloadorchestration.models.ValidationStatus;

/**
 * Samples for Targets UpdateExternalValidationStatus.
 */
public final class TargetsUpdateExternalValidationStatusSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_UpdateExternalValidationStatus_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_UpdateExternalValidationStatus_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void targetsUpdateExternalValidationStatusMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.targets()
            .updateExternalValidationStatus("rgconfigurationmanager", "testname",
                new UpdateExternalValidationStatusParameter().withSolutionVersionId("shntcsuwlmpehmuqkrbf")
                    .withErrorDetails(new ManagementError())
                    .withExternalValidationId("ivsjzwy")
                    .withValidationStatus(ValidationStatus.VALID),
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.Target;
import com.azure.resourcemanager.workloadorchestration.models.TargetProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for Targets Update.
 */
public final class TargetsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Targets_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Targets_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        targetsUpdateMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Target resource = manager.targets()
            .getByResourceGroupWithResponse("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withTags(mapOf("key8026", "fakeTokenPlaceholder"))
            .withProperties(new TargetProperties().withDescription("yhnhdpznncdvncmnvoeohqjx")
                .withDisplayName("pguujtzjjvixgjitugybrefp")
                .withContextId(
                    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                .withTargetSpecification(mapOf())
                .withCapabilities(Arrays.asList("dasqhyxfakivfzqb"))
                .withHierarchyLevel("hfyntwxetgsmnucbjvvphtyxu")
                .withSolutionScope("testname")
                .withState(ResourceState.ACTIVE))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties;

/**
 * Samples for Workflows CreateOrUpdate.
 */
public final class WorkflowsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflows()
            .define("testname")
            .withExistingContext("rgconfigurationmanager", "testname")
            .withProperties(new WorkflowProperties())
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Workflows Delete.
 */
public final class WorkflowsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflows().delete("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Workflows Get.
 */
public final class WorkflowsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void
        workflowsGetMaximumSet(com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflows()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowsListByContextSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for Workflows ListByContext.
 */
public final class WorkflowsListByContextSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_ListByContext_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_ListByContext_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowsListByContextMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflows().listByContext("rgconfigurationmanager", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.Workflow;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties;

/**
 * Samples for Workflows Update.
 */
public final class WorkflowsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/Workflows_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: Workflows_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        Workflow resource = manager.workflows()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE)
            .getValue();
        resource.update().withProperties(new WorkflowProperties()).apply();
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionsCreateOrUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.StageSpec;
import com.azure.resourcemanager.workloadorchestration.models.TaskOption;
import com.azure.resourcemanager.workloadorchestration.models.TaskSpec;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for WorkflowVersions CreateOrUpdate.
 */
public final class WorkflowVersionsCreateOrUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_CreateOrUpdate_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_CreateOrUpdate_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsCreateOrUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflowVersions()
            .define("testname")
            .withExistingWorkflow("rgconfigurationmanager", "testname", "testname")
            .withProperties(new WorkflowVersionProperties().withStageSpec(Arrays.asList(new StageSpec()
                .withName("amrbjd")
                .withSpecification(mapOf())
                .withTasks(Arrays.asList(new TaskSpec().withName("xxmeyvmgydbcwxqwjhadjxjod")
                    .withTargetId(
                        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                    .withSpecification(mapOf())))
                .withTaskOption(
                    new TaskOption().withConcurrency(3)
                        .withErrorAction(new ErrorAction().withMode(ErrorActionMode.STOP_ON_ANY_FAILURE)
                            .withMaxToleratedFailures(0)))))
                .withSpecification(mapOf()))
            .withExtendedLocation(
                new ExtendedLocation().withName("szjrwimeqyiue").withType(ExtendedLocationType.EDGE_ZONE))
            .create();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionsDeleteSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for WorkflowVersions Delete.
 */
public final class WorkflowVersionsDeleteSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_Delete_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_Delete_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsDeleteMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflowVersions()
            .delete("rgconfigurationmanager", "testname", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionsGetSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for WorkflowVersions Get.
 */
public final class WorkflowVersionsGetSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_Get_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_Get_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsGetMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflowVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionsListByWorkflowSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

/**
 * Samples for WorkflowVersions ListByWorkflow.
 */
public final class WorkflowVersionsListByWorkflowSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_ListByWorkflow_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_ListByWorkflow_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsListByWorkflowMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        manager.workflowVersions()
            .listByWorkflow("rgconfigurationmanager", "testname", "testname", com.azure.core.util.Context.NONE);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/samples/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionsUpdateSamples.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode;
import com.azure.resourcemanager.workloadorchestration.models.StageSpec;
import com.azure.resourcemanager.workloadorchestration.models.TaskOption;
import com.azure.resourcemanager.workloadorchestration.models.TaskSpec;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersion;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Samples for WorkflowVersions Update.
 */
public final class WorkflowVersionsUpdateSamples {
    /*
     * x-ms-original-file: 2025-06-01/WorkflowVersions_Update_MaximumSet_Gen.json
     */
    /**
     * Sample code: WorkflowVersions_Update_MaximumSet.
     * 
     * @param manager Entry point to WorkloadOrchestrationManager.
     */
    public static void workflowVersionsUpdateMaximumSet(
        com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager manager) {
        WorkflowVersion resource = manager.workflowVersions()
            .getWithResponse("rgconfigurationmanager", "testname", "testname", "testname",
                com.azure.core.util.Context.NONE)
            .getValue();
        resource.update()
            .withProperties(new WorkflowVersionProperties().withStageSpec(Arrays.asList(new StageSpec()
                .withName("amrbjd")
                .withSpecification(mapOf())
                .withTasks(Arrays.asList(new TaskSpec().withName("xxmeyvmgydbcwxqwjhadjxjod")
                    .withTargetId(
                        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}")
                    .withSpecification(mapOf())))
                .withTaskOption(
                    new TaskOption().withConcurrency(3)
                        .withErrorAction(new ErrorAction().withMode(ErrorActionMode.STOP_ON_ANY_FAILURE)
                            .withMaxToleratedFailures(0)))))
                .withSpecification(mapOf()))
            .apply();
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/AvailableSolutionTemplateVersionTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.AvailableSolutionTemplateVersion;
import org.junit.jupiter.api.Assertions;

public final class AvailableSolutionTemplateVersionTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        AvailableSolutionTemplateVersion model = BinaryData
            .fromString(
                "{\"solutionTemplateVersion\":\"kl\",\"latestConfigRevision\":\"dxbjhwuaanozj\",\"isConfigured\":true}")
            .toObject(AvailableSolutionTemplateVersion.class);
        Assertions.assertEquals("kl", model.solutionTemplateVersion());
        Assertions.assertEquals("dxbjhwuaanozj", model.latestConfigRevision());
        Assertions.assertTrue(model.isConfigured());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/BulkDeploySolutionParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.BulkDeploySolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.BulkDeployTargetDetails;
import java.util.Arrays;
import org.junit.jupiter.api.Assertions;

public final class BulkDeploySolutionParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        BulkDeploySolutionParameter model = BinaryData.fromString(
            "{\"targets\":[{\"solutionVersionId\":\"aztz\"},{\"solutionVersionId\":\"ofncckwyfzqwhxxb\"},{\"solutionVersionId\":\"yq\"}]}")
            .toObject(BulkDeploySolutionParameter.class);
        Assertions.assertEquals("aztz", model.targets().get(0).solutionVersionId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        BulkDeploySolutionParameter model = new BulkDeploySolutionParameter()
            .withTargets(Arrays.asList(new BulkDeployTargetDetails().withSolutionVersionId("aztz"),
                new BulkDeployTargetDetails().withSolutionVersionId("ofncckwyfzqwhxxb"),
                new BulkDeployTargetDetails().withSolutionVersionId("yq")));
        model = BinaryData.fromObject(model).toObject(BulkDeploySolutionParameter.class);
        Assertions.assertEquals("aztz", model.targets().get(0).solutionVersionId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/BulkDeployTargetDetailsTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.BulkDeployTargetDetails;
import org.junit.jupiter.api.Assertions;

public final class BulkDeployTargetDetailsTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        BulkDeployTargetDetails model
            = BinaryData.fromString("{\"solutionVersionId\":\"xzfe\"}").toObject(BulkDeployTargetDetails.class);
        Assertions.assertEquals("xzfe", model.solutionVersionId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        BulkDeployTargetDetails model = new BulkDeployTargetDetails().withSolutionVersionId("xzfe");
        model = BinaryData.fromObject(model).toObject(BulkDeployTargetDetails.class);
        Assertions.assertEquals("xzfe", model.solutionVersionId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/BulkPublishSolutionParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.BulkPublishSolutionParameter;
import com.azure.resourcemanager.workloadorchestration.models.BulkPublishTargetDetails;
import com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter;
import java.util.Arrays;
import org.junit.jupiter.api.Assertions;

public final class BulkPublishSolutionParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        BulkPublishSolutionParameter model = BinaryData.fromString(
            "{\"targets\":[{\"targetId\":\"tpp\",\"solutionInstanceName\":\"o\"},{\"targetId\":\"xorjaltolmncwsob\",\"solutionInstanceName\":\"csdbnwdcfhuc\"},{\"targetId\":\"dpfuvg\",\"solutionInstanceName\":\"bjj\"},{\"targetId\":\"anvx\",\"solutionInstanceName\":\"t\"}],\"solutionInstanceName\":\"dut\",\"solutionDependencies\":[{\"solutionVersionId\":\"mr\",\"solutionTemplateId\":\"qtvcofudflvkgj\",\"solutionTemplateVersion\":\"gdknnqv\",\"solutionInstanceName\":\"znqntoru\",\"targetId\":\"gsahmkycgrauw\",\"dependencies\":[{\"solutionVersionId\":\"aeburuvdmo\",\"solutionTemplateId\":\"mz\",\"solutionTemplateVersion\":\"wabm\",\"solutionInstanceName\":\"efkifr\",\"targetId\":\"puqujmqlgkfbtn\",\"dependencies\":[{},{}]},{\"solutionVersionId\":\"n\",\"solutionTemplateId\":\"jcntuj\",\"solutionTemplateVersion\":\"c\",\"solutionInstanceName\":\"df\",\"targetId\":\"waezkojvd\",\"dependencies\":[{},{},{},{}]}]},{\"solutionVersionId\":\"oqouicybxarzgszu\",\"solutionTemplateId\":\"x\",\"solutionTemplateVersion\":\"q\",\"solutionInstanceName\":\"idoamciodhkha\",\"targetId\":\"khnzbonlw\",\"dependencies\":[{\"solutionVersionId\":\"gokdwbwhks\",\"solutionTemplateId\":\"cmrvexzt\",\"solutionTemplateVersion\":\"t\",\"solutionInstanceName\":\"sfraoyzko\",\"targetId\":\"tlmngu\",\"dependencies\":[{},{}]},{\"solutionVersionId\":\"aldsy\",\"solutionTemplateId\":\"ximerqfobwyznk\",\"solutionTemplateVersion\":\"kutwpf\",\"solutionInstanceName\":\"a\",\"targetId\":\"hrskdsnfd\",\"dependencies\":[{},{},{},{}]},{\"solutionVersionId\":\"kgtdlmkkze\",\"solutionTemplateId\":\"l\",\"solutionTemplateVersion\":\"wpusdsttwvogv\",\"solutionInstanceName\":\"ejdcngqqmoakuf\",\"targetId\":\"jzrwrdgrtw\",\"dependencies\":[{},{},{}]}]},{\"solutionVersionId\":\"uzkopbminrfd\",\"solutionTemplateId\":\"yuhhziu\",\"solutionTemplateVersion\":\"fozbhdmsmlmzqhof\",\"solutionInstanceName\":\"maequiahxicslfa\",\"targetId\":\"z\",\"dependencies\":[{\"solutionVersionId\":\"lhalnswh\",\"solutionTemplateId\":\"sp\",\"solutionTemplateVersion\":\"aivwitqscywu\",\"solutionInstanceName\":\"woluhczbwemhair\",\"targetId\":\"rgzdwmsweyp\",\"dependencies\":[{},{},{},{}]},{\"solutionVersionId\":\"ggicccnxqhue\",\"solutionTemplateId\":\"ktt\",\"solutionTemplateVersion\":\"tvlz\",\"solutionInstanceName\":\"emhzrncsdtc\",\"targetId\":\"siypbs\",\"dependencies\":[{},{}]},{\"solutionVersionId\":\"gusl\",\"solutionTemplateId\":\"adcy\",\"solutionTemplateVersion\":\"ukyhejhzis\",\"solutionInstanceName\":\"fpel\",\"targetId\":\"p\",\"dependencies\":[{},{}]},{\"solutionVersionId\":\"r\",\"solutionTemplateId\":\"vu\",\"solutionTemplateVersion\":\"raehtwdwrft\",\"solutionInstanceName\":\"iby\",\"targetId\":\"dl\",\"dependencies\":[{},{},{},{}]}]},{\"solutionVersionId\":\"fwpracstwi\",\"solutionTemplateId\":\"khevxccedc\",\"solutionTemplateVersion\":\"md\",\"solutionInstanceName\":\"dnwzxltjcvnhltiu\",\"targetId\":\"xnavvwxq\",\"dependencies\":[{\"solutionVersionId\":\"unyowxwl\",\"solutionTemplateId\":\"jrkvfgbvfvpdbo\",\"solutionTemplateVersion\":\"cizsjqlhkrribdei\",\"solutionInstanceName\":\"ipqkghvxndzwm\",\"targetId\":\"efajpj\",\"dependencies\":[{},{}]}]}]}")
            .toObject(BulkPublishSolutionParameter.class);
        Assertions.assertEquals("tpp", model.targets().get(0).targetId());
        Assertions.assertEquals("o", model.targets().get(0).solutionInstanceName());
        Assertions.assertEquals("dut", model.solutionInstanceName());
        Assertions.assertEquals("mr", model.solutionDependencies().get(0).solutionVersionId());
        Assertions.assertEquals("qtvcofudflvkgj", model.solutionDependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("gdknnqv", model.solutionDependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("znqntoru", model.solutionDependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("gsahmkycgrauw", model.solutionDependencies().get(0).targetId());
        Assertions.assertEquals("aeburuvdmo",
            model.solutionDependencies().get(0).dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("mz", model.solutionDependencies().get(0).dependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("wabm",
            model.solutionDependencies().get(0).dependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("efkifr",
            model.solutionDependencies().get(0).dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("puqujmqlgkfbtn", model.solutionDependencies().get(0).dependencies().get(0).targetId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        BulkPublishSolutionParameter model = new BulkPublishSolutionParameter()
            .withTargets(Arrays.asList(new BulkPublishTargetDetails().withTargetId("tpp").withSolutionInstanceName("o"),
                new BulkPublishTargetDetails().withTargetId("xorjaltolmncwsob")
                    .withSolutionInstanceName("csdbnwdcfhuc"),
                new BulkPublishTargetDetails().withTargetId("dpfuvg").withSolutionInstanceName("bjj"),
                new BulkPublishTargetDetails().withTargetId("anvx").withSolutionInstanceName("t")))
            .withSolutionInstanceName("dut")
            .withSolutionDependencies(
                Arrays
                    .asList(
                        new SolutionDependencyParameter().withSolutionVersionId("mr")
                            .withSolutionTemplateId("qtvcofudflvkgj")
                            .withSolutionTemplateVersion("gdknnqv")
                            .withSolutionInstanceName("znqntoru")
                            .withTargetId("gsahmkycgrauw")
                            .withDependencies(Arrays.asList(
                                new SolutionDependencyParameter().withSolutionVersionId("aeburuvdmo")
                                    .withSolutionTemplateId("mz")
                                    .withSolutionTemplateVersion("wabm")
                                    .withSolutionInstanceName("efkifr")
                                    .withTargetId("puqujmqlgkfbtn")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("n")
                                    .withSolutionTemplateId("jcntuj")
                                    .withSolutionTemplateVersion("c")
                                    .withSolutionInstanceName("df")
                                    .withTargetId("waezkojvd")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())))),
                        new SolutionDependencyParameter()
                            .withSolutionVersionId("oqouicybxarzgszu")
                            .withSolutionTemplateId("x")
                            .withSolutionTemplateVersion("q")
                            .withSolutionInstanceName("idoamciodhkha")
                            .withTargetId("khnzbonlw")
                            .withDependencies(Arrays.asList(
                                new SolutionDependencyParameter().withSolutionVersionId("gokdwbwhks")
                                    .withSolutionTemplateId("cmrvexzt")
                                    .withSolutionTemplateVersion("t")
                                    .withSolutionInstanceName("sfraoyzko")
                                    .withTargetId("tlmngu")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("aldsy")
                                    .withSolutionTemplateId("ximerqfobwyznk")
                                    .withSolutionTemplateVersion("kutwpf")
                                    .withSolutionInstanceName("a")
                                    .withTargetId("hrskdsnfd")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("kgtdlmkkze")
                                    .withSolutionTemplateId("l")
                                    .withSolutionTemplateVersion("wpusdsttwvogv")
                                    .withSolutionInstanceName("ejdcngqqmoakuf")
                                    .withTargetId("jzrwrdgrtw")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter())))),
                        new SolutionDependencyParameter().withSolutionVersionId("uzkopbminrfd")
                            .withSolutionTemplateId("yuhhziu")
                            .withSolutionTemplateVersion("fozbhdmsmlmzqhof")
                            .withSolutionInstanceName("maequiahxicslfa")
                            .withTargetId("z")
                            .withDependencies(Arrays.asList(
                                new SolutionDependencyParameter().withSolutionVersionId("lhalnswh")
                                    .withSolutionTemplateId("sp")
                                    .withSolutionTemplateVersion("aivwitqscywu")
                                    .withSolutionInstanceName("woluhczbwemhair")
                                    .withTargetId("rgzdwmsweyp")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("ggicccnxqhue")
                                    .withSolutionTemplateId("ktt")
                                    .withSolutionTemplateVersion("tvlz")
                                    .withSolutionInstanceName("emhzrncsdtc")
                                    .withTargetId("siypbs")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("gusl")
                                    .withSolutionTemplateId("adcy")
                                    .withSolutionTemplateVersion("ukyhejhzis")
                                    .withSolutionInstanceName("fpel")
                                    .withTargetId("p")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter()
                                    .withSolutionVersionId("r")
                                    .withSolutionTemplateId("vu")
                                    .withSolutionTemplateVersion("raehtwdwrft")
                                    .withSolutionInstanceName("iby")
                                    .withTargetId("dl")
                                    .withDependencies(
                                        Arrays.asList(
                                            new SolutionDependencyParameter(), new SolutionDependencyParameter(),
                                            new SolutionDependencyParameter(), new SolutionDependencyParameter())))),
                        new SolutionDependencyParameter().withSolutionVersionId("fwpracstwi")
                            .withSolutionTemplateId("khevxccedc")
                            .withSolutionTemplateVersion("md")
                            .withSolutionInstanceName("dnwzxltjcvnhltiu")
                            .withTargetId("xnavvwxq")
                            .withDependencies(
                                Arrays.asList(new SolutionDependencyParameter().withSolutionVersionId("unyowxwl")
                                    .withSolutionTemplateId("jrkvfgbvfvpdbo")
                                    .withSolutionTemplateVersion("cizsjqlhkrribdei")
                                    .withSolutionInstanceName("ipqkghvxndzwm")
                                    .withTargetId("efajpj")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter()))))));
        model = BinaryData.fromObject(model).toObject(BulkPublishSolutionParameter.class);
        Assertions.assertEquals("tpp", model.targets().get(0).targetId());
        Assertions.assertEquals("o", model.targets().get(0).solutionInstanceName());
        Assertions.assertEquals("dut", model.solutionInstanceName());
        Assertions.assertEquals("mr", model.solutionDependencies().get(0).solutionVersionId());
        Assertions.assertEquals("qtvcofudflvkgj", model.solutionDependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("gdknnqv", model.solutionDependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("znqntoru", model.solutionDependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("gsahmkycgrauw", model.solutionDependencies().get(0).targetId());
        Assertions.assertEquals("aeburuvdmo",
            model.solutionDependencies().get(0).dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("mz", model.solutionDependencies().get(0).dependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("wabm",
            model.solutionDependencies().get(0).dependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("efkifr",
            model.solutionDependencies().get(0).dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("puqujmqlgkfbtn", model.solutionDependencies().get(0).dependencies().get(0).targetId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/BulkPublishTargetDetailsTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.BulkPublishTargetDetails;
import org.junit.jupiter.api.Assertions;

public final class BulkPublishTargetDetailsTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        BulkPublishTargetDetails model
            = BinaryData.fromString("{\"targetId\":\"kqnyh\",\"solutionInstanceName\":\"ij\"}")
                .toObject(BulkPublishTargetDetails.class);
        Assertions.assertEquals("kqnyh", model.targetId());
        Assertions.assertEquals("ij", model.solutionInstanceName());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        BulkPublishTargetDetails model
            = new BulkPublishTargetDetails().withTargetId("kqnyh").withSolutionInstanceName("ij");
        model = BinaryData.fromObject(model).toObject(BulkPublishTargetDetails.class);
        Assertions.assertEquals("kqnyh", model.targetId());
        Assertions.assertEquals("ij", model.solutionInstanceName());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/CapabilityTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.Capability;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import org.junit.jupiter.api.Assertions;

public final class CapabilityTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        Capability model
            = BinaryData.fromString("{\"name\":\"ojhp\",\"description\":\"tfnmdx\",\"state\":\"inactive\"}")
                .toObject(Capability.class);
        Assertions.assertEquals("ojhp", model.name());
        Assertions.assertEquals("tfnmdx", model.description());
        Assertions.assertEquals(ResourceState.INACTIVE, model.state());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        Capability model
            = new Capability().withName("ojhp").withDescription("tfnmdx").withState(ResourceState.INACTIVE);
        model = BinaryData.fromObject(model).toObject(Capability.class);
        Assertions.assertEquals("ojhp", model.name());
        Assertions.assertEquals("tfnmdx", model.description());
        Assertions.assertEquals(ResourceState.INACTIVE, model.state());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ComponentStatusTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ComponentStatus;
import org.junit.jupiter.api.Assertions;

public final class ComponentStatusTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ComponentStatus model
            = BinaryData.fromString("{\"name\":\"quhcdhmduala\",\"status\":\"qpv\"}").toObject(ComponentStatus.class);
        Assertions.assertEquals("quhcdhmduala", model.name());
        Assertions.assertEquals("qpv", model.status());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplateInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class ConfigTemplateInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ConfigTemplateInner model = BinaryData.fromString(
            "{\"properties\":{\"description\":\"ibyowbblgyavutp\",\"latestVersion\":\"joxoism\",\"provisioningState\":\"InProgress\"},\"eTag\":\"pi\",\"location\":\"qolj\",\"tags\":{\"dwl\":\"gxxlxsffgcvizq\",\"youpfgfbkj\":\"w\"},\"id\":\"bdyhgkfminsgowz\",\"name\":\"ttsttktlahbqact\",\"type\":\"tgzukxitmmqt\"}")
            .toObject(ConfigTemplateInner.class);
        Assertions.assertEquals("qolj", model.location());
        Assertions.assertEquals("gxxlxsffgcvizq", model.tags().get("dwl"));
        Assertions.assertEquals("ibyowbblgyavutp", model.properties().description());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ConfigTemplateInner model = new ConfigTemplateInner().withLocation("qolj")
            .withTags(mapOf("dwl", "gxxlxsffgcvizq", "youpfgfbkj", "w"))
            .withProperties(new ConfigTemplateProperties().withDescription("ibyowbblgyavutp"));
        model = BinaryData.fromObject(model).toObject(ConfigTemplateInner.class);
        Assertions.assertEquals("qolj", model.location());
        Assertions.assertEquals("gxxlxsffgcvizq", model.tags().get("dwl"));
        Assertions.assertEquals("ibyowbblgyavutp", model.properties().description());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplateListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.ConfigTemplateListResult;
import org.junit.jupiter.api.Assertions;

public final class ConfigTemplateListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ConfigTemplateListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"description\":\"kkudzp\",\"latestVersion\":\"wjplma\",\"provisioningState\":\"Canceled\"},\"eTag\":\"yohpfkyrkdbdgiog\",\"location\":\"kmnwqjnobaiyhddv\",\"tags\":{\"zdwvvbalxl\":\"egfnmntfpmvmemfn\",\"fukuvsjcswsmystu\":\"lchpodbzevwrdn\",\"chpqbmfpjba\":\"uqypfcvle\"},\"id\":\"widf\",\"name\":\"xsspuunnoxyhk\",\"type\":\"g\"}],\"nextLink\":\"drihpfhoqcaaewda\"}")
            .toObject(ConfigTemplateListResult.class);
        Assertions.assertEquals("kmnwqjnobaiyhddv", model.value().get(0).location());
        Assertions.assertEquals("egfnmntfpmvmemfn", model.value().get(0).tags().get("zdwvvbalxl"));
        Assertions.assertEquals("kkudzp", model.value().get(0).properties().description());
        Assertions.assertEquals("drihpfhoqcaaewda", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatePropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties;
import org.junit.jupiter.api.Assertions;

public final class ConfigTemplatePropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ConfigTemplateProperties model = BinaryData.fromString(
            "{\"description\":\"qqqxhrnxrx\",\"latestVersion\":\"juisavokqdzf\",\"provisioningState\":\"Canceled\"}")
            .toObject(ConfigTemplateProperties.class);
        Assertions.assertEquals("qqqxhrnxrx", model.description());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ConfigTemplateProperties model = new ConfigTemplateProperties().withDescription("qqqxhrnxrx");
        model = BinaryData.fromObject(model).toObject(ConfigTemplateProperties.class);
        Assertions.assertEquals("qqqxhrnxrx", model.description());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplate;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ConfigTemplatesCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"description\":\"mehllizhceu\",\"latestVersion\":\"qodkadppyibngql\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"rxwhydtlu\",\"location\":\"adswz\",\"tags\":{\"y\":\"yemlowuowhlxln\"},\"id\":\"mouvbl\",\"name\":\"mo\",\"type\":\"zkltrfowtdvrfmv\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        ConfigTemplate response = manager.configTemplates()
            .define("ufanray")
            .withRegion("ygzmxieqvdsmak")
            .withExistingResourceGroup("xlzdesygrijwa")
            .withTags(mapOf("bx", "qcahyhxal"))
            .withProperties(new ConfigTemplateProperties().withDescription("ueqfrojsyd"))
            .create();

        Assertions.assertEquals("adswz", response.location());
        Assertions.assertEquals("yemlowuowhlxln", response.tags().get("y"));
        Assertions.assertEquals("mehllizhceu", response.properties().description());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesCreateVersionMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ConfigTemplatesCreateVersionMockTests {
    @Test
    public void testCreateVersion() throws Exception {
        String responseStr
            = "{\"properties\":{\"configurations\":\"tbxoee\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"nfwmyymvqdbpb\",\"id\":\"ckdvez\",\"name\":\"rcssbzhddubbnq\",\"type\":\"b\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        ConfigTemplateVersion response = manager.configTemplates()
            .createVersion("mbmslzoyov", "zdbpqv",
                new ConfigTemplateVersionWithUpdateTypeInner().withUpdateType(UpdateType.MAJOR)
                    .withVersion("gvmxnok")
                    .withConfigTemplateVersion(new ConfigTemplateVersionInner()
                        .withProperties(new ConfigTemplateVersionProperties().withConfigurations("t"))),
                com.azure.core.util.Context.NONE);

        Assertions.assertEquals("tbxoee", response.properties().configurations());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesListByResourceGroupMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplate;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ConfigTemplatesListByResourceGroupMockTests {
    @Test
    public void testListByResourceGroup() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"description\":\"p\",\"latestVersion\":\"xqcsehch\",\"provisioningState\":\"Failed\"},\"eTag\":\"mpqu\",\"location\":\"yjgyd\",\"tags\":{\"sfnhsenwphp\":\"odsaeuzan\"},\"id\":\"fngq\",\"name\":\"clid\",\"type\":\"tujwjju\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<ConfigTemplate> response
            = manager.configTemplates().listByResourceGroup("ygspnbonhpczykm", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("yjgyd", response.iterator().next().location());
        Assertions.assertEquals("odsaeuzan", response.iterator().next().tags().get("sfnhsenwphp"));
        Assertions.assertEquals("p", response.iterator().next().properties().description());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplatesListMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplate;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ConfigTemplatesListMockTests {
    @Test
    public void testList() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"description\":\"beqrkuorh\",\"latestVersion\":\"sruqnmdvha\",\"provisioningState\":\"InProgress\"},\"eTag\":\"ytiq\",\"location\":\"bqerzwx\",\"tags\":{\"dgukvlbpktgds\":\"x\"},\"id\":\"youambewr\",\"name\":\"swmowegmmuteyxe\",\"type\":\"guqigijiitns\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<ConfigTemplate> response = manager.configTemplates().list(com.azure.core.util.Context.NONE);

        Assertions.assertEquals("bqerzwx", response.iterator().next().location());
        Assertions.assertEquals("x", response.iterator().next().tags().get("dgukvlbpktgds"));
        Assertions.assertEquals("beqrkuorh", response.iterator().next().properties().description());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplateVersionInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties;
import org.junit.jupiter.api.Assertions;

public final class ConfigTemplateVersionInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ConfigTemplateVersionInner model = BinaryData.fromString(
            "{\"properties\":{\"configurations\":\"loazuruocbgoo\",\"provisioningState\":\"Deleting\"},\"eTag\":\"oybfhjxakvvj\",\"id\":\"lordilmywwtkgkxn\",\"name\":\"edabgyvudtjue\",\"type\":\"bcihxuuwhc\"}")
            .toObject(ConfigTemplateVersionInner.class);
        Assertions.assertEquals("loazuruocbgoo", model.properties().configurations());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ConfigTemplateVersionInner model = new ConfigTemplateVersionInner()
            .withProperties(new ConfigTemplateVersionProperties().withConfigurations("loazuruocbgoo"));
        model = BinaryData.fromObject(model).toObject(ConfigTemplateVersionInner.class);
        Assertions.assertEquals("loazuruocbgoo", model.properties().configurations());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplateVersionListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.ConfigTemplateVersionListResult;
import org.junit.jupiter.api.Assertions;

public final class ConfigTemplateVersionListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ConfigTemplateVersionListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"configurations\":\"jvlpjxxkzbr\",\"provisioningState\":\"Canceled\"},\"eTag\":\"ivsiy\",\"id\":\"kdncj\",\"name\":\"xonbzoggculapz\",\"type\":\"y\"},{\"properties\":{\"configurations\":\"gogtqxepnylbf\",\"provisioningState\":\"InProgress\"},\"eTag\":\"yjt\",\"id\":\"of\",\"name\":\"zhvfcibyfmowuxr\",\"type\":\"jpvd\"}],\"nextLink\":\"fzwiivwzjbhyz\"}")
            .toObject(ConfigTemplateVersionListResult.class);
        Assertions.assertEquals("jvlpjxxkzbr", model.value().get(0).properties().configurations());
        Assertions.assertEquals("fzwiivwzjbhyz", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplateVersionPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties;
import org.junit.jupiter.api.Assertions;

public final class ConfigTemplateVersionPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ConfigTemplateVersionProperties model
            = BinaryData.fromString("{\"configurations\":\"yxccyb\",\"provisioningState\":\"Initialized\"}")
                .toObject(ConfigTemplateVersionProperties.class);
        Assertions.assertEquals("yxccyb", model.configurations());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ConfigTemplateVersionProperties model = new ConfigTemplateVersionProperties().withConfigurations("yxccyb");
        model = BinaryData.fromObject(model).toObject(ConfigTemplateVersionProperties.class);
        Assertions.assertEquals("yxccyb", model.configurations());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplateVersionsGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersion;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ConfigTemplateVersionsGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"configurations\":\"jbfqzdk\",\"provisioningState\":\"Deleting\"},\"eTag\":\"ixh\",\"id\":\"ratqxmbjro\",\"name\":\"mzznvalqjrhuzgfx\",\"type\":\"njt\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        ConfigTemplateVersion response = manager.configTemplateVersions()
            .getWithResponse("ih", "vjdrqcrjidhftuk", "hdxlw", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("jbfqzdk", response.properties().configurations());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ConfigTemplateVersionWithUpdateTypeInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ConfigTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.ConfigTemplateVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import org.junit.jupiter.api.Assertions;

public final class ConfigTemplateVersionWithUpdateTypeInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ConfigTemplateVersionWithUpdateTypeInner model = BinaryData.fromString(
            "{\"updateType\":\"Minor\",\"version\":\"l\",\"configTemplateVersion\":{\"properties\":{\"configurations\":\"qttbaj\",\"provisioningState\":\"Canceled\"},\"eTag\":\"nwxyiop\",\"id\":\"kqqfk\",\"name\":\"vscx\",\"type\":\"dmligovibrxk\"}}")
            .toObject(ConfigTemplateVersionWithUpdateTypeInner.class);
        Assertions.assertEquals(UpdateType.MINOR, model.updateType());
        Assertions.assertEquals("l", model.version());
        Assertions.assertEquals("qttbaj", model.configTemplateVersion().properties().configurations());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ConfigTemplateVersionWithUpdateTypeInner model
            = new ConfigTemplateVersionWithUpdateTypeInner().withUpdateType(UpdateType.MINOR)
                .withVersion("l")
                .withConfigTemplateVersion(new ConfigTemplateVersionInner()
                    .withProperties(new ConfigTemplateVersionProperties().withConfigurations("qttbaj")));
        model = BinaryData.fromObject(model).toObject(ConfigTemplateVersionWithUpdateTypeInner.class);
        Assertions.assertEquals(UpdateType.MINOR, model.updateType());
        Assertions.assertEquals("l", model.version());
        Assertions.assertEquals("qttbaj", model.configTemplateVersion().properties().configurations());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ContextInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ContextInner;
import com.azure.resourcemanager.workloadorchestration.models.Capability;
import com.azure.resourcemanager.workloadorchestration.models.ContextProperties;
import com.azure.resourcemanager.workloadorchestration.models.Hierarchy;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class ContextInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ContextInner model = BinaryData.fromString(
            "{\"properties\":{\"capabilities\":[{\"name\":\"db\",\"description\":\"cxjmonfdgnwncyp\",\"state\":\"active\"},{\"name\":\"w\",\"description\":\"tvuqjctzenkeifzz\",\"state\":\"inactive\"},{\"name\":\"dasvfl\",\"description\":\"hbxcu\",\"state\":\"inactive\"},{\"name\":\"xgsrboldforobw\",\"description\":\"lvizb\",\"state\":\"inactive\"}],\"hierarchies\":[{\"name\":\"vvacqpb\",\"description\":\"uodxesza\"},{\"name\":\"belawumuaslzkwr\",\"description\":\"woycqucwyha\"},{\"name\":\"nomdrkywuhpsv\",\"description\":\"uurutlwexxwlalni\"}],\"provisioningState\":\"Failed\"},\"location\":\"rzpgep\",\"tags\":{\"wpgdak\":\"bb\"},\"id\":\"hzyvlixqnrkcx\",\"name\":\"jibnxmysu\",\"type\":\"swqrntvlwijp\"}")
            .toObject(ContextInner.class);
        Assertions.assertEquals("rzpgep", model.location());
        Assertions.assertEquals("bb", model.tags().get("wpgdak"));
        Assertions.assertEquals("db", model.properties().capabilities().get(0).name());
        Assertions.assertEquals("cxjmonfdgnwncyp", model.properties().capabilities().get(0).description());
        Assertions.assertEquals(ResourceState.ACTIVE, model.properties().capabilities().get(0).state());
        Assertions.assertEquals("vvacqpb", model.properties().hierarchies().get(0).name());
        Assertions.assertEquals("uodxesza", model.properties().hierarchies().get(0).description());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ContextInner model = new ContextInner().withLocation("rzpgep")
            .withTags(mapOf("wpgdak", "bb"))
            .withProperties(new ContextProperties().withCapabilities(Arrays.asList(
                new Capability().withName("db").withDescription("cxjmonfdgnwncyp").withState(ResourceState.ACTIVE),
                new Capability().withName("w").withDescription("tvuqjctzenkeifzz").withState(ResourceState.INACTIVE),
                new Capability().withName("dasvfl").withDescription("hbxcu").withState(ResourceState.INACTIVE),
                new Capability().withName("xgsrboldforobw").withDescription("lvizb").withState(ResourceState.INACTIVE)))
                .withHierarchies(Arrays.asList(new Hierarchy().withName("vvacqpb").withDescription("uodxesza"),
                    new Hierarchy().withName("belawumuaslzkwr").withDescription("woycqucwyha"),
                    new Hierarchy().withName("nomdrkywuhpsv").withDescription("uurutlwexxwlalni"))));
        model = BinaryData.fromObject(model).toObject(ContextInner.class);
        Assertions.assertEquals("rzpgep", model.location());
        Assertions.assertEquals("bb", model.tags().get("wpgdak"));
        Assertions.assertEquals("db", model.properties().capabilities().get(0).name());
        Assertions.assertEquals("cxjmonfdgnwncyp", model.properties().capabilities().get(0).description());
        Assertions.assertEquals(ResourceState.ACTIVE, model.properties().capabilities().get(0).state());
        Assertions.assertEquals("vvacqpb", model.properties().hierarchies().get(0).name());
        Assertions.assertEquals("uodxesza", model.properties().hierarchies().get(0).description());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ContextListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.ContextListResult;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import org.junit.jupiter.api.Assertions;

public final class ContextListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ContextListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"capabilities\":[{\"name\":\"vyhyhsgzfc\",\"description\":\"bgomfgbegl\",\"state\":\"inactive\"}],\"hierarchies\":[{\"name\":\"o\",\"description\":\"i\"},{\"name\":\"etnluankrrfx\",\"description\":\"eebtijvacvb\"}],\"provisioningState\":\"Succeeded\"},\"location\":\"qqxlajr\",\"tags\":{\"afgaoqlt\":\"acevehjkuyx\",\"gv\":\"aeylinm\"},\"id\":\"irpghriypoqeyh\",\"name\":\"qhykprlpyzn\",\"type\":\"ciqdsme\"}],\"nextLink\":\"itdfuxtyasiib\"}")
            .toObject(ContextListResult.class);
        Assertions.assertEquals("qqxlajr", model.value().get(0).location());
        Assertions.assertEquals("acevehjkuyx", model.value().get(0).tags().get("afgaoqlt"));
        Assertions.assertEquals("vyhyhsgzfc", model.value().get(0).properties().capabilities().get(0).name());
        Assertions.assertEquals("bgomfgbegl", model.value().get(0).properties().capabilities().get(0).description());
        Assertions.assertEquals(ResourceState.INACTIVE,
            model.value().get(0).properties().capabilities().get(0).state());
        Assertions.assertEquals("o", model.value().get(0).properties().hierarchies().get(0).name());
        Assertions.assertEquals("i", model.value().get(0).properties().hierarchies().get(0).description());
        Assertions.assertEquals("itdfuxtyasiib", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ContextPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.Capability;
import com.azure.resourcemanager.workloadorchestration.models.ContextProperties;
import com.azure.resourcemanager.workloadorchestration.models.Hierarchy;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.util.Arrays;
import org.junit.jupiter.api.Assertions;

public final class ContextPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ContextProperties model = BinaryData.fromString(
            "{\"capabilities\":[{\"name\":\"texoqqpwc\",\"description\":\"yufmhruncuwmq\",\"state\":\"inactive\"},{\"name\":\"cdqzhlctddu\",\"description\":\"qn\",\"state\":\"active\"},{\"name\":\"pchrqbn\",\"description\":\"jrcg\",\"state\":\"inactive\"},{\"name\":\"dcwboxjum\",\"description\":\"qqoli\",\"state\":\"inactive\"}],\"hierarchies\":[{\"name\":\"iouaubrjt\",\"description\":\"oq\"},{\"name\":\"fuojrngif\",\"description\":\"rzpasccbiuimzdly\"},{\"name\":\"dfqwmkyoq\",\"description\":\"fdvruz\"}],\"provisioningState\":\"Initialized\"}")
            .toObject(ContextProperties.class);
        Assertions.assertEquals("texoqqpwc", model.capabilities().get(0).name());
        Assertions.assertEquals("yufmhruncuwmq", model.capabilities().get(0).description());
        Assertions.assertEquals(ResourceState.INACTIVE, model.capabilities().get(0).state());
        Assertions.assertEquals("iouaubrjt", model.hierarchies().get(0).name());
        Assertions.assertEquals("oq", model.hierarchies().get(0).description());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ContextProperties model = new ContextProperties().withCapabilities(Arrays.asList(
            new Capability().withName("texoqqpwc").withDescription("yufmhruncuwmq").withState(ResourceState.INACTIVE),
            new Capability().withName("cdqzhlctddu").withDescription("qn").withState(ResourceState.ACTIVE),
            new Capability().withName("pchrqbn").withDescription("jrcg").withState(ResourceState.INACTIVE),
            new Capability().withName("dcwboxjum").withDescription("qqoli").withState(ResourceState.INACTIVE)))
            .withHierarchies(Arrays.asList(new Hierarchy().withName("iouaubrjt").withDescription("oq"),
                new Hierarchy().withName("fuojrngif").withDescription("rzpasccbiuimzdly"),
                new Hierarchy().withName("dfqwmkyoq").withDescription("fdvruz")));
        model = BinaryData.fromObject(model).toObject(ContextProperties.class);
        Assertions.assertEquals("texoqqpwc", model.capabilities().get(0).name());
        Assertions.assertEquals("yufmhruncuwmq", model.capabilities().get(0).description());
        Assertions.assertEquals(ResourceState.INACTIVE, model.capabilities().get(0).state());
        Assertions.assertEquals("iouaubrjt", model.hierarchies().get(0).name());
        Assertions.assertEquals("oq", model.hierarchies().get(0).description());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Capability;
import com.azure.resourcemanager.workloadorchestration.models.ContextModel;
import com.azure.resourcemanager.workloadorchestration.models.ContextProperties;
import com.azure.resourcemanager.workloadorchestration.models.Hierarchy;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ContextsCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"capabilities\":[{\"name\":\"tedousnktjtgrava\",\"description\":\"ogfkbebauzlqb\",\"state\":\"inactive\"}],\"hierarchies\":[{\"name\":\"pfhnjzudrt\",\"description\":\"zkg\"},{\"name\":\"eboywhczzqrhm\",\"description\":\"gqbedygi\"},{\"name\":\"rzwnyk\",\"description\":\"id\"},{\"name\":\"chl\",\"description\":\"mpwctoflds\"}],\"provisioningState\":\"Succeeded\"},\"location\":\"hztxkbrfgd\",\"tags\":{\"etfgcwvrrmdqntyc\":\"iyewhfjsrwqr\"},\"id\":\"awthvmaxgnu\",\"name\":\"eamc\",\"type\":\"hudfjecehok\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        ContextModel response = manager.contexts()
            .define("ojhtollhs")
            .withRegion("ninjgazlsvbz")
            .withExistingResourceGroup("ecleqioulndhzyo")
            .withTags(mapOf("lhsyekrdrenxolr", "uoeedwjcci", "bfgrlpunytjlkes", "yehqbeivdlhydwb"))
            .withProperties(new ContextProperties().withCapabilities(Arrays.asList(
                new Capability().withName("mytzln").withDescription("lxpnovyoanf").withState(ResourceState.INACTIVE)))
                .withHierarchies(Arrays.asList(new Hierarchy().withName("qagywvtxig").withDescription("jrktpgaeukya"),
                    new Hierarchy().withName("ohpmwhqn").withDescription("csklhsidsjt"))))
            .create();

        Assertions.assertEquals("hztxkbrfgd", response.location());
        Assertions.assertEquals("iyewhfjsrwqr", response.tags().get("etfgcwvrrmdqntyc"));
        Assertions.assertEquals("tedousnktjtgrava", response.properties().capabilities().get(0).name());
        Assertions.assertEquals("ogfkbebauzlqb", response.properties().capabilities().get(0).description());
        Assertions.assertEquals(ResourceState.INACTIVE, response.properties().capabilities().get(0).state());
        Assertions.assertEquals("pfhnjzudrt", response.properties().hierarchies().get(0).name());
        Assertions.assertEquals("zkg", response.properties().hierarchies().get(0).description());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsGetByResourceGroupWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ContextModel;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ContextsGetByResourceGroupWithResponseMockTests {
    @Test
    public void testGetByResourceGroupWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"capabilities\":[{\"name\":\"gvkvebaqszll\",\"description\":\"zlsmmdqgmihzpim\",\"state\":\"active\"},{\"name\":\"hnxtmin\",\"description\":\"logxsvtzar\",\"state\":\"active\"},{\"name\":\"qnsqktcmb\",\"description\":\"wzzoslpk\",\"state\":\"inactive\"},{\"name\":\"glwkzpgajsqj\",\"description\":\"emqbmfuvqarwzxuq\",\"state\":\"active\"}],\"hierarchies\":[{\"name\":\"uim\",\"description\":\"bwxsfgtdm\"}],\"provisioningState\":\"Failed\"},\"location\":\"kraokq\",\"tags\":{\"taaknwfrkebsmhp\":\"dbtwaokbavly\"},\"id\":\"ujd\",\"name\":\"gatolekscbctnan\",\"type\":\"imwbzxpdcldpk\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        ContextModel response = manager.contexts()
            .getByResourceGroupWithResponse("kpysthhzagjf", "yyrlhgenu", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("kraokq", response.location());
        Assertions.assertEquals("dbtwaokbavly", response.tags().get("taaknwfrkebsmhp"));
        Assertions.assertEquals("gvkvebaqszll", response.properties().capabilities().get(0).name());
        Assertions.assertEquals("zlsmmdqgmihzpim", response.properties().capabilities().get(0).description());
        Assertions.assertEquals(ResourceState.ACTIVE, response.properties().capabilities().get(0).state());
        Assertions.assertEquals("uim", response.properties().hierarchies().get(0).name());
        Assertions.assertEquals("bwxsfgtdm", response.properties().hierarchies().get(0).description());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsListByResourceGroupMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ContextModel;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ContextsListByResourceGroupMockTests {
    @Test
    public void testListByResourceGroup() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"capabilities\":[{\"name\":\"dmfcoibicziusws\",\"description\":\"jrkbqsjhbtqqvyfs\",\"state\":\"active\"},{\"name\":\"fwbivqvo\",\"description\":\"fuy\",\"state\":\"inactive\"},{\"name\":\"bhli\",\"description\":\"byqecroo\",\"state\":\"inactive\"},{\"name\":\"kcdrdaasaxxobsm\",\"description\":\"kwiy\",\"state\":\"active\"}],\"hierarchies\":[{\"name\":\"ko\",\"description\":\"r\"},{\"name\":\"awn\",\"description\":\"zm\"}],\"provisioningState\":\"Initialized\"},\"location\":\"ywsxvjabjqqaxu\",\"tags\":{\"udndoabhjxw\":\"mc\"},\"id\":\"qweuip\",\"name\":\"pvksmit\",\"type\":\"sqxtltclkrdpq\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<ContextModel> response
            = manager.contexts().listByResourceGroup("wnsnlaimouxwks", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("ywsxvjabjqqaxu", response.iterator().next().location());
        Assertions.assertEquals("mc", response.iterator().next().tags().get("udndoabhjxw"));
        Assertions.assertEquals("dmfcoibicziusws",
            response.iterator().next().properties().capabilities().get(0).name());
        Assertions.assertEquals("jrkbqsjhbtqqvyfs",
            response.iterator().next().properties().capabilities().get(0).description());
        Assertions.assertEquals(ResourceState.ACTIVE,
            response.iterator().next().properties().capabilities().get(0).state());
        Assertions.assertEquals("ko", response.iterator().next().properties().hierarchies().get(0).name());
        Assertions.assertEquals("r", response.iterator().next().properties().hierarchies().get(0).description());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ContextsListMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ContextModel;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ContextsListMockTests {
    @Test
    public void testList() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"capabilities\":[{\"name\":\"yrfrak\",\"description\":\"ldgrcw\",\"state\":\"inactive\"},{\"name\":\"fc\",\"description\":\"rjajqmatxjtie\",\"state\":\"active\"},{\"name\":\"qgxxgfbb\",\"description\":\"tlpqagynoi\",\"state\":\"active\"}],\"hierarchies\":[{\"name\":\"calincryqxz\",\"description\":\"aqzi\"},{\"name\":\"mqimiymqru\",\"description\":\"guhfupe\"},{\"name\":\"asvvoqsbpkfl\",\"description\":\"nfkgxsyaowuzowpu\"}],\"provisioningState\":\"Failed\"},\"location\":\"cprgukxrztiochl\",\"tags\":{\"f\":\"xmqrudjizc\",\"fbcpaqktkrumzu\":\"mcrunfhiucn\",\"kxiuxqggvqr\":\"dkyzbfvxov\",\"jhffbxrqrkij\":\"hyhlwcjsqg\"},\"id\":\"euqlsdxeqztv\",\"name\":\"wmwwmjswen\",\"type\":\"wwa\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<ContextModel> response = manager.contexts().list(com.azure.core.util.Context.NONE);

        Assertions.assertEquals("cprgukxrztiochl", response.iterator().next().location());
        Assertions.assertEquals("xmqrudjizc", response.iterator().next().tags().get("f"));
        Assertions.assertEquals("yrfrak", response.iterator().next().properties().capabilities().get(0).name());
        Assertions.assertEquals("ldgrcw", response.iterator().next().properties().capabilities().get(0).description());
        Assertions.assertEquals(ResourceState.INACTIVE,
            response.iterator().next().properties().capabilities().get(0).state());
        Assertions.assertEquals("calincryqxz", response.iterator().next().properties().hierarchies().get(0).name());
        Assertions.assertEquals("aqzi", response.iterator().next().properties().hierarchies().get(0).description());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DeployJobParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.DeployJobParameter;
import org.junit.jupiter.api.Assertions;

public final class DeployJobParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DeployJobParameter model
            = BinaryData.fromString("{\"jobType\":\"deploy\",\"parameter\":{\"solutionVersionId\":\"piu\"}}")
                .toObject(DeployJobParameter.class);
        Assertions.assertEquals("piu", model.parameter().solutionVersionId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DeployJobStepStatisticsTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.DeployJobStepStatistics;
import org.junit.jupiter.api.Assertions;

public final class DeployJobStepStatisticsTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DeployJobStepStatistics model = BinaryData.fromString(
            "{\"statisticsType\":\"deploy\",\"totalCount\":720121920,\"successCount\":798441434,\"failedCount\":1495315655}")
            .toObject(DeployJobStepStatistics.class);
        Assertions.assertEquals(720121920, model.totalCount());
        Assertions.assertEquals(798441434, model.successCount());
        Assertions.assertEquals(1495315655, model.failedCount());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DeploymentStatusTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.DeploymentStatus;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;

public final class DeploymentStatusTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DeploymentStatus model = BinaryData.fromString(
            "{\"lastModified\":\"2021-11-25T08:03Z\",\"deployed\":435215346,\"expectedRunningJobId\":746279797,\"runningJobId\":996509936,\"status\":\"smtxpsieb\",\"statusDetails\":\"hvpesapskrdqm\",\"generation\":1058725142,\"targetStatuses\":[{\"name\":\"ldwkyzxuutkn\",\"status\":\"scwsv\",\"componentStatuses\":[{\"name\":\"ogtwrupqsxvnmi\",\"status\":\"kvceoveilovnotyf\"},{\"name\":\"cnjbkcnxdhbt\",\"status\":\"phywpnvj\"},{\"name\":\"qnermclfplphoxu\",\"status\":\"rpabg\"}]},{\"name\":\"psbjta\",\"status\":\"ugxywpmueef\",\"componentStatuses\":[{\"name\":\"qkqujidsu\",\"status\":\"nobglaocq\"},{\"name\":\"ccm\",\"status\":\"udxytlmoyrx\"}]}]}")
            .toObject(DeploymentStatus.class);
        Assertions.assertEquals(OffsetDateTime.parse("2021-11-25T08:03Z"), model.lastModified());
        Assertions.assertEquals(435215346, model.deployed());
        Assertions.assertEquals(746279797, model.expectedRunningJobId());
        Assertions.assertEquals(996509936, model.runningJobId());
        Assertions.assertEquals("smtxpsieb", model.status());
        Assertions.assertEquals("hvpesapskrdqm", model.statusDetails());
        Assertions.assertEquals(1058725142, model.generation());
        Assertions.assertEquals("ldwkyzxuutkn", model.targetStatuses().get(0).name());
        Assertions.assertEquals("scwsv", model.targetStatuses().get(0).status());
        Assertions.assertEquals("ogtwrupqsxvnmi", model.targetStatuses().get(0).componentStatuses().get(0).name());
        Assertions.assertEquals("kvceoveilovnotyf", model.targetStatuses().get(0).componentStatuses().get(0).status());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DiagnosticInner;
import com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class DiagnosticInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DiagnosticInner model = BinaryData.fromString(
            "{\"properties\":{\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"oyjathwtzol\",\"type\":\"EdgeZone\"},\"eTag\":\"mwmdxmebwjscjpa\",\"location\":\"xveabf\",\"tags\":{\"ijddtvqc\":\"mwmqtibx\",\"jaeukmrsieekpn\":\"tad\",\"pibudqwyxebeybpm\":\"zaapmudqmeqwi\"},\"id\":\"znrtffyaqit\",\"name\":\"hheioqaqhvseuf\",\"type\":\"qyrxp\"}")
            .toObject(DiagnosticInner.class);
        Assertions.assertEquals("xveabf", model.location());
        Assertions.assertEquals("mwmqtibx", model.tags().get("ijddtvqc"));
        Assertions.assertEquals("oyjathwtzol", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.extendedLocation().type());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        DiagnosticInner model = new DiagnosticInner().withLocation("xveabf")
            .withTags(mapOf("ijddtvqc", "mwmqtibx", "jaeukmrsieekpn", "tad", "pibudqwyxebeybpm", "zaapmudqmeqwi"))
            .withProperties(new DiagnosticProperties())
            .withExtendedLocation(
                new ExtendedLocation().withName("oyjathwtzol").withType(ExtendedLocationType.EDGE_ZONE));
        model = BinaryData.fromObject(model).toObject(DiagnosticInner.class);
        Assertions.assertEquals("xveabf", model.location());
        Assertions.assertEquals("mwmqtibx", model.tags().get("ijddtvqc"));
        Assertions.assertEquals("oyjathwtzol", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.extendedLocation().type());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.DiagnosticListResult;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import org.junit.jupiter.api.Assertions;

public final class DiagnosticListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DiagnosticListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"provisioningState\":\"Deleting\"},\"extendedLocation\":{\"name\":\"smjqfrddgam\",\"type\":\"CustomLocation\"},\"eTag\":\"iosrsjuivfcdis\",\"location\":\"rnxzh\",\"tags\":{\"qvwre\":\"xrxzbujrtr\",\"nzonzl\":\"khgn\",\"jtszcof\":\"piqywnc\",\"k\":\"zehtdhgb\"},\"id\":\"reljeamur\",\"name\":\"zmlovuanash\",\"type\":\"xlpm\"}],\"nextLink\":\"rbdkelvidiz\"}")
            .toObject(DiagnosticListResult.class);
        Assertions.assertEquals("rnxzh", model.value().get(0).location());
        Assertions.assertEquals("xrxzbujrtr", model.value().get(0).tags().get("qvwre"));
        Assertions.assertEquals("smjqfrddgam", model.value().get(0).extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.value().get(0).extendedLocation().type());
        Assertions.assertEquals("rbdkelvidiz", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties;

public final class DiagnosticPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DiagnosticProperties model
            = BinaryData.fromString("{\"provisioningState\":\"Deleting\"}").toObject(DiagnosticProperties.class);
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        DiagnosticProperties model = new DiagnosticProperties();
        model = BinaryData.fromObject(model).toObject(DiagnosticProperties.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticsCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Diagnostic;
import com.azure.resourcemanager.workloadorchestration.models.DiagnosticProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class DiagnosticsCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"ggytexvzilmhivz\",\"type\":\"EdgeZone\"},\"eTag\":\"wncknr\",\"location\":\"ajlskzptj\",\"tags\":{\"qlehmcgcjeinu\":\"weucyrth\"},\"id\":\"hokamvfej\",\"name\":\"qnttmbq\",\"type\":\"abzfivf\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Diagnostic response = manager.diagnostics()
            .define("funlcpxxvi")
            .withRegion("ljtiahxmfqryarv")
            .withExistingResourceGroup("txvcm")
            .withTags(mapOf("hz", "qbglcjkaysp", "gblioskkfmkm", "dubtlmj", "dlrslskk", "djxyxgbkkqvjcteo"))
            .withProperties(new DiagnosticProperties())
            .withExtendedLocation(new ExtendedLocation().withName("gjgvr").withType(ExtendedLocationType.EDGE_ZONE))
            .create();

        Assertions.assertEquals("ajlskzptj", response.location());
        Assertions.assertEquals("weucyrth", response.tags().get("qlehmcgcjeinu"));
        Assertions.assertEquals("ggytexvzilmhivz", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.extendedLocation().type());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticsListByResourceGroupMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Diagnostic;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class DiagnosticsListByResourceGroupMockTests {
    @Test
    public void testListByResourceGroup() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"uqndaizupfkhuy\",\"type\":\"EdgeZone\"},\"eTag\":\"zx\",\"location\":\"tvtv\",\"tags\":{\"tthaokgkskj\":\"qiukvzwyd\"},\"id\":\"vb\",\"name\":\"shajqf\",\"type\":\"kpeexpgeumilh\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Diagnostic> response
            = manager.diagnostics().listByResourceGroup("ldtzmpypefcp", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("tvtv", response.iterator().next().location());
        Assertions.assertEquals("qiukvzwyd", response.iterator().next().tags().get("tthaokgkskj"));
        Assertions.assertEquals("uqndaizupfkhuy", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.iterator().next().extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DiagnosticsListMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Diagnostic;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class DiagnosticsListMockTests {
    @Test
    public void testList() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"provisioningState\":\"InProgress\"},\"extendedLocation\":{\"name\":\"dexyionofninbdb\",\"type\":\"EdgeZone\"},\"eTag\":\"cw\",\"location\":\"rsmpcbbprtuga\",\"tags\":{\"tbfcm\":\"bcyksivmfogd\",\"mb\":\"rftsjcwjjxs\"},\"id\":\"wvif\",\"name\":\"xkecifhocj\",\"type\":\"wkloozr\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Diagnostic> response = manager.diagnostics().list(com.azure.core.util.Context.NONE);

        Assertions.assertEquals("rsmpcbbprtuga", response.iterator().next().location());
        Assertions.assertEquals("bcyksivmfogd", response.iterator().next().tags().get("tbfcm"));
        Assertions.assertEquals("dexyionofninbdb", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.iterator().next().extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaInner;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties;

public final class DynamicSchemaInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DynamicSchemaInner model = BinaryData.fromString(
            "{\"properties\":{\"configurationType\":\"Shared\",\"configurationModel\":\"Application\",\"provisioningState\":\"Initialized\"},\"eTag\":\"xpyb\",\"id\":\"m\",\"name\":\"hmtzopbsphrup\",\"type\":\"dgs\"}")
            .toObject(DynamicSchemaInner.class);
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        DynamicSchemaInner model = new DynamicSchemaInner().withProperties(new DynamicSchemaProperties());
        model = BinaryData.fromObject(model).toObject(DynamicSchemaInner.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.DynamicSchemaListResult;
import org.junit.jupiter.api.Assertions;

public final class DynamicSchemaListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DynamicSchemaListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"configurationType\":\"Hierarchy\",\"configurationModel\":\"Application\",\"provisioningState\":\"Deleting\"},\"eTag\":\"bhdxbm\",\"id\":\"ioq\",\"name\":\"zehtbmu\",\"type\":\"p\"},{\"properties\":{\"configurationType\":\"Shared\",\"configurationModel\":\"Application\",\"provisioningState\":\"Deleting\"},\"eTag\":\"rxybqsoq\",\"id\":\"gkdmb\",\"name\":\"azlobcufpdznrbt\",\"type\":\"qqjnqgl\"}],\"nextLink\":\"gnufoooj\"}")
            .toObject(DynamicSchemaListResult.class);
        Assertions.assertEquals("gnufoooj", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties;

public final class DynamicSchemaPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DynamicSchemaProperties model = BinaryData.fromString(
            "{\"configurationType\":\"Hierarchy\",\"configurationModel\":\"Application\",\"provisioningState\":\"Failed\"}")
            .toObject(DynamicSchemaProperties.class);
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        DynamicSchemaProperties model = new DynamicSchemaProperties();
        model = BinaryData.fromObject(model).toObject(DynamicSchemaProperties.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemasCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchema;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class DynamicSchemasCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"configurationType\":\"Shared\",\"configurationModel\":\"Application\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"ieholewjwi\",\"id\":\"bwefqsfapaqtfer\",\"name\":\"q\",\"type\":\"ex\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        DynamicSchema response = manager.dynamicSchemas()
            .define("tmzlbiojlv")
            .withExistingSchema("sbostzel", "dlat")
            .withProperties(new DynamicSchemaProperties())
            .create();

    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemasGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchema;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class DynamicSchemasGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"configurationType\":\"Shared\",\"configurationModel\":\"Common\",\"provisioningState\":\"InProgress\"},\"eTag\":\"fkbg\",\"id\":\"bowxe\",\"name\":\"o\",\"type\":\"ljmygvkzqkjjeokb\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        DynamicSchema response = manager.dynamicSchemas()
            .getWithResponse("sufco", "dxbzlmcmuap", "vhdbevwqqxey", com.azure.core.util.Context.NONE)
            .getValue();

    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemasListBySchemaMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchema;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class DynamicSchemasListBySchemaMockTests {
    @Test
    public void testListBySchema() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"configurationType\":\"Shared\",\"configurationModel\":\"Application\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"v\",\"id\":\"bzdixzmq\",\"name\":\"noda\",\"type\":\"opqhewjptmc\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<DynamicSchema> response
            = manager.dynamicSchemas().listBySchema("efezrxcczurtlei", "q", com.azure.core.util.Context.NONE);

    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaVersionInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.DynamicSchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import org.junit.jupiter.api.Assertions;

public final class DynamicSchemaVersionInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DynamicSchemaVersionInner model = BinaryData.fromString(
            "{\"properties\":{\"value\":\"jxgciqibrh\",\"provisioningState\":\"InProgress\"},\"eTag\":\"dqrhzoymib\",\"id\":\"qyib\",\"name\":\"hwflu\",\"type\":\"zdtmhrkwofy\"}")
            .toObject(DynamicSchemaVersionInner.class);
        Assertions.assertEquals("jxgciqibrh", model.properties().value());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        DynamicSchemaVersionInner model
            = new DynamicSchemaVersionInner().withProperties(new SchemaVersionProperties().withValue("jxgciqibrh"));
        model = BinaryData.fromObject(model).toObject(DynamicSchemaVersionInner.class);
        Assertions.assertEquals("jxgciqibrh", model.properties().value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaVersionListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.DynamicSchemaVersionListResult;
import org.junit.jupiter.api.Assertions;

public final class DynamicSchemaVersionListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        DynamicSchemaVersionListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"value\":\"qacpiex\",\"provisioningState\":\"Failed\"},\"eTag\":\"iwbwoenwashrtdtk\",\"id\":\"qxwbpokulpiu\",\"name\":\"waasip\",\"type\":\"i\"},{\"properties\":{\"value\":\"byuqerpqlp\",\"provisioningState\":\"Canceled\"},\"eTag\":\"iuqgbdbutauv\",\"id\":\"tkuwhhmhykojo\",\"name\":\"afnn\",\"type\":\"lpichk\"},{\"properties\":{\"value\":\"mkcdyhbpkkpwdre\",\"provisioningState\":\"Initialized\"},\"eTag\":\"vq\",\"id\":\"vljxywsu\",\"name\":\"syrsndsytgadgvra\",\"type\":\"aeneqnzarrwl\"}],\"nextLink\":\"uijfqk\"}")
            .toObject(DynamicSchemaVersionListResult.class);
        Assertions.assertEquals("qacpiex", model.value().get(0).properties().value());
        Assertions.assertEquals("uijfqk", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaVersionsCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class DynamicSchemaVersionsCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"value\":\"weftkwq\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"vssehaepw\",\"id\":\"cxtczhupeukn\",\"name\":\"jduyyespydjfb\",\"type\":\"c\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        DynamicSchemaVersion response = manager.dynamicSchemaVersions()
            .define("bsjuscvsfx")
            .withExistingDynamicSchema("mghihp", "ecmslclbl", "jxl")
            .withProperties(new SchemaVersionProperties().withValue("ctmgxuupbezqccy"))
            .create();

        Assertions.assertEquals("weftkwq", response.properties().value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/DynamicSchemaVersionsGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.DynamicSchemaVersion;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class DynamicSchemaVersionsGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"value\":\"k\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"wgzwxjlmecvog\",\"id\":\"zyvneezaifghtmo\",\"name\":\"qtlffhzbk\",\"type\":\"kjj\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        DynamicSchemaVersion response = manager.dynamicSchemaVersions()
            .getWithResponse("fgbrtt", "iac", "kiexhajlfnthiq", "yuttdiygbpvnwswm", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("k", response.properties().value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ErrorActionTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode;
import org.junit.jupiter.api.Assertions;

public final class ErrorActionTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ErrorAction model = BinaryData.fromString("{\"mode\":\"stopOnNFailures\",\"maxToleratedFailures\":1343904651}")
            .toObject(ErrorAction.class);
        Assertions.assertEquals(ErrorActionMode.STOP_ON_NFAILURES, model.mode());
        Assertions.assertEquals(1343904651, model.maxToleratedFailures());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ErrorAction model
            = new ErrorAction().withMode(ErrorActionMode.STOP_ON_NFAILURES).withMaxToleratedFailures(1343904651);
        model = BinaryData.fromObject(model).toObject(ErrorAction.class);
        Assertions.assertEquals(ErrorActionMode.STOP_ON_NFAILURES, model.mode());
        Assertions.assertEquals(1343904651, model.maxToleratedFailures());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ExecutionInner;
import com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class ExecutionInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ExecutionInner model = BinaryData.fromString(
            "{\"properties\":{\"workflowVersionId\":\"iwrxgkn\",\"specification\":{},\"status\":{\"updateTime\":\"2021-10-18T16:16:50Z\",\"status\":1482773915,\"statusMessage\":\"dfvpg\",\"stageHistory\":[{\"status\":631960755,\"statusMessage\":\"gbpfgz\",\"stage\":\"tx\",\"nextstage\":\"flbqvgaq\",\"errorMessage\":\"gafcqu\",\"isActive\":\"active\",\"inputs\":{},\"outputs\":{}},{\"status\":999562740,\"statusMessage\":\"tutnwlduycvuzhyr\",\"stage\":\"wipmvekdxuk\",\"nextstage\":\"gsjj\",\"errorMessage\":\"n\",\"isActive\":\"inactive\",\"inputs\":{},\"outputs\":{}},{\"status\":1861244838,\"statusMessage\":\"zjhfjmhvv\",\"stage\":\"vgpmun\",\"nextstage\":\"sx\",\"errorMessage\":\"hfbuzjyihsasbhud\",\"isActive\":\"inactive\",\"inputs\":{},\"outputs\":{}},{\"status\":840782124,\"statusMessage\":\"ynsqyrpfoobr\",\"stage\":\"tyms\",\"nextstage\":\"ygqdnfwqzdz\",\"errorMessage\":\"ilaxhn\",\"isActive\":\"active\",\"inputs\":{},\"outputs\":{}}]},\"provisioningState\":\"Failed\"},\"extendedLocation\":{\"name\":\"wivkxo\",\"type\":\"EdgeZone\"},\"eTag\":\"nbixxrti\",\"id\":\"cpwpg\",\"name\":\"lrcivtsoxfrke\",\"type\":\"xpmyyefrpmpdnq\"}")
            .toObject(ExecutionInner.class);
        Assertions.assertEquals("iwrxgkn", model.properties().workflowVersionId());
        Assertions.assertEquals("wivkxo", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.extendedLocation().type());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ExecutionInner model = new ExecutionInner()
            .withProperties(new ExecutionProperties().withWorkflowVersionId("iwrxgkn").withSpecification(mapOf()))
            .withExtendedLocation(new ExtendedLocation().withName("wivkxo").withType(ExtendedLocationType.EDGE_ZONE));
        model = BinaryData.fromObject(model).toObject(ExecutionInner.class);
        Assertions.assertEquals("iwrxgkn", model.properties().workflowVersionId());
        Assertions.assertEquals("wivkxo", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.extendedLocation().type());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.ExecutionListResult;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import org.junit.jupiter.api.Assertions;

public final class ExecutionListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ExecutionListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"workflowVersionId\":\"nhxk\",\"specification\":{},\"status\":{\"updateTime\":\"2021-03-21T02:57:11Z\",\"status\":1084894026,\"statusMessage\":\"uljraae\",\"stageHistory\":[{}]},\"provisioningState\":\"InProgress\"},\"extendedLocation\":{\"name\":\"gukkjqnvbroy\",\"type\":\"EdgeZone\"},\"eTag\":\"xulcdisdos\",\"id\":\"b\",\"name\":\"svgjrwhryvy\",\"type\":\"ytdc\"},{\"properties\":{\"workflowVersionId\":\"gc\",\"specification\":{},\"status\":{\"updateTime\":\"2021-02-23T09:22:23Z\",\"status\":1455211628,\"statusMessage\":\"mvpdvjdhttzaef\",\"stageHistory\":[{}]},\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"hrphkmcrjdqn\",\"type\":\"CustomLocation\"},\"eTag\":\"zpbgtgkylkdg\",\"id\":\"jeuut\",\"name\":\"wxezwzhok\",\"type\":\"bwnhhtql\"},{\"properties\":{\"workflowVersionId\":\"hgppipifhpfeoa\",\"specification\":{},\"status\":{\"updateTime\":\"2021-07-28T21:00:45Z\",\"status\":189991071,\"statusMessage\":\"sheafid\",\"stageHistory\":[{},{},{},{}]},\"provisioningState\":\"Canceled\"},\"extendedLocation\":{\"name\":\"esmkssjhoiftxfkf\",\"type\":\"CustomLocation\"},\"eTag\":\"prhptillu\",\"id\":\"iqtgdqoh\",\"name\":\"cwsldri\",\"type\":\"etpwbralll\"},{\"properties\":{\"workflowVersionId\":\"phbqz\",\"specification\":{},\"status\":{\"updateTime\":\"2021-08-01T14:43:08Z\",\"status\":495942092,\"statusMessage\":\"kjpdnjzhajo\",\"stageHistory\":[{},{}]},\"provisioningState\":\"Deleting\"},\"extendedLocation\":{\"name\":\"uo\",\"type\":\"CustomLocation\"},\"eTag\":\"rimrs\",\"id\":\"teecjmeislst\",\"name\":\"asylwx\",\"type\":\"zaum\"}],\"nextLink\":\"oohgu\"}")
            .toObject(ExecutionListResult.class);
        Assertions.assertEquals("nhxk", model.value().get(0).properties().workflowVersionId());
        Assertions.assertEquals("gukkjqnvbroy", model.value().get(0).extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.value().get(0).extendedLocation().type());
        Assertions.assertEquals("oohgu", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class ExecutionPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ExecutionProperties model = BinaryData.fromString(
            "{\"workflowVersionId\":\"skawaoqvmmb\",\"specification\":{},\"status\":{\"updateTime\":\"2021-04-20T09:58:27Z\",\"status\":1516123032,\"statusMessage\":\"zmegnitgvk\",\"stageHistory\":[{\"status\":1806013013,\"statusMessage\":\"rfe\",\"stage\":\"ealzxwhcansymoyq\",\"nextstage\":\"wigdi\",\"errorMessage\":\"kbxgom\",\"isActive\":\"inactive\",\"inputs\":{},\"outputs\":{}},{\"status\":1426574768,\"statusMessage\":\"aeyyg\",\"stage\":\"akjsqz\",\"nextstage\":\"bezkgimsidxasic\",\"errorMessage\":\"yvvjskgfmo\",\"isActive\":\"active\",\"inputs\":{},\"outputs\":{}},{\"status\":789499857,\"statusMessage\":\"eaahhvjhhn\",\"stage\":\"zybbj\",\"nextstage\":\"dj\",\"errorMessage\":\"yxkyxvx\",\"isActive\":\"active\",\"inputs\":{},\"outputs\":{}},{\"status\":995606751,\"statusMessage\":\"jlageu\",\"stage\":\"lxunsmjbnkppxy\",\"nextstage\":\"nlsvxeiz\",\"errorMessage\":\"wklnsrmffeyc\",\"isActive\":\"active\",\"inputs\":{},\"outputs\":{}}]},\"provisioningState\":\"Canceled\"}")
            .toObject(ExecutionProperties.class);
        Assertions.assertEquals("skawaoqvmmb", model.workflowVersionId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ExecutionProperties model
            = new ExecutionProperties().withWorkflowVersionId("skawaoqvmmb").withSpecification(mapOf());
        model = BinaryData.fromObject(model).toObject(ExecutionProperties.class);
        Assertions.assertEquals("skawaoqvmmb", model.workflowVersionId());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionsCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Execution;
import com.azure.resourcemanager.workloadorchestration.models.ExecutionProperties;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ExecutionsCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"workflowVersionId\":\"a\",\"specification\":{},\"status\":{\"updateTime\":\"2021-07-30T03:54:50Z\",\"status\":190169721,\"statusMessage\":\"mkxettcsloj\",\"stageHistory\":[{\"status\":734161368,\"statusMessage\":\"qtoqxjhqxcsq\",\"stage\":\"kbtn\",\"nextstage\":\"rngl\",\"errorMessage\":\"biipsnawwlqkznx\",\"isActive\":\"active\",\"inputs\":{},\"outputs\":{}}]},\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"kwmuqqo\",\"type\":\"EdgeZone\"},\"eTag\":\"eiyglesrwvaexhdc\",\"id\":\"ceqnkbrupobehd\",\"name\":\"lj\",\"type\":\"acvumepj\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Execution response = manager.executions()
            .define("wmseharxifvqn")
            .withExistingVersion("hbkgfyrt", "gm", "mjpjscdfpdqwty", "ev")
            .withProperties(new ExecutionProperties().withWorkflowVersionId("tmbpjp").withSpecification(mapOf()))
            .withExtendedLocation(new ExtendedLocation().withName("lf").withType(ExtendedLocationType.EDGE_ZONE))
            .create();

        Assertions.assertEquals("a", response.properties().workflowVersionId());
        Assertions.assertEquals("kwmuqqo", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.extendedLocation().type());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionsGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Execution;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ExecutionsGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"workflowVersionId\":\"ibuyvpirf\",\"specification\":{},\"status\":{\"updateTime\":\"2021-01-03T00:43:50Z\",\"status\":1671411460,\"statusMessage\":\"sbede\",\"stageHistory\":[{\"status\":160688731,\"statusMessage\":\"bhxv\",\"stage\":\"nul\",\"nextstage\":\"nhj\",\"errorMessage\":\"dyznfajsvks\",\"isActive\":\"inactive\",\"inputs\":{},\"outputs\":{}},{\"status\":1522602449,\"statusMessage\":\"hjrliizjixlqfh\",\"stage\":\"kwabsolronqq\",\"nextstage\":\"gn\",\"errorMessage\":\"xsjxtelexhvuqboz\",\"isActive\":\"active\",\"inputs\":{},\"outputs\":{}}]},\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"uzlbcnn\",\"type\":\"EdgeZone\"},\"eTag\":\"nx\",\"id\":\"qytl\",\"name\":\"hd\",\"type\":\"z\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Execution response = manager.executions()
            .getWithResponse("wvpsoz", "iihjriybmrzo", "pnx", "dvwnjkgvfnmxa", "rsqftib",
                com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("ibuyvpirf", response.properties().workflowVersionId());
        Assertions.assertEquals("uzlbcnn", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionsListByWorkflowVersionMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Execution;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class ExecutionsListByWorkflowVersionMockTests {
    @Test
    public void testListByWorkflowVersion() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"workflowVersionId\":\"kiwrsiw\",\"specification\":{},\"status\":{\"updateTime\":\"2021-09-30T22:56:34Z\",\"status\":980511476,\"statusMessage\":\"rra\",\"stageHistory\":[{\"status\":742764824,\"statusMessage\":\"uehogdd\",\"stage\":\"bcbgydlqidywmhm\",\"nextstage\":\"yrilkfb\",\"errorMessage\":\"qqxvztpbn\",\"isActive\":\"inactive\",\"inputs\":{},\"outputs\":{}},{\"status\":222029368,\"statusMessage\":\"lswbnf\",\"stage\":\"epl\",\"nextstage\":\"qjn\",\"errorMessage\":\"zygleexahvm\",\"isActive\":\"active\",\"inputs\":{},\"outputs\":{}}]},\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"csjjzyvoaqajuve\",\"type\":\"CustomLocation\"},\"eTag\":\"tdmkrrbhmpful\",\"id\":\"efgybpmfbfununmp\",\"name\":\"krvfyifkdschl\",\"type\":\"vfictnkjjwgcwn\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Execution> response = manager.executions()
            .listByWorkflowVersion("yckzex", "xak", "kywymxgaabj", "dtfohfaog", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("kiwrsiw", response.iterator().next().properties().workflowVersionId());
        Assertions.assertEquals("csjjzyvoaqajuve", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION,
            response.iterator().next().extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ExecutionStatusTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExecutionStatus;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;

public final class ExecutionStatusTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ExecutionStatus model = BinaryData.fromString(
            "{\"updateTime\":\"2021-07-18T14:17:15Z\",\"status\":1780956876,\"statusMessage\":\"mmxqiekkkzddrtk\",\"stageHistory\":[{\"status\":1241768286,\"statusMessage\":\"xv\",\"stage\":\"refdee\",\"nextstage\":\"ecuijpxtxs\",\"errorMessage\":\"prtujwsawdd\",\"isActive\":\"inactive\",\"inputs\":{},\"outputs\":{}},{\"status\":1148508080,\"statusMessage\":\"tvtzeexavoxtfg\",\"stage\":\"cd\",\"nextstage\":\"qbw\",\"errorMessage\":\"pqtgsfjac\",\"isActive\":\"inactive\",\"inputs\":{},\"outputs\":{}}]}")
            .toObject(ExecutionStatus.class);
        Assertions.assertEquals(OffsetDateTime.parse("2021-07-18T14:17:15Z"), model.updateTime());
        Assertions.assertEquals(1780956876, model.status());
        Assertions.assertEquals("mmxqiekkkzddrtk", model.statusMessage());
        Assertions.assertEquals(1241768286, model.stageHistory().get(0).status());
        Assertions.assertEquals("xv", model.stageHistory().get(0).statusMessage());
        Assertions.assertEquals("refdee", model.stageHistory().get(0).stage());
        Assertions.assertEquals("ecuijpxtxs", model.stageHistory().get(0).nextstage());
        Assertions.assertEquals("prtujwsawdd", model.stageHistory().get(0).errorMessage());
        Assertions.assertEquals(ActiveState.INACTIVE, model.stageHistory().get(0).isActive());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ExtendedLocationTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import org.junit.jupiter.api.Assertions;

public final class ExtendedLocationTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ExtendedLocation model
            = BinaryData.fromString("{\"name\":\"ynnaam\",\"type\":\"EdgeZone\"}").toObject(ExtendedLocation.class);
        Assertions.assertEquals("ynnaam", model.name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.type());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ExtendedLocation model = new ExtendedLocation().withName("ynnaam").withType(ExtendedLocationType.EDGE_ZONE);
        model = BinaryData.fromObject(model).toObject(ExtendedLocation.class);
        Assertions.assertEquals("ynnaam", model.name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/HierarchyTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.Hierarchy;
import org.junit.jupiter.api.Assertions;

public final class HierarchyTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        Hierarchy model = BinaryData.fromString("{\"name\":\"gfdgugeyzi\",\"description\":\"grkyuizabsnmfpph\"}")
            .toObject(Hierarchy.class);
        Assertions.assertEquals("gfdgugeyzi", model.name());
        Assertions.assertEquals("grkyuizabsnmfpph", model.description());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        Hierarchy model = new Hierarchy().withName("gfdgugeyzi").withDescription("grkyuizabsnmfpph");
        model = BinaryData.fromObject(model).toObject(Hierarchy.class);
        Assertions.assertEquals("gfdgugeyzi", model.name());
        Assertions.assertEquals("grkyuizabsnmfpph", model.description());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstallSolutionParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.InstallSolutionParameter;
import org.junit.jupiter.api.Assertions;

public final class InstallSolutionParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        InstallSolutionParameter model
            = BinaryData.fromString("{\"solutionVersionId\":\"gygev\"}").toObject(InstallSolutionParameter.class);
        Assertions.assertEquals("gygev", model.solutionVersionId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        InstallSolutionParameter model = new InstallSolutionParameter().withSolutionVersionId("gygev");
        model = BinaryData.fromObject(model).toObject(InstallSolutionParameter.class);
        Assertions.assertEquals("gygev", model.solutionVersionId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstanceHistoriesGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.InstanceHistory;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class InstanceHistoriesGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"solutionVersion\":{\"solutionVersionId\":\"xe\",\"specification\":{}},\"target\":{\"targetId\":\"bormcqmiciijqpkz\",\"targetSpecification\":{},\"solutionScope\":\"xjmcsmyqwixvcpw\"},\"solutionScope\":\"wy\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"active\",\"interval\":\"alickduoi\"},\"status\":{\"lastModified\":\"2021-02-12T08:45:06Z\",\"deployed\":947599262,\"expectedRunningJobId\":1704599538,\"runningJobId\":384634481,\"status\":\"rwzawnvs\",\"statusDetails\":\"fhzag\",\"generation\":2116581743,\"targetStatuses\":[{\"name\":\"vdimwrzregzgy\",\"status\":\"utrwpweryekz\",\"componentStatuses\":[{},{}]},{\"name\":\"eotta\",\"status\":\"yos\",\"componentStatuses\":[{},{}]}]},\"provisioningState\":\"Failed\"},\"extendedLocation\":{\"name\":\"jtfvpndpmiljpn\",\"type\":\"CustomLocation\"},\"eTag\":\"udqll\",\"id\":\"auzpjlx\",\"name\":\"ehuxiqhzlraym\",\"type\":\"zxlskihmxr\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        InstanceHistory response = manager.instanceHistories()
            .getWithResponse("v", "atbwbqam", "e", "liys", "pkcvmwf", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals(ActiveState.ACTIVE, response.properties().activeState());
        Assertions.assertEquals("jtfvpndpmiljpn", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstanceHistoriesListByInstanceMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.InstanceHistory;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class InstanceHistoriesListByInstanceMockTests {
    @Test
    public void testListByInstance() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"solutionVersion\":{\"solutionVersionId\":\"orpravkjoges\",\"specification\":{}},\"target\":{\"targetId\":\"smjkwynqxaekqsy\",\"targetSpecification\":{},\"solutionScope\":\"tqpkevmy\"},\"solutionScope\":\"jcrspxklurcclfgx\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"inactive\",\"interval\":\"ytzpo\"},\"status\":{\"lastModified\":\"2021-06-06T14:38:21Z\",\"deployed\":1822498924,\"expectedRunningJobId\":1807994418,\"runningJobId\":467042544,\"status\":\"aupxvpi\",\"statusDetails\":\"f\",\"generation\":479705193,\"targetStatuses\":[{\"name\":\"zeyuubeidszl\",\"status\":\"toi\",\"componentStatuses\":[{},{},{},{}]},{\"name\":\"gvfltgvdihoynkr\",\"status\":\"etwkdrcyrucpc\",\"componentStatuses\":[{},{}]},{\"name\":\"zdqumoe\",\"status\":\"dnaienhqhskndnel\",\"componentStatuses\":[{}]},{\"name\":\"dlknwfoanniyop\",\"status\":\"xivcnrlyxnu\",\"componentStatuses\":[{},{},{},{}]}]},\"provisioningState\":\"Initialized\"},\"extendedLocation\":{\"name\":\"lkwq\",\"type\":\"EdgeZone\"},\"eTag\":\"vbqsdt\",\"id\":\"bctvivuzqym\",\"name\":\"uo\",\"type\":\"o\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<InstanceHistory> response = manager.instanceHistories()
            .listByInstance("dsajrednwyysh", "uwg", "evuafpwzyifrk", "wltxeqipxgzdyims",
                com.azure.core.util.Context.NONE);

        Assertions.assertEquals(ActiveState.ACTIVE, response.iterator().next().properties().activeState());
        Assertions.assertEquals("lkwq", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.iterator().next().extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstanceHistoryInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceHistoryInner;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import org.junit.jupiter.api.Assertions;

public final class InstanceHistoryInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        InstanceHistoryInner model = BinaryData.fromString(
            "{\"properties\":{\"solutionVersion\":{\"solutionVersionId\":\"scyhwz\",\"specification\":{}},\"target\":{\"targetId\":\"ujb\",\"targetSpecification\":{},\"solutionScope\":\"vzzbtdcq\"},\"solutionScope\":\"niyujv\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"inactive\",\"interval\":\"shfssnrbgyef\"},\"status\":{\"lastModified\":\"2021-08-04T00:45:18Z\",\"deployed\":1164354320,\"expectedRunningJobId\":225590692,\"runningJobId\":800665018,\"status\":\"nc\",\"statusDetails\":\"mrfhirctymox\",\"generation\":849605054,\"targetStatuses\":[{\"name\":\"iwyczuh\",\"status\":\"cpqjlihhyu\",\"componentStatuses\":[{},{},{},{}]},{\"name\":\"asdvl\",\"status\":\"wdgzxulucv\",\"componentStatuses\":[{},{},{},{}]}]},\"provisioningState\":\"Initialized\"},\"extendedLocation\":{\"name\":\"euzvx\",\"type\":\"CustomLocation\"},\"eTag\":\"sjnhn\",\"id\":\"xifqjzgxm\",\"name\":\"hu\",\"type\":\"lw\"}")
            .toObject(InstanceHistoryInner.class);
        Assertions.assertEquals(ActiveState.ACTIVE, model.properties().activeState());
        Assertions.assertEquals("euzvx", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstanceHistoryListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.InstanceHistoryListResult;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import org.junit.jupiter.api.Assertions;

public final class InstanceHistoryListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        InstanceHistoryListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"solutionVersion\":{\"solutionVersionId\":\"dlwwqfbumlkxt\",\"specification\":{}},\"target\":{\"targetId\":\"smlmbtxhwgfwsrta\",\"targetSpecification\":{},\"solutionScope\":\"zbrhubskhudyg\"},\"solutionScope\":\"okkqfqjbvleo\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"active\",\"interval\":\"iqtqzfavyvnq\"},\"status\":{\"lastModified\":\"2021-07-18T06:03:13Z\",\"deployed\":1053197687,\"expectedRunningJobId\":1877295480,\"runningJobId\":1922609600,\"status\":\"kq\",\"statusDetails\":\"qgzsles\",\"generation\":397447732,\"targetStatuses\":[{},{},{},{}]},\"provisioningState\":\"Deleting\"},\"extendedLocation\":{\"name\":\"tiewdj\",\"type\":\"EdgeZone\"},\"eTag\":\"quwrbehwag\",\"id\":\"buffkmrqemvvhm\",\"name\":\"tdrjfutacoebj\",\"type\":\"ewzcjznmwcp\"},{\"properties\":{\"solutionVersion\":{\"solutionVersionId\":\"aadraufactkahz\",\"specification\":{}},\"target\":{\"targetId\":\"j\",\"targetSpecification\":{},\"solutionScope\":\"xps\"},\"solutionScope\":\"eekulfgslqubkwd\",\"activeState\":\"inactive\",\"reconciliationPolicy\":{\"state\":\"inactive\",\"interval\":\"sutujba\"},\"status\":{\"lastModified\":\"2021-08-28T04:22:09Z\",\"deployed\":1813394757,\"expectedRunningJobId\":1747811781,\"runningJobId\":1064399622,\"status\":\"lnorwmdu\",\"statusDetails\":\"pklvxw\",\"generation\":1194335789,\"targetStatuses\":[{},{}]},\"provisioningState\":\"Initialized\"},\"extendedLocation\":{\"name\":\"qchiszep\",\"type\":\"EdgeZone\"},\"eTag\":\"jcrxgibbdaxcon\",\"id\":\"zauorsuk\",\"name\":\"kwbqplhlvnuu\",\"type\":\"pzlrphw\"},{\"properties\":{\"solutionVersion\":{\"solutionVersionId\":\"l\",\"specification\":{}},\"target\":{\"targetId\":\"uqdunvmnnrwrbi\",\"targetSpecification\":{},\"solutionScope\":\"alywjhhgdn\"},\"solutionScope\":\"msi\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"active\",\"interval\":\"loxggdufiqn\"},\"status\":{\"lastModified\":\"2021-06-04T07:32:04Z\",\"deployed\":339501706,\"expectedRunningJobId\":1581273229,\"runningJobId\":886290907,\"status\":\"vcyy\",\"statusDetails\":\"fgdo\",\"generation\":1738680873,\"targetStatuses\":[{},{},{}]},\"provisioningState\":\"InProgress\"},\"extendedLocation\":{\"name\":\"ipwoqonmacjek\",\"type\":\"EdgeZone\"},\"eTag\":\"shqvcimpev\",\"id\":\"mblrrilbywd\",\"name\":\"smiccwrwfscj\",\"type\":\"n\"}],\"nextLink\":\"szqujizdvoq\"}")
            .toObject(InstanceHistoryListResult.class);
        Assertions.assertEquals(ActiveState.ACTIVE, model.value().get(0).properties().activeState());
        Assertions.assertEquals("tiewdj", model.value().get(0).extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.value().get(0).extendedLocation().type());
        Assertions.assertEquals("szqujizdvoq", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstanceHistoryPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.InstanceHistoryProperties;
import org.junit.jupiter.api.Assertions;

public final class InstanceHistoryPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        InstanceHistoryProperties model = BinaryData.fromString(
            "{\"solutionVersion\":{\"solutionVersionId\":\"esutrgjupauutpw\",\"specification\":{}},\"target\":{\"targetId\":\"hej\",\"targetSpecification\":{},\"solutionScope\":\"pnfqntcyp\"},\"solutionScope\":\"jv\",\"activeState\":\"inactive\",\"reconciliationPolicy\":{\"state\":\"inactive\",\"interval\":\"kslircizjxvydfc\"},\"status\":{\"lastModified\":\"2021-04-08T10:04:22Z\",\"deployed\":751635247,\"expectedRunningJobId\":733359450,\"runningJobId\":788840144,\"status\":\"ftumrtwnawjslbiw\",\"statusDetails\":\"jgcyztsfmznba\",\"generation\":419128665,\"targetStatuses\":[{\"name\":\"qnrnrpxehuwryk\",\"status\":\"aifmvikl\",\"componentStatuses\":[{\"name\":\"khbejdznxc\",\"status\":\"srhnjivo\"}]},{\"name\":\"tnovqfzgemjdftul\",\"status\":\"tduceamt\",\"componentStatuses\":[{\"name\":\"o\",\"status\":\"jw\"}]},{\"name\":\"wqiok\",\"status\":\"sx\",\"componentStatuses\":[{\"name\":\"sv\",\"status\":\"jpr\"},{\"name\":\"wcfzqljyxgt\",\"status\":\"heyd\"}]},{\"name\":\"dshmkxmaehvbbx\",\"status\":\"iplt\",\"componentStatuses\":[{\"name\":\"baxk\",\"status\":\"ywrckp\"}]}]},\"provisioningState\":\"Canceled\"}")
            .toObject(InstanceHistoryProperties.class);
        Assertions.assertEquals(ActiveState.INACTIVE, model.activeState());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstanceInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.InstanceInner;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.InstanceProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;
import org.junit.jupiter.api.Assertions;

public final class InstanceInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        InstanceInner model = BinaryData.fromString(
            "{\"properties\":{\"solutionVersionId\":\"rpw\",\"targetId\":\"xeznoi\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"active\",\"interval\":\"w\"},\"solutionScope\":\"kpnb\",\"status\":{\"lastModified\":\"2021-03-01T09:58:07Z\",\"deployed\":552544194,\"expectedRunningJobId\":2849760,\"runningJobId\":4171905,\"status\":\"fhsxttaugz\",\"statusDetails\":\"faazpxdtnkdmkqjj\",\"generation\":1784311457,\"targetStatuses\":[{\"name\":\"rkpyouaibrebqaay\",\"status\":\"kixqtnqtt\",\"componentStatuses\":[{},{}]}]},\"deploymentTimestampEpoch\":6158670602245383291,\"provisioningState\":\"Failed\"},\"extendedLocation\":{\"name\":\"kpj\",\"type\":\"CustomLocation\"},\"eTag\":\"m\",\"id\":\"d\",\"name\":\"tmmjihyeozph\",\"type\":\"wau\"}")
            .toObject(InstanceInner.class);
        Assertions.assertEquals("rpw", model.properties().solutionVersionId());
        Assertions.assertEquals("xeznoi", model.properties().targetId());
        Assertions.assertEquals(ActiveState.ACTIVE, model.properties().activeState());
        Assertions.assertEquals(ReconciliationState.ACTIVE, model.properties().reconciliationPolicy().state());
        Assertions.assertEquals("w", model.properties().reconciliationPolicy().interval());
        Assertions.assertEquals("kpnb", model.properties().solutionScope());
        Assertions.assertEquals("kpj", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.extendedLocation().type());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        InstanceInner model = new InstanceInner()
            .withProperties(new InstanceProperties().withSolutionVersionId("rpw")
                .withTargetId("xeznoi")
                .withActiveState(ActiveState.ACTIVE)
                .withReconciliationPolicy(
                    new ReconciliationPolicyProperties().withState(ReconciliationState.ACTIVE).withInterval("w"))
                .withSolutionScope("kpnb"))
            .withExtendedLocation(
                new ExtendedLocation().withName("kpj").withType(ExtendedLocationType.CUSTOM_LOCATION));
        model = BinaryData.fromObject(model).toObject(InstanceInner.class);
        Assertions.assertEquals("rpw", model.properties().solutionVersionId());
        Assertions.assertEquals("xeznoi", model.properties().targetId());
        Assertions.assertEquals(ActiveState.ACTIVE, model.properties().activeState());
        Assertions.assertEquals(ReconciliationState.ACTIVE, model.properties().reconciliationPolicy().state());
        Assertions.assertEquals("w", model.properties().reconciliationPolicy().interval());
        Assertions.assertEquals("kpnb", model.properties().solutionScope());
        Assertions.assertEquals("kpj", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstanceListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.InstanceListResult;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;
import org.junit.jupiter.api.Assertions;

public final class InstanceListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        InstanceListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"solutionVersionId\":\"rghxjb\",\"targetId\":\"hqxvcxgfrpdsofbs\",\"activeState\":\"inactive\",\"reconciliationPolicy\":{\"state\":\"inactive\",\"interval\":\"buswdvzyy\"},\"solutionScope\":\"cnunvjsr\",\"status\":{\"lastModified\":\"2021-04-02T14:41:37Z\",\"deployed\":1116646616,\"expectedRunningJobId\":1280835844,\"runningJobId\":204322777,\"status\":\"kyzirtxdyux\",\"statusDetails\":\"jntpsewgioilqu\",\"generation\":1456439071,\"targetStatuses\":[{},{},{}]},\"deploymentTimestampEpoch\":3410093693766084456,\"provisioningState\":\"Canceled\"},\"extendedLocation\":{\"name\":\"xorgg\",\"type\":\"EdgeZone\"},\"eTag\":\"yaomtb\",\"id\":\"havgrvk\",\"name\":\"fo\",\"type\":\"jzhpjbibgjmfx\"}],\"nextLink\":\"vfcluyovwxnbkfe\"}")
            .toObject(InstanceListResult.class);
        Assertions.assertEquals("rghxjb", model.value().get(0).properties().solutionVersionId());
        Assertions.assertEquals("hqxvcxgfrpdsofbs", model.value().get(0).properties().targetId());
        Assertions.assertEquals(ActiveState.INACTIVE, model.value().get(0).properties().activeState());
        Assertions.assertEquals(ReconciliationState.INACTIVE,
            model.value().get(0).properties().reconciliationPolicy().state());
        Assertions.assertEquals("buswdvzyy", model.value().get(0).properties().reconciliationPolicy().interval());
        Assertions.assertEquals("cnunvjsr", model.value().get(0).properties().solutionScope());
        Assertions.assertEquals("xorgg", model.value().get(0).extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.value().get(0).extendedLocation().type());
        Assertions.assertEquals("vfcluyovwxnbkfe", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstancePropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.InstanceProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;
import org.junit.jupiter.api.Assertions;

public final class InstancePropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        InstanceProperties model = BinaryData.fromString(
            "{\"solutionVersionId\":\"qncygupkvi\",\"targetId\":\"mdscwxqupev\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"active\",\"interval\":\"otxhojujby\"},\"solutionScope\":\"lmcuvhixb\",\"status\":{\"lastModified\":\"2021-05-06T10:55:08Z\",\"deployed\":32806532,\"expectedRunningJobId\":1015582593,\"runningJobId\":1461211866,\"status\":\"o\",\"statusDetails\":\"ttpkiwkkbnujrywv\",\"generation\":209065244,\"targetStatuses\":[{\"name\":\"ncu\",\"status\":\"oiwiithtywub\",\"componentStatuses\":[{\"name\":\"h\",\"status\":\"knfd\"},{\"name\":\"wjchrdg\",\"status\":\"hxumwctondzj\"},{\"name\":\"udfdlwgg\",\"status\":\"sb\"}]},{\"name\":\"ovvtgseinqfiu\",\"status\":\"qknp\",\"componentStatuses\":[{\"name\":\"epttwqmsniff\",\"status\":\"mqnrojlpijnkr\"},{\"name\":\"rddh\",\"status\":\"atiz\"},{\"name\":\"onasxifto\",\"status\":\"yzhftwesgogczh\"}]}]},\"deploymentTimestampEpoch\":8192981272541420643,\"provisioningState\":\"Canceled\"}")
            .toObject(InstanceProperties.class);
        Assertions.assertEquals("qncygupkvi", model.solutionVersionId());
        Assertions.assertEquals("mdscwxqupev", model.targetId());
        Assertions.assertEquals(ActiveState.ACTIVE, model.activeState());
        Assertions.assertEquals(ReconciliationState.ACTIVE, model.reconciliationPolicy().state());
        Assertions.assertEquals("otxhojujby", model.reconciliationPolicy().interval());
        Assertions.assertEquals("lmcuvhixb", model.solutionScope());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        InstanceProperties model = new InstanceProperties().withSolutionVersionId("qncygupkvi")
            .withTargetId("mdscwxqupev")
            .withActiveState(ActiveState.ACTIVE)
            .withReconciliationPolicy(
                new ReconciliationPolicyProperties().withState(ReconciliationState.ACTIVE).withInterval("otxhojujby"))
            .withSolutionScope("lmcuvhixb");
        model = BinaryData.fromObject(model).toObject(InstanceProperties.class);
        Assertions.assertEquals("qncygupkvi", model.solutionVersionId());
        Assertions.assertEquals("mdscwxqupev", model.targetId());
        Assertions.assertEquals(ActiveState.ACTIVE, model.activeState());
        Assertions.assertEquals(ReconciliationState.ACTIVE, model.reconciliationPolicy().state());
        Assertions.assertEquals("otxhojujby", model.reconciliationPolicy().interval());
        Assertions.assertEquals("lmcuvhixb", model.solutionScope());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstancesCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.Instance;
import com.azure.resourcemanager.workloadorchestration.models.InstanceProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class InstancesCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"solutionVersionId\":\"opagttmvmmag\",\"targetId\":\"aqylkjztji\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"inactive\",\"interval\":\"gmxitpfi\"},\"solutionScope\":\"cpdltkrlg\",\"status\":{\"lastModified\":\"2021-11-01T19:23:43Z\",\"deployed\":1780203290,\"expectedRunningJobId\":1405016434,\"runningJobId\":1161865517,\"status\":\"efz\",\"statusDetails\":\"mpheqdur\",\"generation\":2146493282,\"targetStatuses\":[{\"name\":\"fyoum\",\"status\":\"kyeclcdigpta\",\"componentStatuses\":[{}]},{\"name\":\"mqxuc\",\"status\":\"ijo\",\"componentStatuses\":[{},{},{}]}]},\"deploymentTimestampEpoch\":7203756374062354312,\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"yzyzjd\",\"type\":\"EdgeZone\"},\"eTag\":\"jb\",\"id\":\"jeaoqaqbz\",\"name\":\"yh\",\"type\":\"w\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Instance response = manager.instances()
            .define("ltcoqc")
            .withExistingSolution("alwvskbu", "z", "caqt")
            .withProperties(new InstanceProperties().withSolutionVersionId("pdsxzakuejkm")
                .withTargetId("bizt")
                .withActiveState(ActiveState.ACTIVE)
                .withReconciliationPolicy(new ReconciliationPolicyProperties().withState(ReconciliationState.ACTIVE)
                    .withInterval("vovjufycsjmlbe"))
                .withSolutionScope("ej"))
            .withExtendedLocation(new ExtendedLocation().withName("gvxvatv").withType(ExtendedLocationType.EDGE_ZONE))
            .create();

        Assertions.assertEquals("opagttmvmmag", response.properties().solutionVersionId());
        Assertions.assertEquals("aqylkjztji", response.properties().targetId());
        Assertions.assertEquals(ActiveState.ACTIVE, response.properties().activeState());
        Assertions.assertEquals(ReconciliationState.INACTIVE, response.properties().reconciliationPolicy().state());
        Assertions.assertEquals("gmxitpfi", response.properties().reconciliationPolicy().interval());
        Assertions.assertEquals("cpdltkrlg", response.properties().solutionScope());
        Assertions.assertEquals("yzyzjd", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstancesGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.Instance;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class InstancesGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"solutionVersionId\":\"s\",\"targetId\":\"grbjbxsjybvitvqk\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"inactive\",\"interval\":\"umtggmuwdchozfn\"},\"solutionScope\":\"exlvxnoakiz\",\"status\":{\"lastModified\":\"2021-09-09T07:48:02Z\",\"deployed\":1220529720,\"expectedRunningJobId\":106818765,\"runningJobId\":1377558622,\"status\":\"wiguyxlyk\",\"statusDetails\":\"hvxzcwxhmp\",\"generation\":338411027,\"targetStatuses\":[{\"name\":\"xaonwivkcqh\",\"status\":\"hxknlccrmmkyupi\",\"componentStatuses\":[{},{},{},{}]}]},\"deploymentTimestampEpoch\":7739164189837902113,\"provisioningState\":\"Deleting\"},\"extendedLocation\":{\"name\":\"kfq\",\"type\":\"EdgeZone\"},\"eTag\":\"em\",\"id\":\"ldudxjascowv\",\"name\":\"djkpdxph\",\"type\":\"kk\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Instance response = manager.instances()
            .getWithResponse("wrso", "pl", "dbmairrhvhfnr", "cwnpqigtuujwouhd", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("s", response.properties().solutionVersionId());
        Assertions.assertEquals("grbjbxsjybvitvqk", response.properties().targetId());
        Assertions.assertEquals(ActiveState.ACTIVE, response.properties().activeState());
        Assertions.assertEquals(ReconciliationState.INACTIVE, response.properties().reconciliationPolicy().state());
        Assertions.assertEquals("umtggmuwdchozfn", response.properties().reconciliationPolicy().interval());
        Assertions.assertEquals("exlvxnoakiz", response.properties().solutionScope());
        Assertions.assertEquals("kfq", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/InstancesListBySolutionMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.Instance;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class InstancesListBySolutionMockTests {
    @Test
    public void testListBySolution() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"solutionVersionId\":\"luqw\",\"targetId\":\"ulsutrjbhxy\",\"activeState\":\"active\",\"reconciliationPolicy\":{\"state\":\"inactive\",\"interval\":\"ezvqq\"},\"solutionScope\":\"drftbcvexreuquo\",\"status\":{\"lastModified\":\"2021-01-27T00:09:21Z\",\"deployed\":1013930183,\"expectedRunningJobId\":1432269012,\"runningJobId\":949120362,\"status\":\"gkhyxvrqtvbczsu\",\"statusDetails\":\"dgglmepjpfs\",\"generation\":557010764,\"targetStatuses\":[{\"name\":\"ngpszngafpg\",\"status\":\"kvec\",\"componentStatuses\":[{},{},{}]}]},\"deploymentTimestampEpoch\":2612565558576892207,\"provisioningState\":\"InProgress\"},\"extendedLocation\":{\"name\":\"yedmzrgj\",\"type\":\"EdgeZone\"},\"eTag\":\"nub\",\"id\":\"itpkpztrgdg\",\"name\":\"vcoqraswugyxpqi\",\"type\":\"we\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Instance> response
            = manager.instances().listBySolution("nmgzvyfijdkzuqnw", "it", "uqoly", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("luqw", response.iterator().next().properties().solutionVersionId());
        Assertions.assertEquals("ulsutrjbhxy", response.iterator().next().properties().targetId());
        Assertions.assertEquals(ActiveState.ACTIVE, response.iterator().next().properties().activeState());
        Assertions.assertEquals(ReconciliationState.INACTIVE,
            response.iterator().next().properties().reconciliationPolicy().state());
        Assertions.assertEquals("ezvqq", response.iterator().next().properties().reconciliationPolicy().interval());
        Assertions.assertEquals("drftbcvexreuquo", response.iterator().next().properties().solutionScope());
        Assertions.assertEquals("yedmzrgj", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.iterator().next().extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/JobParameterBaseTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.JobParameterBase;

public final class JobParameterBaseTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        JobParameterBase model
            = BinaryData.fromString("{\"jobType\":\"JobParameterBase\"}").toObject(JobParameterBase.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/JobStepStatisticsBaseTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.JobStepStatisticsBase;

public final class JobStepStatisticsBaseTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        JobStepStatisticsBase model = BinaryData.fromString("{\"statisticsType\":\"JobStepStatisticsBase\"}")
            .toObject(JobStepStatisticsBase.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ReconciliationPolicyPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationPolicyProperties;
import com.azure.resourcemanager.workloadorchestration.models.ReconciliationState;
import org.junit.jupiter.api.Assertions;

public final class ReconciliationPolicyPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ReconciliationPolicyProperties model
            = BinaryData.fromString("{\"state\":\"inactive\",\"interval\":\"gnyhmossxkkg\"}")
                .toObject(ReconciliationPolicyProperties.class);
        Assertions.assertEquals(ReconciliationState.INACTIVE, model.state());
        Assertions.assertEquals("gnyhmossxkkg", model.interval());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        ReconciliationPolicyProperties model
            = new ReconciliationPolicyProperties().withState(ReconciliationState.INACTIVE).withInterval("gnyhmossxkkg");
        model = BinaryData.fromObject(model).toObject(ReconciliationPolicyProperties.class);
        Assertions.assertEquals(ReconciliationState.INACTIVE, model.state());
        Assertions.assertEquals("gnyhmossxkkg", model.interval());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/RemoveRevisionParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.RemoveRevisionParameter;
import org.junit.jupiter.api.Assertions;

public final class RemoveRevisionParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        RemoveRevisionParameter model
            = BinaryData.fromString("{\"solutionTemplateId\":\"txon\",\"solutionVersion\":\"mtsavjcbpwxqp\"}")
                .toObject(RemoveRevisionParameter.class);
        Assertions.assertEquals("txon", model.solutionTemplateId());
        Assertions.assertEquals("mtsavjcbpwxqp", model.solutionVersion());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        RemoveRevisionParameter model
            = new RemoveRevisionParameter().withSolutionTemplateId("txon").withSolutionVersion("mtsavjcbpwxqp");
        model = BinaryData.fromObject(model).toObject(RemoveRevisionParameter.class);
        Assertions.assertEquals("txon", model.solutionTemplateId());
        Assertions.assertEquals("mtsavjcbpwxqp", model.solutionVersion());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/RemoveVersionResponseInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.RemoveVersionResponseInner;
import org.junit.jupiter.api.Assertions;

public final class RemoveVersionResponseInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        RemoveVersionResponseInner model
            = BinaryData.fromString("{\"status\":\"bifpikxwczb\"}").toObject(RemoveVersionResponseInner.class);
        Assertions.assertEquals("bifpikxwczb", model.status());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/ResolvedConfigurationInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.ResolvedConfigurationInner;
import org.junit.jupiter.api.Assertions;

public final class ResolvedConfigurationInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        ResolvedConfigurationInner model
            = BinaryData.fromString("{\"configuration\":\"oz\"}").toObject(ResolvedConfigurationInner.class);
        Assertions.assertEquals("oz", model.configuration());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaProperties;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class SchemaInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaInner model = BinaryData.fromString(
            "{\"properties\":{\"currentVersion\":\"fsqesaagdfmglzlh\",\"provisioningState\":\"Deleting\"},\"eTag\":\"f\",\"location\":\"mrvktsizntoc\",\"tags\":{\"kfo\":\"ouajpsqucmpoyf\"},\"id\":\"knygjofjddeq\",\"name\":\"rd\",\"type\":\"upewnwreitjzy\"}")
            .toObject(SchemaInner.class);
        Assertions.assertEquals("mrvktsizntoc", model.location());
        Assertions.assertEquals("ouajpsqucmpoyf", model.tags().get("kfo"));
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SchemaInner model = new SchemaInner().withLocation("mrvktsizntoc")
            .withTags(mapOf("kfo", "ouajpsqucmpoyf"))
            .withProperties(new SchemaProperties());
        model = BinaryData.fromObject(model).toObject(SchemaInner.class);
        Assertions.assertEquals("mrvktsizntoc", model.location());
        Assertions.assertEquals("ouajpsqucmpoyf", model.tags().get("kfo"));
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaListResult;
import org.junit.jupiter.api.Assertions;

public final class SchemaListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"currentVersion\":\"pqxu\",\"provisioningState\":\"Canceled\"},\"eTag\":\"qniwbybrkxvdumj\",\"location\":\"tfwvukxgaudc\",\"tags\":{\"jcny\":\"h\",\"kryhtnapczwlokj\":\"j\",\"jnchgej\":\"emkkvnipjox\"},\"id\":\"podmailzydehojwy\",\"name\":\"huxinpmqnj\",\"type\":\"qwixjspro\"},{\"properties\":{\"currentVersion\":\"putegjvwmfd\",\"provisioningState\":\"Initialized\"},\"eTag\":\"mdvpjhulsu\",\"location\":\"mkjozkrwf\",\"tags\":{\"vwryoqpso\":\"odjpslwejd\",\"yffdfdos\":\"cctazakljlahbc\"},\"id\":\"gexpaojakhmsbz\",\"name\":\"hcrzevd\",\"type\":\"hlxaolthqtr\"},{\"properties\":{\"currentVersion\":\"bpf\",\"provisioningState\":\"Initialized\"},\"eTag\":\"n\",\"location\":\"v\",\"tags\":{\"it\":\"rwzoxxjtfelluwf\",\"qfpjk\":\"np\"},\"id\":\"lxofpdvhpfxxypin\",\"name\":\"nmayhuybb\",\"type\":\"podepoo\"}],\"nextLink\":\"nuvamiheogna\"}")
            .toObject(SchemaListResult.class);
        Assertions.assertEquals("tfwvukxgaudc", model.value().get(0).location());
        Assertions.assertEquals("h", model.value().get(0).tags().get("jcny"));
        Assertions.assertEquals("nuvamiheogna", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SchemaProperties;

public final class SchemaPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaProperties model
            = BinaryData.fromString("{\"currentVersion\":\"usarhmofc\",\"provisioningState\":\"Failed\"}")
                .toObject(SchemaProperties.class);
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SchemaProperties model = new SchemaProperties();
        model = BinaryData.fromObject(model).toObject(SchemaProperties.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaReferenceInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaReferenceInner;
import org.junit.jupiter.api.Assertions;

public final class SchemaReferenceInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaReferenceInner model = BinaryData.fromString(
            "{\"properties\":{\"schemaId\":\"e\",\"provisioningState\":\"Canceled\"},\"eTag\":\"fpubjibwwi\",\"id\":\"ohqkvpuvksgpls\",\"name\":\"kn\",\"type\":\"n\"}")
            .toObject(SchemaReferenceInner.class);
        Assertions.assertEquals("e", model.properties().schemaId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaReferenceListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaReferenceListResult;
import org.junit.jupiter.api.Assertions;

public final class SchemaReferenceListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaReferenceListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"schemaId\":\"orzihle\",\"provisioningState\":\"InProgress\"},\"eTag\":\"w\",\"id\":\"mslyzrpzbchckqqz\",\"name\":\"ioxiysuiizyn\",\"type\":\"edyatrwyhqmibzyh\"},{\"properties\":{\"schemaId\":\"tsmypyynpcdp\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"g\",\"id\":\"z\",\"name\":\"mabiknsorgjhxb\",\"type\":\"dtlwwrlkd\"},{\"properties\":{\"schemaId\":\"ncvokotllxdyhg\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"ogjltdtbnnhad\",\"id\":\"crkvcikhnv\",\"name\":\"amqgxqquezikyw\",\"type\":\"gxk\"},{\"properties\":{\"schemaId\":\"la\",\"provisioningState\":\"InProgress\"},\"eTag\":\"wuipiccjzkzivg\",\"id\":\"c\",\"name\":\"ayrhyrnx\",\"type\":\"mueedndrdvstk\"}],\"nextLink\":\"qtc\"}")
            .toObject(SchemaReferenceListResult.class);
        Assertions.assertEquals("orzihle", model.value().get(0).properties().schemaId());
        Assertions.assertEquals("qtc", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaReferencePropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SchemaReferenceProperties;
import org.junit.jupiter.api.Assertions;

public final class SchemaReferencePropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaReferenceProperties model
            = BinaryData.fromString("{\"schemaId\":\"synljphuopxodl\",\"provisioningState\":\"InProgress\"}")
                .toObject(SchemaReferenceProperties.class);
        Assertions.assertEquals("synljphuopxodl", model.schemaId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaReferencesGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.SchemaReference;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemaReferencesGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"schemaId\":\"flgbhgau\",\"provisioningState\":\"Canceled\"},\"eTag\":\"xmxufrsryjqgdk\",\"id\":\"ozo\",\"name\":\"oqbvjhvefgwbmqj\",\"type\":\"hntasfaymx\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        SchemaReference response = manager.schemaReferences()
            .getWithResponse("v", "hulrtywikdmhla", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("flgbhgau", response.properties().schemaId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaReferencesListByResourceGroupMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.SchemaReference;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemaReferencesListByResourceGroupMockTests {
    @Test
    public void testListByResourceGroup() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"schemaId\":\"kyojwyvfk\",\"provisioningState\":\"Initialized\"},\"eTag\":\"uahxs\",\"id\":\"jcmmzrrscub\",\"name\":\"wsdrnpxqwodif\",\"type\":\"jxcjrmmuabwib\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<SchemaReference> response
            = manager.schemaReferences().listByResourceGroup("ulpzealb", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("kyojwyvfk", response.iterator().next().properties().schemaId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Schema;
import com.azure.resourcemanager.workloadorchestration.models.SchemaProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemasCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"currentVersion\":\"pfbcunezzcez\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"yfwlwxjwet\",\"location\":\"sihclafzvaylp\",\"tags\":{\"mwqkchcxwaxf\":\"qqwzt\"},\"id\":\"w\",\"name\":\"jkjexf\",\"type\":\"eqvhpsylkk\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Schema response = manager.schemas()
            .define("bcblemb")
            .withRegion("swbzuwfmdurage")
            .withExistingResourceGroup("hfqpofv")
            .withTags(mapOf("igkxkbsazga", "vcjfelisdjubggb", "apvu", "gacyrcmjdmspo", "zjedmstkvnlv", "rylniofrzg",
                "ktwfa", "bcuiiz"))
            .withProperties(new SchemaProperties())
            .create();

        Assertions.assertEquals("sihclafzvaylp", response.location());
        Assertions.assertEquals("qqwzt", response.tags().get("mwqkchcxwaxf"));
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasCreateVersionMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemasCreateVersionMockTests {
    @Test
    public void testCreateVersion() throws Exception {
        String responseStr
            = "{\"properties\":{\"value\":\"gjkskyrioov\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"xwaabzmifrygznmm\",\"id\":\"ri\",\"name\":\"kzobgopxlhsln\",\"type\":\"lxieixynllxecwcr\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        SchemaVersion response = manager.schemas()
            .createVersion("zsvtuikzhajqgl", "fh",
                new SchemaVersionWithUpdateTypeInner().withUpdateType(UpdateType.PATCH)
                    .withVersion("ryxynqnzrd")
                    .withSchemaVersion(
                        new SchemaVersionInner().withProperties(new SchemaVersionProperties().withValue("ovw"))),
                com.azure.core.util.Context.NONE);

        Assertions.assertEquals("gjkskyrioov", response.properties().value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasGetByResourceGroupWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Schema;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemasGetByResourceGroupWithResponseMockTests {
    @Test
    public void testGetByResourceGroupWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"currentVersion\":\"dcdab\",\"provisioningState\":\"Canceled\"},\"eTag\":\"wyawbzasqbuc\",\"location\":\"gkyexaoguy\",\"tags\":{\"ault\":\"ids\"},\"id\":\"ijjumfq\",\"name\":\"azlnqnmcjngzqdqx\",\"type\":\"bjwgnyfus\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Schema response = manager.schemas()
            .getByResourceGroupWithResponse("kmfx", "pjwogqqno", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("gkyexaoguy", response.location());
        Assertions.assertEquals("ids", response.tags().get("ault"));
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasListByResourceGroupMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Schema;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemasListByResourceGroupMockTests {
    @Test
    public void testListByResourceGroup() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"currentVersion\":\"lkafhonqjuje\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"zvcpopm\",\"location\":\"lnwcltyjed\",\"tags\":{\"azuawx\":\"mlfmkqs\"},\"id\":\"z\",\"name\":\"puamwabzxr\",\"type\":\"xcushs\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Schema> response = manager.schemas().listByResourceGroup("tzh", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("lnwcltyjed", response.iterator().next().location());
        Assertions.assertEquals("mlfmkqs", response.iterator().next().tags().get("azuawx"));
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasListMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.Schema;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemasListMockTests {
    @Test
    public void testList() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"currentVersion\":\"ivmxyasfl\",\"provisioningState\":\"InProgress\"},\"eTag\":\"zwywako\",\"location\":\"knsmjblmljhlnymz\",\"tags\":{\"qqvxmvwfgtayxons\":\"yryuzcb\",\"cvsql\":\"peujlzqn\",\"yqo\":\"nzoibgsxgnx\",\"o\":\"mpqoxw\"},\"id\":\"dbxiqx\",\"name\":\"iiqbi\",\"type\":\"htmwwinh\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Schema> response = manager.schemas().list(com.azure.core.util.Context.NONE);

        Assertions.assertEquals("knsmjblmljhlnymz", response.iterator().next().location());
        Assertions.assertEquals("yryuzcb", response.iterator().next().tags().get("qqvxmvwfgtayxons"));
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemasRemoveVersionWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.RemoveVersionResponse;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemasRemoveVersionWithResponseMockTests {
    @Test
    public void testRemoveVersionWithResponse() throws Exception {
        String responseStr = "{\"status\":\"dwfmvigorqjb\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        RemoveVersionResponse response = manager.schemas()
            .removeVersionWithResponse("jphslhcaw", "u", new VersionParameter().withVersion("i"),
                com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("dwfmvigorqjb", response.status());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import org.junit.jupiter.api.Assertions;

public final class SchemaVersionInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaVersionInner model = BinaryData.fromString(
            "{\"properties\":{\"value\":\"kknryrtihf\",\"provisioningState\":\"Failed\"},\"eTag\":\"bpzvgn\",\"id\":\"symglzufcyz\",\"name\":\"ohdbihanufh\",\"type\":\"cbjy\"}")
            .toObject(SchemaVersionInner.class);
        Assertions.assertEquals("kknryrtihf", model.properties().value());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SchemaVersionInner model
            = new SchemaVersionInner().withProperties(new SchemaVersionProperties().withValue("kknryrtihf"));
        model = BinaryData.fromObject(model).toObject(SchemaVersionInner.class);
        Assertions.assertEquals("kknryrtihf", model.properties().value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SchemaVersionListResult;
import org.junit.jupiter.api.Assertions;

public final class SchemaVersionListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaVersionListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"value\":\"xth\",\"provisioningState\":\"InProgress\"},\"eTag\":\"si\",\"id\":\"evcciqihnhun\",\"name\":\"bwjzr\",\"type\":\"fygxgispemvtzfk\"},{\"properties\":{\"value\":\"ubljofxqe\",\"provisioningState\":\"Initialized\"},\"eTag\":\"e\",\"id\":\"hqjbasvmsmj\",\"name\":\"ulngsntn\",\"type\":\"ybkzgcwr\"}],\"nextLink\":\"lxxwrljdouskc\"}")
            .toObject(SchemaVersionListResult.class);
        Assertions.assertEquals("xth", model.value().get(0).properties().value());
        Assertions.assertEquals("lxxwrljdouskc", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import org.junit.jupiter.api.Assertions;

public final class SchemaVersionPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaVersionProperties model = BinaryData.fromString("{\"value\":\"a\",\"provisioningState\":\"Canceled\"}")
            .toObject(SchemaVersionProperties.class);
        Assertions.assertEquals("a", model.value());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SchemaVersionProperties model = new SchemaVersionProperties().withValue("a");
        model = BinaryData.fromObject(model).toObject(SchemaVersionProperties.class);
        Assertions.assertEquals("a", model.value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionsCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemaVersionsCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"value\":\"vnoamldseha\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"hhflzo\",\"id\":\"coxpelnjeta\",\"name\":\"ltsxoatf\",\"type\":\"g\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        SchemaVersion response = manager.schemaVersions()
            .define("ycucrwnamikzeb")
            .withExistingSchema("xqzv", "ers")
            .withProperties(new SchemaVersionProperties().withValue("bsmswziqgf"))
            .create();

        Assertions.assertEquals("vnoamldseha", response.properties().value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionsGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemaVersionsGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"value\":\"icgaao\",\"provisioningState\":\"Deleting\"},\"eTag\":\"aqutdewemxswvruu\",\"id\":\"zjgehkfkim\",\"name\":\"tixo\",\"type\":\"ffqyinlj\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        SchemaVersion response = manager.schemaVersions()
            .getWithResponse("hkbffmbm", "zjrgyww", "gjxsnptfu", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("icgaao", response.properties().value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionsListBySchemaMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersion;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SchemaVersionsListBySchemaMockTests {
    @Test
    public void testListBySchema() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"value\":\"lfcldu\",\"provisioningState\":\"Canceled\"},\"eTag\":\"rds\",\"id\":\"wcobie\",\"name\":\"stmninwjizcilng\",\"type\":\"gshejjtbxqmulux\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<SchemaVersion> response
            = manager.schemaVersions().listBySchema("epqw", "ixmonstshiyxg", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("lfcldu", response.iterator().next().properties().value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SchemaVersionWithUpdateTypeInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SchemaVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.SchemaVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import org.junit.jupiter.api.Assertions;

public final class SchemaVersionWithUpdateTypeInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SchemaVersionWithUpdateTypeInner model = BinaryData.fromString(
            "{\"updateType\":\"Minor\",\"version\":\"rkdtmlxh\",\"schemaVersion\":{\"properties\":{\"value\":\"uksjtxukcdmp\",\"provisioningState\":\"Deleting\"},\"eTag\":\"y\",\"id\":\"nzwuxzd\",\"name\":\"t\",\"type\":\"yrlhmwhfpmrqobm\"}}")
            .toObject(SchemaVersionWithUpdateTypeInner.class);
        Assertions.assertEquals(UpdateType.MINOR, model.updateType());
        Assertions.assertEquals("rkdtmlxh", model.version());
        Assertions.assertEquals("uksjtxukcdmp", model.schemaVersion().properties().value());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SchemaVersionWithUpdateTypeInner model = new SchemaVersionWithUpdateTypeInner().withUpdateType(UpdateType.MINOR)
            .withVersion("rkdtmlxh")
            .withSchemaVersion(
                new SchemaVersionInner().withProperties(new SchemaVersionProperties().withValue("uksjtxukcdmp")));
        model = BinaryData.fromObject(model).toObject(SchemaVersionWithUpdateTypeInner.class);
        Assertions.assertEquals(UpdateType.MINOR, model.updateType());
        Assertions.assertEquals("rkdtmlxh", model.version());
        Assertions.assertEquals("uksjtxukcdmp", model.schemaVersion().properties().value());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferenceInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SiteReferenceInner;
import com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties;
import org.junit.jupiter.api.Assertions;

public final class SiteReferenceInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SiteReferenceInner model = BinaryData.fromString(
            "{\"properties\":{\"siteId\":\"ybnnustg\",\"provisioningState\":\"Initialized\"},\"id\":\"nmgixh\",\"name\":\"mavmq\",\"type\":\"oudorhcgyyp\"}")
            .toObject(SiteReferenceInner.class);
        Assertions.assertEquals("ybnnustg", model.properties().siteId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SiteReferenceInner model
            = new SiteReferenceInner().withProperties(new SiteReferenceProperties().withSiteId("ybnnustg"));
        model = BinaryData.fromObject(model).toObject(SiteReferenceInner.class);
        Assertions.assertEquals("ybnnustg", model.properties().siteId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferenceListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SiteReferenceListResult;
import org.junit.jupiter.api.Assertions;

public final class SiteReferenceListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SiteReferenceListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"siteId\":\"mjkavlgorbmft\",\"provisioningState\":\"Canceled\"},\"id\":\"zfjltfvnzcyjto\",\"name\":\"p\",\"type\":\"opv\"},{\"properties\":{\"siteId\":\"dbzqgqqihed\",\"provisioningState\":\"Deleting\"},\"id\":\"thmkyib\",\"name\":\"ysi\",\"type\":\"sgqcwdho\"}],\"nextLink\":\"dtmcd\"}")
            .toObject(SiteReferenceListResult.class);
        Assertions.assertEquals("mjkavlgorbmft", model.value().get(0).properties().siteId());
        Assertions.assertEquals("dtmcd", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferencePropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties;
import org.junit.jupiter.api.Assertions;

public final class SiteReferencePropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SiteReferenceProperties model
            = BinaryData.fromString("{\"siteId\":\"otwypundmb\",\"provisioningState\":\"Failed\"}")
                .toObject(SiteReferenceProperties.class);
        Assertions.assertEquals("otwypundmb", model.siteId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SiteReferenceProperties model = new SiteReferenceProperties().withSiteId("otwypundmb");
        model = BinaryData.fromObject(model).toObject(SiteReferenceProperties.class);
        Assertions.assertEquals("otwypundmb", model.siteId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferencesCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.SiteReference;
import com.azure.resourcemanager.workloadorchestration.models.SiteReferenceProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SiteReferencesCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"siteId\":\"gczeuntgx\",\"provisioningState\":\"Succeeded\"},\"id\":\"q\",\"name\":\"tiekoifuvnyttz\",\"type\":\"ixgy\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        SiteReference response = manager.siteReferences()
            .define("lmhxdqaolfylnk")
            .withExistingContext("t", "qjilaywkdcwmqsyr")
            .withProperties(new SiteReferenceProperties().withSiteId("jpjvly"))
            .create();

        Assertions.assertEquals("gczeuntgx", response.properties().siteId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferencesGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.SiteReference;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SiteReferencesGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"siteId\":\"ipjlhwyxpzruz\",\"provisioningState\":\"Deleting\"},\"id\":\"kkwhbgxvellvulnx\",\"name\":\"mnitmujd\",\"type\":\"vm\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        SiteReference response = manager.siteReferences()
            .getWithResponse("cpqtwloesq", "ggvrbnyrukoilaci", "uwj", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("ipjlhwyxpzruz", response.properties().siteId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SiteReferencesListByContextMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.SiteReference;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SiteReferencesListByContextMockTests {
    @Test
    public void testListByContext() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"siteId\":\"zjqr\",\"provisioningState\":\"Failed\"},\"id\":\"nmdyfoebo\",\"name\":\"tjpp\",\"type\":\"laohoqkp\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<SiteReference> response
            = manager.siteReferences().listByContext("lyymffhmjpddny", "fzuvrzmz", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("zjqr", response.iterator().next().properties().siteId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionDependencyParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter;
import java.util.Arrays;
import org.junit.jupiter.api.Assertions;

public final class SolutionDependencyParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionDependencyParameter model = BinaryData.fromString(
            "{\"solutionVersionId\":\"thnzd\",\"solutionTemplateId\":\"sl\",\"solutionTemplateVersion\":\"ayqigynduhav\",\"solutionInstanceName\":\"lkthu\",\"targetId\":\"qolbgyc\",\"dependencies\":[{\"solutionVersionId\":\"r\",\"solutionTemplateId\":\"ccymvaolpsslql\",\"solutionTemplateVersion\":\"mdnbbglzpswiy\",\"solutionInstanceName\":\"cwyhzdxssa\",\"targetId\":\"zmnvdfznudaod\",\"dependencies\":[{\"solutionVersionId\":\"ncblylpst\",\"solutionTemplateId\":\"hh\",\"solutionTemplateVersion\":\"rzdzucerscdnt\",\"solutionInstanceName\":\"vfiwjmygtdss\",\"targetId\":\"wtmwerio\",\"dependencies\":[{}]}]},{\"solutionVersionId\":\"qsemwabne\",\"solutionTemplateId\":\"hhszh\",\"solutionTemplateVersion\":\"plvwiwubmwmbes\",\"solutionInstanceName\":\"nkww\",\"targetId\":\"pjflcxogao\",\"dependencies\":[{\"solutionVersionId\":\"m\",\"solutionTemplateId\":\"ikvmkqzeqqk\",\"solutionTemplateVersion\":\"tfz\",\"solutionInstanceName\":\"hhvh\",\"targetId\":\"r\",\"dependencies\":[{},{},{}]},{\"solutionVersionId\":\"wobdagxtibqdx\",\"solutionTemplateId\":\"wakbogqxndl\",\"solutionTemplateVersion\":\"gxhuriplbp\",\"solutionInstanceName\":\"xunkbebxmubyynt\",\"targetId\":\"rbqtkoie\",\"dependencies\":[{}]},{\"solutionVersionId\":\"tgqr\",\"solutionTemplateId\":\"tmuwlauwzi\",\"solutionTemplateVersion\":\"bm\",\"solutionInstanceName\":\"cjefuzmu\",\"targetId\":\"bttdumorppxe\",\"dependencies\":[{},{}]}]},{\"solutionVersionId\":\"btbhjpglkfgohd\",\"solutionTemplateId\":\"uel\",\"solutionTemplateVersion\":\"hsd\",\"solutionInstanceName\":\"t\",\"targetId\":\"fikdowwqu\",\"dependencies\":[{\"solutionVersionId\":\"xclvit\",\"solutionTemplateId\":\"qzonosggbhcohf\",\"solutionTemplateVersion\":\"sjnkal\",\"solutionInstanceName\":\"tiiswacffg\",\"targetId\":\"zzewkfvhqcrai\",\"dependencies\":[{},{}]},{\"solutionVersionId\":\"ppfufl\",\"solutionTemplateId\":\"dmhdlxyjr\",\"solutionTemplateVersion\":\"agafcnihgwqap\",\"solutionInstanceName\":\"dgfbcvkcvqvpke\",\"targetId\":\"cvdrhvoodsot\",\"dependencies\":[{},{}]}]},{\"solutionVersionId\":\"dopcjwvnh\",\"solutionTemplateId\":\"d\",\"solutionTemplateVersion\":\"gx\",\"solutionInstanceName\":\"rslpmutwuoeg\",\"targetId\":\"khjwn\",\"dependencies\":[{\"solutionVersionId\":\"luicpdggkzzlvmbm\",\"solutionTemplateId\":\"xmodf\",\"solutionTemplateVersion\":\"efyw\",\"solutionInstanceName\":\"pfvmwyhrfou\",\"targetId\":\"taakc\",\"dependencies\":[{},{},{}]},{\"solutionVersionId\":\"zvqtmnubexkp\",\"solutionTemplateId\":\"smond\",\"solutionTemplateVersion\":\"quxvypomgkop\",\"solutionInstanceName\":\"hojvpajqgxysmocm\",\"targetId\":\"fqvm\",\"dependencies\":[{},{}]}]}]}")
            .toObject(SolutionDependencyParameter.class);
        Assertions.assertEquals("thnzd", model.solutionVersionId());
        Assertions.assertEquals("sl", model.solutionTemplateId());
        Assertions.assertEquals("ayqigynduhav", model.solutionTemplateVersion());
        Assertions.assertEquals("lkthu", model.solutionInstanceName());
        Assertions.assertEquals("qolbgyc", model.targetId());
        Assertions.assertEquals("r", model.dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("ccymvaolpsslql", model.dependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("mdnbbglzpswiy", model.dependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("cwyhzdxssa", model.dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("zmnvdfznudaod", model.dependencies().get(0).targetId());
        Assertions.assertEquals("ncblylpst", model.dependencies().get(0).dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("hh", model.dependencies().get(0).dependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("rzdzucerscdnt",
            model.dependencies().get(0).dependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("vfiwjmygtdss",
            model.dependencies().get(0).dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("wtmwerio", model.dependencies().get(0).dependencies().get(0).targetId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionDependencyParameter model = new SolutionDependencyParameter().withSolutionVersionId("thnzd")
            .withSolutionTemplateId("sl")
            .withSolutionTemplateVersion("ayqigynduhav")
            .withSolutionInstanceName("lkthu")
            .withTargetId("qolbgyc")
            .withDependencies(Arrays.asList(
                new SolutionDependencyParameter().withSolutionVersionId("r")
                    .withSolutionTemplateId("ccymvaolpsslql")
                    .withSolutionTemplateVersion("mdnbbglzpswiy")
                    .withSolutionInstanceName("cwyhzdxssa")
                    .withTargetId("zmnvdfznudaod")
                    .withDependencies(Arrays.asList(new SolutionDependencyParameter().withSolutionVersionId("ncblylpst")
                        .withSolutionTemplateId("hh")
                        .withSolutionTemplateVersion("rzdzucerscdnt")
                        .withSolutionInstanceName("vfiwjmygtdss")
                        .withTargetId("wtmwerio")
                        .withDependencies(Arrays.asList(new SolutionDependencyParameter())))),
                new SolutionDependencyParameter().withSolutionVersionId("qsemwabne")
                    .withSolutionTemplateId("hhszh")
                    .withSolutionTemplateVersion("plvwiwubmwmbes")
                    .withSolutionInstanceName("nkww")
                    .withTargetId("pjflcxogao")
                    .withDependencies(
                        Arrays.asList(
                            new SolutionDependencyParameter().withSolutionVersionId("m")
                                .withSolutionTemplateId("ikvmkqzeqqk")
                                .withSolutionTemplateVersion("tfz")
                                .withSolutionInstanceName("hhvh")
                                .withTargetId("r")
                                .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                    new SolutionDependencyParameter(), new SolutionDependencyParameter())),
                            new SolutionDependencyParameter().withSolutionVersionId("wobdagxtibqdx")
                                .withSolutionTemplateId("wakbogqxndl")
                                .withSolutionTemplateVersion("gxhuriplbp")
                                .withSolutionInstanceName("xunkbebxmubyynt")
                                .withTargetId("rbqtkoie")
                                .withDependencies(Arrays.asList(new SolutionDependencyParameter())),
                            new SolutionDependencyParameter().withSolutionVersionId("tgqr")
                                .withSolutionTemplateId("tmuwlauwzi")
                                .withSolutionTemplateVersion("bm")
                                .withSolutionInstanceName("cjefuzmu")
                                .withTargetId("bttdumorppxe")
                                .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                    new SolutionDependencyParameter())))),
                new SolutionDependencyParameter().withSolutionVersionId("btbhjpglkfgohd")
                    .withSolutionTemplateId("uel")
                    .withSolutionTemplateVersion("hsd")
                    .withSolutionInstanceName("t")
                    .withTargetId("fikdowwqu")
                    .withDependencies(
                        Arrays.asList(
                            new SolutionDependencyParameter().withSolutionVersionId("xclvit")
                                .withSolutionTemplateId("qzonosggbhcohf")
                                .withSolutionTemplateVersion("sjnkal")
                                .withSolutionInstanceName("tiiswacffg")
                                .withTargetId("zzewkfvhqcrai")
                                .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                    new SolutionDependencyParameter())),
                            new SolutionDependencyParameter().withSolutionVersionId("ppfufl")
                                .withSolutionTemplateId("dmhdlxyjr")
                                .withSolutionTemplateVersion("agafcnihgwqap")
                                .withSolutionInstanceName("dgfbcvkcvqvpke")
                                .withTargetId("cvdrhvoodsot")
                                .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                    new SolutionDependencyParameter())))),
                new SolutionDependencyParameter().withSolutionVersionId("dopcjwvnh")
                    .withSolutionTemplateId("d")
                    .withSolutionTemplateVersion("gx")
                    .withSolutionInstanceName("rslpmutwuoeg")
                    .withTargetId("khjwn")
                    .withDependencies(Arrays.asList(
                        new SolutionDependencyParameter().withSolutionVersionId("luicpdggkzzlvmbm")
                            .withSolutionTemplateId("xmodf")
                            .withSolutionTemplateVersion("efyw")
                            .withSolutionInstanceName("pfvmwyhrfou")
                            .withTargetId("taakc")
                            .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                new SolutionDependencyParameter(), new SolutionDependencyParameter())),
                        new SolutionDependencyParameter().withSolutionVersionId("zvqtmnubexkp")
                            .withSolutionTemplateId("smond")
                            .withSolutionTemplateVersion("quxvypomgkop")
                            .withSolutionInstanceName("hojvpajqgxysmocm")
                            .withTargetId("fqvm")
                            .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                new SolutionDependencyParameter()))))));
        model = BinaryData.fromObject(model).toObject(SolutionDependencyParameter.class);
        Assertions.assertEquals("thnzd", model.solutionVersionId());
        Assertions.assertEquals("sl", model.solutionTemplateId());
        Assertions.assertEquals("ayqigynduhav", model.solutionTemplateVersion());
        Assertions.assertEquals("lkthu", model.solutionInstanceName());
        Assertions.assertEquals("qolbgyc", model.targetId());
        Assertions.assertEquals("r", model.dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("ccymvaolpsslql", model.dependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("mdnbbglzpswiy", model.dependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("cwyhzdxssa", model.dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("zmnvdfznudaod", model.dependencies().get(0).targetId());
        Assertions.assertEquals("ncblylpst", model.dependencies().get(0).dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("hh", model.dependencies().get(0).dependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("rzdzucerscdnt",
            model.dependencies().get(0).dependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("vfiwjmygtdss",
            model.dependencies().get(0).dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("wtmwerio", model.dependencies().get(0).dependencies().get(0).targetId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionDependencyTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SolutionDependency;
import org.junit.jupiter.api.Assertions;

public final class SolutionDependencyTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionDependency model = BinaryData.fromString(
            "{\"solutionVersionId\":\"vkmijcmmxdcuf\",\"solutionInstanceName\":\"srp\",\"solutionTemplateVersionId\":\"mzidnsezcxtb\",\"targetId\":\"sgfyccsnew\",\"dependencies\":[{\"solutionVersionId\":\"z\",\"solutionInstanceName\":\"iachbo\",\"solutionTemplateVersionId\":\"sflnrosfqp\",\"targetId\":\"eeh\",\"dependencies\":[{\"solutionVersionId\":\"ypyqrimzinp\",\"solutionInstanceName\":\"wjdk\",\"solutionTemplateVersionId\":\"rsoodqxhcrmnoh\",\"targetId\":\"t\",\"dependencies\":[{\"solutionVersionId\":\"h\",\"solutionTemplateVersionId\":\"soifiyipjxsqw\",\"targetId\":\"gr\"},{\"solutionVersionId\":\"bznorcjxvsnby\",\"solutionTemplateVersionId\":\"qabnmoc\",\"targetId\":\"cyshurzafbljjgp\"},{\"solutionVersionId\":\"toqcjmklja\",\"solutionTemplateVersionId\":\"bqidtqaj\",\"targetId\":\"yulpkudjkr\"}]},{\"solutionVersionId\":\"khbzhfepgzg\",\"solutionInstanceName\":\"xzlocxscp\",\"solutionTemplateVersionId\":\"ierhhbcsglummaj\",\"targetId\":\"j\",\"dependencies\":[{\"solutionVersionId\":\"xobnbdxkqpxok\",\"solutionTemplateVersionId\":\"jionpimexgstxgc\",\"targetId\":\"odgmaajrmvdjwz\"}]},{\"solutionVersionId\":\"lovmclwhijcoe\",\"solutionInstanceName\":\"tbzaqsqsycbkbfk\",\"solutionTemplateVersionId\":\"ukdkexxppofmxa\",\"targetId\":\"c\",\"dependencies\":[{\"solutionVersionId\":\"gddtocj\",\"solutionTemplateVersionId\":\"xhvpmoue\",\"targetId\":\"hd\"}]},{\"solutionVersionId\":\"xibqeojnx\",\"solutionInstanceName\":\"zvddntwndeicbtwn\",\"solutionTemplateVersionId\":\"zao\",\"targetId\":\"vuhrhcffcyddgl\",\"dependencies\":[{\"solutionVersionId\":\"hjq\",\"solutionTemplateVersionId\":\"wpyeicxmqciwqvh\",\"targetId\":\"hix\"}]}]},{\"solutionVersionId\":\"igdtopbob\",\"solutionInstanceName\":\"ghmewuam\",\"solutionTemplateVersionId\":\"uhrzayvvt\",\"targetId\":\"gvdfgiotkftutq\",\"dependencies\":[{\"solutionVersionId\":\"gxlefgugnxkrxd\",\"solutionInstanceName\":\"i\",\"solutionTemplateVersionId\":\"tthzrvqd\",\"targetId\":\"abhjybi\",\"dependencies\":[{\"solutionVersionId\":\"oqfbowskanyk\",\"solutionTemplateVersionId\":\"zlcuiywgqywgndrv\",\"targetId\":\"nhzgpphrcgyn\"}]},{\"solutionVersionId\":\"ocpecfvmmco\",\"solutionInstanceName\":\"sxlzevgbmqj\",\"solutionTemplateVersionId\":\"abcypmivk\",\"targetId\":\"lzu\",\"dependencies\":[{\"solutionVersionId\":\"fwnfnb\",\"solutionTemplateVersionId\":\"cfionl\",\"targetId\":\"bxetqgtzxdpn\"}]},{\"solutionVersionId\":\"bqqwxrj\",\"solutionInstanceName\":\"al\",\"solutionTemplateVersionId\":\"nwsubisnj\",\"targetId\":\"mpmngnzscxaqwoo\",\"dependencies\":[{\"solutionVersionId\":\"bonqvpkvlrxnjeas\",\"solutionTemplateVersionId\":\"ipheoflokeyyien\",\"targetId\":\"bdlwtgrhpdjpj\"},{\"solutionVersionId\":\"masxazjpqyegu\",\"solutionTemplateVersionId\":\"lhbxxhejjzzvdud\",\"targetId\":\"wdslfhotwmcy\"}]},{\"solutionVersionId\":\"pwlbjnpg\",\"solutionInstanceName\":\"ftadehxnltyfs\",\"solutionTemplateVersionId\":\"ppusuesnzwdejba\",\"targetId\":\"orxzdmohctbqvud\",\"dependencies\":[{\"solutionVersionId\":\"ndnvo\",\"solutionTemplateVersionId\":\"gujjugwdkcglh\",\"targetId\":\"lazjdyggdtjixhbk\"},{\"solutionVersionId\":\"ofqweykhmenevfye\",\"solutionTemplateVersionId\":\"fwhybcibvy\",\"targetId\":\"dcsi\"}]}]}]}")
            .toObject(SolutionDependency.class);
        Assertions.assertEquals("vkmijcmmxdcuf", model.solutionVersionId());
        Assertions.assertEquals("srp", model.solutionInstanceName());
        Assertions.assertEquals("mzidnsezcxtb", model.solutionTemplateVersionId());
        Assertions.assertEquals("sgfyccsnew", model.targetId());
        Assertions.assertEquals("z", model.dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("iachbo", model.dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("sflnrosfqp", model.dependencies().get(0).solutionTemplateVersionId());
        Assertions.assertEquals("eeh", model.dependencies().get(0).targetId());
        Assertions.assertEquals("ypyqrimzinp", model.dependencies().get(0).dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("wjdk", model.dependencies().get(0).dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("rsoodqxhcrmnoh",
            model.dependencies().get(0).dependencies().get(0).solutionTemplateVersionId());
        Assertions.assertEquals("t", model.dependencies().get(0).dependencies().get(0).targetId());
        Assertions.assertEquals("h",
            model.dependencies().get(0).dependencies().get(0).dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("soifiyipjxsqw",
            model.dependencies().get(0).dependencies().get(0).dependencies().get(0).solutionTemplateVersionId());
        Assertions.assertEquals("gr",
            model.dependencies().get(0).dependencies().get(0).dependencies().get(0).targetId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionProperties;
import org.junit.jupiter.api.Assertions;

public final class SolutionInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionInner model = BinaryData.fromString(
            "{\"properties\":{\"solutionTemplateId\":\"lmfmtdaay\",\"availableSolutionTemplateVersions\":[{\"solutionTemplateVersion\":\"wvgpiohg\",\"latestConfigRevision\":\"xrtfudxep\",\"isConfigured\":true}],\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"gvr\",\"type\":\"CustomLocation\"},\"eTag\":\"pkukghi\",\"id\":\"blxgwimf\",\"name\":\"jhfjxwm\",\"type\":\"zk\"}")
            .toObject(SolutionInner.class);
        Assertions.assertEquals("gvr", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.extendedLocation().type());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionInner model = new SolutionInner().withProperties(new SolutionProperties())
            .withExtendedLocation(
                new ExtendedLocation().withName("gvr").withType(ExtendedLocationType.CUSTOM_LOCATION));
        model = BinaryData.fromObject(model).toObject(SolutionInner.class);
        Assertions.assertEquals("gvr", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionListResult;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import org.junit.jupiter.api.Assertions;

public final class SolutionListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"solutionTemplateId\":\"oulpjrv\",\"availableSolutionTemplateVersions\":[{\"solutionTemplateVersion\":\"l\",\"latestConfigRevision\":\"vimjwos\",\"isConfigured\":false},{\"solutionTemplateVersion\":\"xitc\",\"latestConfigRevision\":\"kfcktqum\",\"isConfigured\":true},{\"solutionTemplateVersion\":\"kkezzikhlyfjhdgq\",\"latestConfigRevision\":\"gebdunygaeq\",\"isConfigured\":false},{\"solutionTemplateVersion\":\"bqfatpxllrxcyjmo\",\"latestConfigRevision\":\"dsuvarmywdmjsjqb\",\"isConfigured\":false}],\"provisioningState\":\"Initialized\"},\"extendedLocation\":{\"name\":\"xrwlyc\",\"type\":\"EdgeZone\"},\"eTag\":\"hp\",\"id\":\"kgymareqnajxqug\",\"name\":\"hky\",\"type\":\"ubeddg\"}],\"nextLink\":\"ofwq\"}")
            .toObject(SolutionListResult.class);
        Assertions.assertEquals("xrwlyc", model.value().get(0).extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.value().get(0).extendedLocation().type());
        Assertions.assertEquals("ofwq", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SolutionProperties;

public final class SolutionPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionProperties model = BinaryData.fromString(
            "{\"solutionTemplateId\":\"oqreyfkzikfjawn\",\"availableSolutionTemplateVersions\":[{\"solutionTemplateVersion\":\"vxwc\",\"latestConfigRevision\":\"elpcirelsfeaenwa\",\"isConfigured\":false}],\"provisioningState\":\"Canceled\"}")
            .toObject(SolutionProperties.class);
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionProperties model = new SolutionProperties();
        model = BinaryData.fromObject(model).toObject(SolutionProperties.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionsCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.Solution;
import com.azure.resourcemanager.workloadorchestration.models.SolutionProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SolutionsCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"solutionTemplateId\":\"vsqxfxjelgcmpzqj\",\"availableSolutionTemplateVersions\":[{\"solutionTemplateVersion\":\"qxuwyvca\",\"latestConfigRevision\":\"oyvivbsiz\",\"isConfigured\":false}],\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"lbscmnlz\",\"type\":\"EdgeZone\"},\"eTag\":\"uf\",\"id\":\"gmvflnwyvqkx\",\"name\":\"erlniylylyfw\",\"type\":\"zutgqztwhghmupg\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Solution response = manager.solutions()
            .define("ot")
            .withExistingTarget("pyc", "hcoeocnhzq")
            .withProperties(new SolutionProperties())
            .withExtendedLocation(new ExtendedLocation().withName("d").withType(ExtendedLocationType.EDGE_ZONE))
            .create();

        Assertions.assertEquals("lbscmnlz", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionsGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.Solution;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SolutionsGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"solutionTemplateId\":\"pol\",\"availableSolutionTemplateVersions\":[{\"solutionTemplateVersion\":\"evboclzhzjknyuxg\",\"latestConfigRevision\":\"ttxpnrupza\",\"isConfigured\":true},{\"solutionTemplateVersion\":\"rdixt\",\"latestConfigRevision\":\"ekidswyskb\",\"isConfigured\":true},{\"solutionTemplateVersion\":\"ffg\",\"latestConfigRevision\":\"lukkutvlxhrpqhvm\",\"isConfigured\":true}],\"provisioningState\":\"InProgress\"},\"extendedLocation\":{\"name\":\"qehbhbcds\",\"type\":\"EdgeZone\"},\"eTag\":\"yr\",\"id\":\"doypm\",\"name\":\"ltoormkfqlwxldyk\",\"type\":\"lsygaol\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Solution response = manager.solutions()
            .getWithResponse("jogjonmc", "e", "oyzbamwineofvf", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("qehbhbcds", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionsListByTargetMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.Solution;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SolutionsListByTargetMockTests {
    @Test
    public void testListByTarget() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"solutionTemplateId\":\"inbmh\",\"availableSolutionTemplateVersions\":[{\"solutionTemplateVersion\":\"ijkgqxnhm\",\"latestConfigRevision\":\"keznjaujvaa\",\"isConfigured\":true},{\"solutionTemplateVersion\":\"ggiycwkdtaawxwf\",\"latestConfigRevision\":\"ka\",\"isConfigured\":true},{\"solutionTemplateVersion\":\"rrqmbzmqk\",\"latestConfigRevision\":\"atbnxwbj\",\"isConfigured\":true},{\"solutionTemplateVersion\":\"dbirkfpksokdgo\",\"latestConfigRevision\":\"ewijymrhbguz\",\"isConfigured\":false}],\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"wnf\",\"type\":\"EdgeZone\"},\"eTag\":\"hhqosmffjku\",\"id\":\"cyar\",\"name\":\"roohguabzogh\",\"type\":\"t\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Solution> response
            = manager.solutions().listByTarget("jpnnbmjksibjgsj", "xxahmrnadzyqegxy", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("wnf", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.iterator().next().extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplateInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateInner;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class SolutionTemplateInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionTemplateInner model = BinaryData.fromString(
            "{\"properties\":{\"description\":\"ivfxzsjabibsyst\",\"capabilities\":[\"fsdjpvkvp\",\"jxbkzbzkdvn\",\"jabudurgkakmo\"],\"latestVersion\":\"hjjklff\",\"state\":\"active\",\"enableExternalValidation\":false,\"provisioningState\":\"Succeeded\"},\"eTag\":\"zrfze\",\"location\":\"ebizikayuh\",\"tags\":{\"vtldgmfpgvmpip\":\"jbsybbqw\",\"x\":\"slthaq\"},\"id\":\"smwutwbdsrezpd\",\"name\":\"hneuyowqkd\",\"type\":\"ytisibir\"}")
            .toObject(SolutionTemplateInner.class);
        Assertions.assertEquals("ebizikayuh", model.location());
        Assertions.assertEquals("jbsybbqw", model.tags().get("vtldgmfpgvmpip"));
        Assertions.assertEquals("ivfxzsjabibsyst", model.properties().description());
        Assertions.assertEquals("fsdjpvkvp", model.properties().capabilities().get(0));
        Assertions.assertEquals(ResourceState.ACTIVE, model.properties().state());
        Assertions.assertFalse(model.properties().enableExternalValidation());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionTemplateInner model = new SolutionTemplateInner().withLocation("ebizikayuh")
            .withTags(mapOf("vtldgmfpgvmpip", "jbsybbqw", "x", "slthaq"))
            .withProperties(new SolutionTemplateProperties().withDescription("ivfxzsjabibsyst")
                .withCapabilities(Arrays.asList("fsdjpvkvp", "jxbkzbzkdvn", "jabudurgkakmo"))
                .withState(ResourceState.ACTIVE)
                .withEnableExternalValidation(false));
        model = BinaryData.fromObject(model).toObject(SolutionTemplateInner.class);
        Assertions.assertEquals("ebizikayuh", model.location());
        Assertions.assertEquals("jbsybbqw", model.tags().get("vtldgmfpgvmpip"));
        Assertions.assertEquals("ivfxzsjabibsyst", model.properties().description());
        Assertions.assertEquals("fsdjpvkvp", model.properties().capabilities().get(0));
        Assertions.assertEquals(ResourceState.ACTIVE, model.properties().state());
        Assertions.assertFalse(model.properties().enableExternalValidation());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplateListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionTemplateListResult;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import org.junit.jupiter.api.Assertions;

public final class SolutionTemplateListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionTemplateListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"description\":\"ndxdigrjguufzdm\",\"capabilities\":[\"qtfihwhbotzinga\",\"vppho\"],\"latestVersion\":\"qzudphq\",\"state\":\"inactive\",\"enableExternalValidation\":false,\"provisioningState\":\"Initialized\"},\"eTag\":\"nwcvtbvkayhmtnv\",\"location\":\"iatkzwpcnp\",\"tags\":{\"g\":\"jaesgvvsccya\",\"lvdnkfx\":\"qfhwyg\",\"apfcqdpsq\":\"semdwzrmu\"},\"id\":\"qvpsvuoymg\",\"name\":\"celve\",\"type\":\"rypqlmfeo\"},{\"properties\":{\"description\":\"rqwky\",\"capabilities\":[\"ob\",\"pg\",\"edkowepbqpcrfk\"],\"latestVersion\":\"ccsnjvcdwxlpq\",\"state\":\"active\",\"enableExternalValidation\":true,\"provisioningState\":\"InProgress\"},\"eTag\":\"jsyingwfqatm\",\"location\":\"htmdvy\",\"tags\":{\"uzhlhkjoqrv\":\"kdgszywkbirr\",\"oupmfii\":\"qaatjinrv\",\"x\":\"fggjioolvr\"},\"id\":\"v\",\"name\":\"kkgll\",\"type\":\"wjygvjayvblmhvk\"},{\"properties\":{\"description\":\"hbxvvyhgsopbyrqu\",\"capabilities\":[\"g\",\"uvwzfbnh\"],\"latestVersion\":\"ctlpdngitvgb\",\"state\":\"inactive\",\"enableExternalValidation\":false,\"provisioningState\":\"Succeeded\"},\"eTag\":\"yijejvegrhbpnaix\",\"location\":\"ccbdre\",\"tags\":{\"qkghtpwijnhy\":\"cexdrrvqa\",\"owvrvmtgjqppyos\":\"svfycxzbfv\",\"sxkm\":\"ronzmyhgfip\"},\"id\":\"waekrrjreafxtsgu\",\"name\":\"hjglikk\",\"type\":\"wslolbqp\"}],\"nextLink\":\"zlmvfelfktgp\"}")
            .toObject(SolutionTemplateListResult.class);
        Assertions.assertEquals("iatkzwpcnp", model.value().get(0).location());
        Assertions.assertEquals("jaesgvvsccya", model.value().get(0).tags().get("g"));
        Assertions.assertEquals("ndxdigrjguufzdm", model.value().get(0).properties().description());
        Assertions.assertEquals("qtfihwhbotzinga", model.value().get(0).properties().capabilities().get(0));
        Assertions.assertEquals(ResourceState.INACTIVE, model.value().get(0).properties().state());
        Assertions.assertFalse(model.value().get(0).properties().enableExternalValidation());
        Assertions.assertEquals("zlmvfelfktgp", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplateParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import java.util.Arrays;
import org.junit.jupiter.api.Assertions;

public final class SolutionTemplateParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionTemplateParameter model = BinaryData.fromString(
            "{\"solutionTemplateVersionId\":\"rknftguvriuhprwm\",\"solutionInstanceName\":\"vxqtayriwwroyqbe\",\"solutionDependencies\":[{\"solutionVersionId\":\"qibycnojvknm\",\"solutionTemplateId\":\"qsgzvahapj\",\"solutionTemplateVersion\":\"hpvgqz\",\"solutionInstanceName\":\"rvxdjzlmw\",\"targetId\":\"kvugfhzovawjvzun\",\"dependencies\":[{\"solutionVersionId\":\"nnprn\",\"solutionTemplateId\":\"peilpjzuaejxdu\",\"solutionTemplateVersion\":\"skzbb\",\"solutionInstanceName\":\"zumveekgpwo\",\"targetId\":\"hkfpbs\",\"dependencies\":[{}]},{\"solutionVersionId\":\"dxluu\",\"solutionTemplateId\":\"ttouwaboekqvkel\",\"solutionTemplateVersion\":\"mvb\",\"solutionInstanceName\":\"yjsflhhcaalnji\",\"targetId\":\"sxyawjoyaqcs\",\"dependencies\":[{},{},{},{}]}]},{\"solutionVersionId\":\"kiidzyex\",\"solutionTemplateId\":\"eli\",\"solutionTemplateVersion\":\"nr\",\"solutionInstanceName\":\"folhbnxknal\",\"targetId\":\"lp\",\"dependencies\":[{\"solutionVersionId\":\"tpnapnyiropuhpig\",\"solutionTemplateId\":\"gylgqgitxmedjvcs\",\"solutionTemplateVersion\":\"n\",\"solutionInstanceName\":\"wncwzzhxgktrmg\",\"targetId\":\"napkteoellw\",\"dependencies\":[{},{},{},{}]},{\"solutionVersionId\":\"ygpfqb\",\"solutionTemplateId\":\"ceopzfqrhhuaopp\",\"solutionTemplateVersion\":\"qeqxo\",\"solutionInstanceName\":\"dahzxctobg\",\"targetId\":\"dmoizpostmg\",\"dependencies\":[{},{},{}]},{\"solutionVersionId\":\"unrmfqjhhkxb\",\"solutionTemplateId\":\"jy\",\"solutionTemplateVersion\":\"hx\",\"solutionInstanceName\":\"yngudivk\",\"targetId\":\"swbxqz\",\"dependencies\":[{}]}]},{\"solutionVersionId\":\"fauvjfdxx\",\"solutionTemplateId\":\"e\",\"solutionTemplateVersion\":\"t\",\"solutionInstanceName\":\"aqtdoqmcbx\",\"targetId\":\"vxysl\",\"dependencies\":[{\"solutionVersionId\":\"fxoblytkb\",\"solutionTemplateId\":\"pe\",\"solutionTemplateVersion\":\"wfbkrvrns\",\"solutionInstanceName\":\"hqjohxcrsbfova\",\"targetId\":\"ruvw\",\"dependencies\":[{},{},{},{}]},{\"solutionVersionId\":\"fsubcgjbirxbpy\",\"solutionTemplateId\":\"rfbjf\",\"solutionTemplateVersion\":\"w\",\"solutionInstanceName\":\"otftpvjzbexilz\",\"targetId\":\"fqqnvwpmqtaruo\",\"dependencies\":[{},{},{},{}]},{\"solutionVersionId\":\"cjhwq\",\"solutionTemplateId\":\"jrybnwjewgdrjer\",\"solutionTemplateVersion\":\"aen\",\"solutionInstanceName\":\"eh\",\"targetId\":\"doy\",\"dependencies\":[{},{}]}]}]}")
            .toObject(SolutionTemplateParameter.class);
        Assertions.assertEquals("rknftguvriuhprwm", model.solutionTemplateVersionId());
        Assertions.assertEquals("vxqtayriwwroyqbe", model.solutionInstanceName());
        Assertions.assertEquals("qibycnojvknm", model.solutionDependencies().get(0).solutionVersionId());
        Assertions.assertEquals("qsgzvahapj", model.solutionDependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("hpvgqz", model.solutionDependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("rvxdjzlmw", model.solutionDependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("kvugfhzovawjvzun", model.solutionDependencies().get(0).targetId());
        Assertions.assertEquals("nnprn", model.solutionDependencies().get(0).dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("peilpjzuaejxdu",
            model.solutionDependencies().get(0).dependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("skzbb",
            model.solutionDependencies().get(0).dependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("zumveekgpwo",
            model.solutionDependencies().get(0).dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("hkfpbs", model.solutionDependencies().get(0).dependencies().get(0).targetId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionTemplateParameter model
            = new SolutionTemplateParameter().withSolutionTemplateVersionId("rknftguvriuhprwm")
                .withSolutionInstanceName("vxqtayriwwroyqbe")
                .withSolutionDependencies(
                    Arrays.asList(
                        new SolutionDependencyParameter().withSolutionVersionId("qibycnojvknm")
                            .withSolutionTemplateId("qsgzvahapj")
                            .withSolutionTemplateVersion("hpvgqz")
                            .withSolutionInstanceName("rvxdjzlmw")
                            .withTargetId("kvugfhzovawjvzun")
                            .withDependencies(Arrays.asList(
                                new SolutionDependencyParameter().withSolutionVersionId("nnprn")
                                    .withSolutionTemplateId("peilpjzuaejxdu")
                                    .withSolutionTemplateVersion("skzbb")
                                    .withSolutionInstanceName("zumveekgpwo")
                                    .withTargetId("hkfpbs")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("dxluu")
                                    .withSolutionTemplateId("ttouwaboekqvkel")
                                    .withSolutionTemplateVersion("mvb")
                                    .withSolutionInstanceName("yjsflhhcaalnji")
                                    .withTargetId("sxyawjoyaqcs")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())))),
                        new SolutionDependencyParameter().withSolutionVersionId("kiidzyex")
                            .withSolutionTemplateId("eli")
                            .withSolutionTemplateVersion("nr")
                            .withSolutionInstanceName("folhbnxknal")
                            .withTargetId("lp")
                            .withDependencies(Arrays.asList(
                                new SolutionDependencyParameter().withSolutionVersionId("tpnapnyiropuhpig")
                                    .withSolutionTemplateId("gylgqgitxmedjvcs")
                                    .withSolutionTemplateVersion("n")
                                    .withSolutionInstanceName("wncwzzhxgktrmg")
                                    .withTargetId("napkteoellw")
                                    .withDependencies(Arrays.asList(
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("ygpfqb")
                                    .withSolutionTemplateId("ceopzfqrhhuaopp")
                                    .withSolutionTemplateVersion("qeqxo")
                                    .withSolutionInstanceName("dahzxctobg")
                                    .withTargetId("dmoizpostmg")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("unrmfqjhhkxb")
                                    .withSolutionTemplateId("jy")
                                    .withSolutionTemplateVersion("hx")
                                    .withSolutionInstanceName("yngudivk")
                                    .withTargetId("swbxqz")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter())))),
                        new SolutionDependencyParameter().withSolutionVersionId("fauvjfdxx")
                            .withSolutionTemplateId("e")
                            .withSolutionTemplateVersion("t")
                            .withSolutionInstanceName("aqtdoqmcbx")
                            .withTargetId("vxysl")
                            .withDependencies(Arrays.asList(
                                new SolutionDependencyParameter().withSolutionVersionId("fxoblytkb")
                                    .withSolutionTemplateId("pe")
                                    .withSolutionTemplateVersion("wfbkrvrns")
                                    .withSolutionInstanceName("hqjohxcrsbfova")
                                    .withTargetId("ruvw")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("fsubcgjbirxbpy")
                                    .withSolutionTemplateId("rfbjf")
                                    .withSolutionTemplateVersion("w")
                                    .withSolutionInstanceName("otftpvjzbexilz")
                                    .withTargetId("fqqnvwpmqtaruo")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("cjhwq")
                                    .withSolutionTemplateId("jrybnwjewgdrjer")
                                    .withSolutionTemplateVersion("aen")
                                    .withSolutionInstanceName("eh")
                                    .withTargetId("doy")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter()))))));
        model = BinaryData.fromObject(model).toObject(SolutionTemplateParameter.class);
        Assertions.assertEquals("rknftguvriuhprwm", model.solutionTemplateVersionId());
        Assertions.assertEquals("vxqtayriwwroyqbe", model.solutionInstanceName());
        Assertions.assertEquals("qibycnojvknm", model.solutionDependencies().get(0).solutionVersionId());
        Assertions.assertEquals("qsgzvahapj", model.solutionDependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("hpvgqz", model.solutionDependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("rvxdjzlmw", model.solutionDependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("kvugfhzovawjvzun", model.solutionDependencies().get(0).targetId());
        Assertions.assertEquals("nnprn", model.solutionDependencies().get(0).dependencies().get(0).solutionVersionId());
        Assertions.assertEquals("peilpjzuaejxdu",
            model.solutionDependencies().get(0).dependencies().get(0).solutionTemplateId());
        Assertions.assertEquals("skzbb",
            model.solutionDependencies().get(0).dependencies().get(0).solutionTemplateVersion());
        Assertions.assertEquals("zumveekgpwo",
            model.solutionDependencies().get(0).dependencies().get(0).solutionInstanceName());
        Assertions.assertEquals("hkfpbs", model.solutionDependencies().get(0).dependencies().get(0).targetId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatePropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties;
import java.util.Arrays;
import org.junit.jupiter.api.Assertions;

public final class SolutionTemplatePropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionTemplateProperties model = BinaryData.fromString(
            "{\"description\":\"gpikpzimejza\",\"capabilities\":[\"fzxiavrmb\",\"onok\",\"xrjqcirgzpfrlazs\",\"rnwoiindfp\"],\"latestVersion\":\"jylwbtlhflsj\",\"state\":\"active\",\"enableExternalValidation\":true,\"provisioningState\":\"Failed\"}")
            .toObject(SolutionTemplateProperties.class);
        Assertions.assertEquals("gpikpzimejza", model.description());
        Assertions.assertEquals("fzxiavrmb", model.capabilities().get(0));
        Assertions.assertEquals(ResourceState.ACTIVE, model.state());
        Assertions.assertTrue(model.enableExternalValidation());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionTemplateProperties model = new SolutionTemplateProperties().withDescription("gpikpzimejza")
            .withCapabilities(Arrays.asList("fzxiavrmb", "onok", "xrjqcirgzpfrlazs", "rnwoiindfp"))
            .withState(ResourceState.ACTIVE)
            .withEnableExternalValidation(true);
        model = BinaryData.fromObject(model).toObject(SolutionTemplateProperties.class);
        Assertions.assertEquals("gpikpzimejza", model.description());
        Assertions.assertEquals("fzxiavrmb", model.capabilities().get(0));
        Assertions.assertEquals(ResourceState.ACTIVE, model.state());
        Assertions.assertTrue(model.enableExternalValidation());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplate;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SolutionTemplatesCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"description\":\"aykmmf\",\"capabilities\":[\"bfw\",\"rzx\"],\"latestVersion\":\"ewsrsxkrplbjaze\",\"state\":\"active\",\"enableExternalValidation\":true,\"provisioningState\":\"Succeeded\"},\"eTag\":\"ps\",\"location\":\"brnnhjxsqw\",\"tags\":{\"qiqyhgfsetzlexbs\":\"kbiwetpozyc\",\"uwfbzkkdtnhqsy\":\"ledynojpz\"},\"id\":\"ljselp\",\"name\":\"pbafvafhlbylc\",\"type\":\"bevxrhyzd\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        SolutionTemplate response = manager.solutionTemplates()
            .define("efh")
            .withRegion("sxfwushcdp")
            .withExistingResourceGroup("sxap")
            .withTags(mapOf("mgjfbpkuwxeoio", "nq"))
            .withProperties(new SolutionTemplateProperties().withDescription("cgjokjljnhvlq")
                .withCapabilities(Arrays.asList("ek", "eeksnbksdqhjvyk", "xeslkhhustcpoqm", "vnwqjwgo"))
                .withState(ResourceState.ACTIVE)
                .withEnableExternalValidation(false))
            .create();

        Assertions.assertEquals("brnnhjxsqw", response.location());
        Assertions.assertEquals("kbiwetpozyc", response.tags().get("qiqyhgfsetzlexbs"));
        Assertions.assertEquals("aykmmf", response.properties().description());
        Assertions.assertEquals("bfw", response.properties().capabilities().get(0));
        Assertions.assertEquals(ResourceState.ACTIVE, response.properties().state());
        Assertions.assertTrue(response.properties().enableExternalValidation());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesCreateVersionMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.OrchestratorType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersion;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SolutionTemplatesCreateVersionMockTests {
    @Test
    public void testCreateVersion() throws Exception {
        String responseStr
            = "{\"properties\":{\"configurations\":\"ehqpuvjmvqmt\",\"specification\":{},\"orchestratorType\":\"TO\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"oejnndljdju\",\"id\":\"br\",\"name\":\"eqy\",\"type\":\"kceysfaqegplw\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        SolutionTemplateVersion response = manager.solutionTemplates()
            .createVersion("cgqyhleseyq", "hvyeldotj",
                new SolutionTemplateVersionWithUpdateTypeInner().withUpdateType(UpdateType.MINOR)
                    .withVersion("iswskuk")
                    .withSolutionTemplateVersion(new SolutionTemplateVersionInner()
                        .withProperties(new SolutionTemplateVersionProperties().withConfigurations("asbvw")
                            .withSpecification(mapOf())
                            .withOrchestratorType(OrchestratorType.TO))),
                com.azure.core.util.Context.NONE);

        Assertions.assertEquals("ehqpuvjmvqmt", response.properties().configurations());
        Assertions.assertEquals(OrchestratorType.TO, response.properties().orchestratorType());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesListByResourceGroupMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplate;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SolutionTemplatesListByResourceGroupMockTests {
    @Test
    public void testListByResourceGroup() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"description\":\"d\",\"capabilities\":[\"bxgkqusy\",\"w\",\"tdacarvvlfn\"],\"latestVersion\":\"mt\",\"state\":\"inactive\",\"enableExternalValidation\":true,\"provisioningState\":\"Deleting\"},\"eTag\":\"erohzrsqalsxkdn\",\"location\":\"apfgsdpcvessm\",\"tags\":{\"ldqqctekv\":\"kuui\"},\"id\":\"lblhtjq\",\"name\":\"qyv\",\"type\":\"eh\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<SolutionTemplate> response
            = manager.solutionTemplates().listByResourceGroup("ysh", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("apfgsdpcvessm", response.iterator().next().location());
        Assertions.assertEquals("kuui", response.iterator().next().tags().get("ldqqctekv"));
        Assertions.assertEquals("d", response.iterator().next().properties().description());
        Assertions.assertEquals("bxgkqusy", response.iterator().next().properties().capabilities().get(0));
        Assertions.assertEquals(ResourceState.INACTIVE, response.iterator().next().properties().state());
        Assertions.assertTrue(response.iterator().next().properties().enableExternalValidation());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplatesListMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplate;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SolutionTemplatesListMockTests {
    @Test
    public void testList() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"description\":\"emxhzzy\",\"capabilities\":[\"vusxiv\"],\"latestVersion\":\"rryveimipskdy\",\"state\":\"active\",\"enableExternalValidation\":true,\"provisioningState\":\"Succeeded\"},\"eTag\":\"aftjvvruxwigsy\",\"location\":\"pq\",\"tags\":{\"smk\":\"jtgrqgdgkkileplk\",\"floygbdgwumg\":\"hwtbbaedorvvm\"},\"id\":\"dgdhpabgdexj\",\"name\":\"d\",\"type\":\"jsaqwotmmwllcols\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<SolutionTemplate> response = manager.solutionTemplates().list(com.azure.core.util.Context.NONE);

        Assertions.assertEquals("pq", response.iterator().next().location());
        Assertions.assertEquals("jtgrqgdgkkileplk", response.iterator().next().tags().get("smk"));
        Assertions.assertEquals("emxhzzy", response.iterator().next().properties().description());
        Assertions.assertEquals("vusxiv", response.iterator().next().properties().capabilities().get(0));
        Assertions.assertEquals(ResourceState.ACTIVE, response.iterator().next().properties().state());
        Assertions.assertTrue(response.iterator().next().properties().enableExternalValidation());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplateVersionInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.OrchestratorType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class SolutionTemplateVersionInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionTemplateVersionInner model = BinaryData.fromString(
            "{\"properties\":{\"configurations\":\"qal\",\"specification\":{},\"orchestratorType\":\"TO\",\"provisioningState\":\"Failed\"},\"eTag\":\"pxacqqudfn\",\"id\":\"xbaaabjyv\",\"name\":\"yffimrzrtuzqogs\",\"type\":\"xnevfdnwn\"}")
            .toObject(SolutionTemplateVersionInner.class);
        Assertions.assertEquals("qal", model.properties().configurations());
        Assertions.assertEquals(OrchestratorType.TO, model.properties().orchestratorType());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionTemplateVersionInner model = new SolutionTemplateVersionInner()
            .withProperties(new SolutionTemplateVersionProperties().withConfigurations("qal")
                .withSpecification(mapOf())
                .withOrchestratorType(OrchestratorType.TO));
        model = BinaryData.fromObject(model).toObject(SolutionTemplateVersionInner.class);
        Assertions.assertEquals("qal", model.properties().configurations());
        Assertions.assertEquals(OrchestratorType.TO, model.properties().orchestratorType());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplateVersionListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.SolutionTemplateVersionListResult;
import com.azure.resourcemanager.workloadorchestration.models.OrchestratorType;
import org.junit.jupiter.api.Assertions;

public final class SolutionTemplateVersionListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionTemplateVersionListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"configurations\":\"ud\",\"specification\":{},\"orchestratorType\":\"TO\",\"provisioningState\":\"Deleting\"},\"eTag\":\"hzv\",\"id\":\"tdwkqbrq\",\"name\":\"bpaxhexiilivpdt\",\"type\":\"irqtdqoa\"},{\"properties\":{\"configurations\":\"r\",\"specification\":{},\"orchestratorType\":\"TO\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"yfxrx\",\"id\":\"eptra\",\"name\":\"xje\",\"type\":\"wlwnwxuqlcv\"},{\"properties\":{\"configurations\":\"ypatdooaojkniod\",\"specification\":{},\"orchestratorType\":\"TO\",\"provisioningState\":\"Deleting\"},\"eTag\":\"ujhemmsbvdkcrodt\",\"id\":\"nfwjlfltkacjvefk\",\"name\":\"lfoakg\",\"type\":\"kfpagao\"},{\"properties\":{\"configurations\":\"ulpqblylsyxkqjn\",\"specification\":{},\"orchestratorType\":\"TO\",\"provisioningState\":\"Deleting\"},\"eTag\":\"agxsdszuemps\",\"id\":\"kfzbeyvpnqicvi\",\"name\":\"v\",\"type\":\"jjxd\"}],\"nextLink\":\"buukzclewyhml\"}")
            .toObject(SolutionTemplateVersionListResult.class);
        Assertions.assertEquals("ud", model.value().get(0).properties().configurations());
        Assertions.assertEquals(OrchestratorType.TO, model.value().get(0).properties().orchestratorType());
        Assertions.assertEquals("buukzclewyhml", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplateVersionPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.OrchestratorType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class SolutionTemplateVersionPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionTemplateVersionProperties model = BinaryData.fromString(
            "{\"configurations\":\"mewzsyyc\",\"specification\":{},\"orchestratorType\":\"TO\",\"provisioningState\":\"Canceled\"}")
            .toObject(SolutionTemplateVersionProperties.class);
        Assertions.assertEquals("mewzsyyc", model.configurations());
        Assertions.assertEquals(OrchestratorType.TO, model.orchestratorType());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionTemplateVersionProperties model = new SolutionTemplateVersionProperties().withConfigurations("mewzsyyc")
            .withSpecification(mapOf())
            .withOrchestratorType(OrchestratorType.TO);
        model = BinaryData.fromObject(model).toObject(SolutionTemplateVersionProperties.class);
        Assertions.assertEquals("mewzsyyc", model.configurations());
        Assertions.assertEquals(OrchestratorType.TO, model.orchestratorType());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplateVersionsGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.OrchestratorType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersion;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class SolutionTemplateVersionsGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"configurations\":\"okrtalvnb\",\"specification\":{},\"orchestratorType\":\"TO\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"luclvdjjuk\",\"id\":\"dnqodx\",\"name\":\"hhxhq\",\"type\":\"aqnvzoqgyipemchg\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        SolutionTemplateVersion response = manager.solutionTemplateVersions()
            .getWithResponse("yjtcdxabbujftab", "nbbklqpxzucafed", "wwnlzafwxudgnh", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("okrtalvnb", response.properties().configurations());
        Assertions.assertEquals(OrchestratorType.TO, response.properties().orchestratorType());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionTemplateVersionWithUpdateTypeInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionInner;
import com.azure.resourcemanager.workloadorchestration.fluent.models.SolutionTemplateVersionWithUpdateTypeInner;
import com.azure.resourcemanager.workloadorchestration.models.OrchestratorType;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateVersionProperties;
import com.azure.resourcemanager.workloadorchestration.models.UpdateType;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class SolutionTemplateVersionWithUpdateTypeInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionTemplateVersionWithUpdateTypeInner model = BinaryData.fromString(
            "{\"updateType\":\"Patch\",\"version\":\"gofel\",\"solutionTemplateVersion\":{\"properties\":{\"configurations\":\"grqmqhldvrii\",\"specification\":{},\"orchestratorType\":\"TO\",\"provisioningState\":\"Canceled\"},\"eTag\":\"hfkvtvsexsowuel\",\"id\":\"hhahhxvrhmzkwpjg\",\"name\":\"wspughftqsxhqx\",\"type\":\"j\"}}")
            .toObject(SolutionTemplateVersionWithUpdateTypeInner.class);
        Assertions.assertEquals(UpdateType.PATCH, model.updateType());
        Assertions.assertEquals("gofel", model.version());
        Assertions.assertEquals("grqmqhldvrii", model.solutionTemplateVersion().properties().configurations());
        Assertions.assertEquals(OrchestratorType.TO, model.solutionTemplateVersion().properties().orchestratorType());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionTemplateVersionWithUpdateTypeInner model
            = new SolutionTemplateVersionWithUpdateTypeInner().withUpdateType(UpdateType.PATCH)
                .withVersion("gofel")
                .withSolutionTemplateVersion(new SolutionTemplateVersionInner()
                    .withProperties(new SolutionTemplateVersionProperties().withConfigurations("grqmqhldvrii")
                        .withSpecification(mapOf())
                        .withOrchestratorType(OrchestratorType.TO)));
        model = BinaryData.fromObject(model).toObject(SolutionTemplateVersionWithUpdateTypeInner.class);
        Assertions.assertEquals(UpdateType.PATCH, model.updateType());
        Assertions.assertEquals("gofel", model.version());
        Assertions.assertEquals("grqmqhldvrii", model.solutionTemplateVersion().properties().configurations());
        Assertions.assertEquals(OrchestratorType.TO, model.solutionTemplateVersion().properties().orchestratorType());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionVersionParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionParameter;
import org.junit.jupiter.api.Assertions;

public final class SolutionVersionParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionVersionParameter model
            = BinaryData.fromString("{\"solutionVersionId\":\"pvhelxprg\"}").toObject(SolutionVersionParameter.class);
        Assertions.assertEquals("pvhelxprg", model.solutionVersionId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        SolutionVersionParameter model = new SolutionVersionParameter().withSolutionVersionId("pvhelxprg");
        model = BinaryData.fromObject(model).toObject(SolutionVersionParameter.class);
        Assertions.assertEquals("pvhelxprg", model.solutionVersionId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/SolutionVersionSnapshotTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.SolutionVersionSnapshot;
import org.junit.jupiter.api.Assertions;

public final class SolutionVersionSnapshotTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        SolutionVersionSnapshot model
            = BinaryData.fromString("{\"solutionVersionId\":\"hpluodpvruudlg\",\"specification\":{}}")
                .toObject(SolutionVersionSnapshot.class);
        Assertions.assertEquals("hpluodpvruudlg", model.solutionVersionId());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/StageSpecTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode;
import com.azure.resourcemanager.workloadorchestration.models.StageSpec;
import com.azure.resourcemanager.workloadorchestration.models.TaskOption;
import com.azure.resourcemanager.workloadorchestration.models.TaskSpec;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class StageSpecTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        StageSpec model = BinaryData.fromString(
            "{\"name\":\"zeyqxtjjfzqlqhyc\",\"specification\":{},\"tasks\":[{\"name\":\"gxdbeesmie\",\"targetId\":\"lrariaawiu\",\"specification\":{}},{\"name\":\"ydwqfbylyrf\",\"targetId\":\"agt\",\"specification\":{}}],\"taskOption\":{\"concurrency\":1650535228,\"errorAction\":{\"mode\":\"stopOnAnyFailure\",\"maxToleratedFailures\":842850517}}}")
            .toObject(StageSpec.class);
        Assertions.assertEquals("zeyqxtjjfzqlqhyc", model.name());
        Assertions.assertEquals("gxdbeesmie", model.tasks().get(0).name());
        Assertions.assertEquals("lrariaawiu", model.tasks().get(0).targetId());
        Assertions.assertEquals(1650535228, model.taskOption().concurrency());
        Assertions.assertEquals(ErrorActionMode.STOP_ON_ANY_FAILURE, model.taskOption().errorAction().mode());
        Assertions.assertEquals(842850517, model.taskOption().errorAction().maxToleratedFailures());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        StageSpec model = new StageSpec().withName("zeyqxtjjfzqlqhyc")
            .withSpecification(mapOf())
            .withTasks(Arrays.asList(
                new TaskSpec().withName("gxdbeesmie").withTargetId("lrariaawiu").withSpecification(mapOf()),
                new TaskSpec().withName("ydwqfbylyrf").withTargetId("agt").withSpecification(mapOf())))
            .withTaskOption(new TaskOption().withConcurrency(1650535228)
                .withErrorAction(new ErrorAction().withMode(ErrorActionMode.STOP_ON_ANY_FAILURE)
                    .withMaxToleratedFailures(842850517)));
        model = BinaryData.fromObject(model).toObject(StageSpec.class);
        Assertions.assertEquals("zeyqxtjjfzqlqhyc", model.name());
        Assertions.assertEquals("gxdbeesmie", model.tasks().get(0).name());
        Assertions.assertEquals("lrariaawiu", model.tasks().get(0).targetId());
        Assertions.assertEquals(1650535228, model.taskOption().concurrency());
        Assertions.assertEquals(ErrorActionMode.STOP_ON_ANY_FAILURE, model.taskOption().errorAction().mode());
        Assertions.assertEquals(842850517, model.taskOption().errorAction().maxToleratedFailures());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/StageStatusTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ActiveState;
import com.azure.resourcemanager.workloadorchestration.models.StageStatus;
import org.junit.jupiter.api.Assertions;

public final class StageStatusTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        StageStatus model = BinaryData.fromString(
            "{\"status\":641653590,\"statusMessage\":\"vodhtn\",\"stage\":\"rudhzmmesckdl\",\"nextstage\":\"gzrcxfailcfxwmdb\",\"errorMessage\":\"dfgsftufqobrj\",\"isActive\":\"inactive\",\"inputs\":{},\"outputs\":{}}")
            .toObject(StageStatus.class);
        Assertions.assertEquals(641653590, model.status());
        Assertions.assertEquals("vodhtn", model.statusMessage());
        Assertions.assertEquals("rudhzmmesckdl", model.stage());
        Assertions.assertEquals("gzrcxfailcfxwmdb", model.nextstage());
        Assertions.assertEquals("dfgsftufqobrj", model.errorMessage());
        Assertions.assertEquals(ActiveState.INACTIVE, model.isActive());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.TargetInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.TargetProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class TargetInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        TargetInner model = BinaryData.fromString(
            "{\"properties\":{\"description\":\"zz\",\"displayName\":\"bijhtxfvgxbf\",\"contextId\":\"mxnehmp\",\"targetSpecification\":{},\"capabilities\":[\"xgodebfqkkrbmp\",\"kgriwflzlfbx\"],\"hierarchyLevel\":\"puz\",\"status\":{\"lastModified\":\"2021-03-03T14:03:42Z\",\"deployed\":1593715454,\"expectedRunningJobId\":2125725117,\"runningJobId\":64383308,\"status\":\"gkbrpyyd\",\"statusDetails\":\"bnuqqkpik\",\"generation\":1684029730,\"targetStatuses\":[{\"name\":\"qagnbuyn\",\"status\":\"jggmebfsiarbu\",\"componentStatuses\":[{},{},{},{}]}]},\"solutionScope\":\"pnazzm\",\"state\":\"active\",\"provisioningState\":\"Canceled\"},\"eTag\":\"pxtt\",\"extendedLocation\":{\"name\":\"hrbnlankxmyskpbh\",\"type\":\"CustomLocation\"},\"location\":\"tkcxywnytnrsy\",\"tags\":{\"lhaaxdbabp\":\"idybyxczf\",\"fkts\":\"lwrq\"},\"id\":\"hsucoc\",\"name\":\"nyyazttbtwwrqpue\",\"type\":\"ckzywbiexzfeyue\"}")
            .toObject(TargetInner.class);
        Assertions.assertEquals("tkcxywnytnrsy", model.location());
        Assertions.assertEquals("idybyxczf", model.tags().get("lhaaxdbabp"));
        Assertions.assertEquals("zz", model.properties().description());
        Assertions.assertEquals("bijhtxfvgxbf", model.properties().displayName());
        Assertions.assertEquals("mxnehmp", model.properties().contextId());
        Assertions.assertEquals("xgodebfqkkrbmp", model.properties().capabilities().get(0));
        Assertions.assertEquals("puz", model.properties().hierarchyLevel());
        Assertions.assertEquals("pnazzm", model.properties().solutionScope());
        Assertions.assertEquals(ResourceState.ACTIVE, model.properties().state());
        Assertions.assertEquals("hrbnlankxmyskpbh", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.extendedLocation().type());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        TargetInner model = new TargetInner().withLocation("tkcxywnytnrsy")
            .withTags(mapOf("lhaaxdbabp", "idybyxczf", "fkts", "lwrq"))
            .withProperties(new TargetProperties().withDescription("zz")
                .withDisplayName("bijhtxfvgxbf")
                .withContextId("mxnehmp")
                .withTargetSpecification(mapOf())
                .withCapabilities(Arrays.asList("xgodebfqkkrbmp", "kgriwflzlfbx"))
                .withHierarchyLevel("puz")
                .withSolutionScope("pnazzm")
                .withState(ResourceState.ACTIVE))
            .withExtendedLocation(
                new ExtendedLocation().withName("hrbnlankxmyskpbh").withType(ExtendedLocationType.CUSTOM_LOCATION));
        model = BinaryData.fromObject(model).toObject(TargetInner.class);
        Assertions.assertEquals("tkcxywnytnrsy", model.location());
        Assertions.assertEquals("idybyxczf", model.tags().get("lhaaxdbabp"));
        Assertions.assertEquals("zz", model.properties().description());
        Assertions.assertEquals("bijhtxfvgxbf", model.properties().displayName());
        Assertions.assertEquals("mxnehmp", model.properties().contextId());
        Assertions.assertEquals("xgodebfqkkrbmp", model.properties().capabilities().get(0));
        Assertions.assertEquals("puz", model.properties().hierarchyLevel());
        Assertions.assertEquals("pnazzm", model.properties().solutionScope());
        Assertions.assertEquals(ResourceState.ACTIVE, model.properties().state());
        Assertions.assertEquals("hrbnlankxmyskpbh", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.extendedLocation().type());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.TargetListResult;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import org.junit.jupiter.api.Assertions;

public final class TargetListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        TargetListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"description\":\"mwsrcrgvxpvgo\",\"displayName\":\"zlfmisgwbnbbeld\",\"contextId\":\"wkz\",\"targetSpecification\":{},\"capabilities\":[\"io\",\"rqhakauha\",\"hsfwxosowzxcug\"],\"hierarchyLevel\":\"cjooxdjebwpucwwf\",\"status\":{\"lastModified\":\"2021-05-10T00:57:01Z\",\"deployed\":812601807,\"expectedRunningJobId\":2004605521,\"runningJobId\":321338352,\"status\":\"vyhzceuojgjrwj\",\"statusDetails\":\"iotwmcdytdxwit\",\"generation\":1070997174,\"targetStatuses\":[{},{},{}]},\"solutionScope\":\"gqwgxhniskxfbkp\",\"state\":\"active\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"ndnhj\",\"extendedLocation\":{\"name\":\"uwhvylwzbtdhxujz\",\"type\":\"EdgeZone\"},\"location\":\"pow\",\"tags\":{\"lupj\":\"rzqlveu\",\"riplrbpbewtg\":\"khfxobbcswsrt\"},\"id\":\"fgb\",\"name\":\"c\",\"type\":\"wxzvlvqhjkb\"}],\"nextLink\":\"ibtnmxiebwwaloay\"}")
            .toObject(TargetListResult.class);
        Assertions.assertEquals("pow", model.value().get(0).location());
        Assertions.assertEquals("rzqlveu", model.value().get(0).tags().get("lupj"));
        Assertions.assertEquals("mwsrcrgvxpvgo", model.value().get(0).properties().description());
        Assertions.assertEquals("zlfmisgwbnbbeld", model.value().get(0).properties().displayName());
        Assertions.assertEquals("wkz", model.value().get(0).properties().contextId());
        Assertions.assertEquals("io", model.value().get(0).properties().capabilities().get(0));
        Assertions.assertEquals("cjooxdjebwpucwwf", model.value().get(0).properties().hierarchyLevel());
        Assertions.assertEquals("gqwgxhniskxfbkp", model.value().get(0).properties().solutionScope());
        Assertions.assertEquals(ResourceState.ACTIVE, model.value().get(0).properties().state());
        Assertions.assertEquals("uwhvylwzbtdhxujz", model.value().get(0).extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.value().get(0).extendedLocation().type());
        Assertions.assertEquals("ibtnmxiebwwaloay", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.TargetProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class TargetPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        TargetProperties model = BinaryData.fromString(
            "{\"description\":\"xibxujwbhqwalm\",\"displayName\":\"zyoxaepdkzjan\",\"contextId\":\"ux\",\"targetSpecification\":{},\"capabilities\":[\"wbavxbniwdj\"],\"hierarchyLevel\":\"wz\",\"status\":{\"lastModified\":\"2021-08-07T21:53:51Z\",\"deployed\":806707414,\"expectedRunningJobId\":421443987,\"runningJobId\":862771413,\"status\":\"hpzxbzpfzab\",\"statusDetails\":\"cuh\",\"generation\":1070511980,\"targetStatuses\":[{\"name\":\"qik\",\"status\":\"bovpl\",\"componentStatuses\":[{\"name\":\"vgyuguos\",\"status\":\"kfssxqukkf\"},{\"name\":\"gmgsxnkjzkde\",\"status\":\"pvlopwiyighxpkd\"}]}]},\"solutionScope\":\"baiuebbaumny\",\"state\":\"active\",\"provisioningState\":\"Succeeded\"}")
            .toObject(TargetProperties.class);
        Assertions.assertEquals("xibxujwbhqwalm", model.description());
        Assertions.assertEquals("zyoxaepdkzjan", model.displayName());
        Assertions.assertEquals("ux", model.contextId());
        Assertions.assertEquals("wbavxbniwdj", model.capabilities().get(0));
        Assertions.assertEquals("wz", model.hierarchyLevel());
        Assertions.assertEquals("baiuebbaumny", model.solutionScope());
        Assertions.assertEquals(ResourceState.ACTIVE, model.state());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        TargetProperties model = new TargetProperties().withDescription("xibxujwbhqwalm")
            .withDisplayName("zyoxaepdkzjan")
            .withContextId("ux")
            .withTargetSpecification(mapOf())
            .withCapabilities(Arrays.asList("wbavxbniwdj"))
            .withHierarchyLevel("wz")
            .withSolutionScope("baiuebbaumny")
            .withState(ResourceState.ACTIVE);
        model = BinaryData.fromObject(model).toObject(TargetProperties.class);
        Assertions.assertEquals("xibxujwbhqwalm", model.description());
        Assertions.assertEquals("zyoxaepdkzjan", model.displayName());
        Assertions.assertEquals("ux", model.contextId());
        Assertions.assertEquals("wbavxbniwdj", model.capabilities().get(0));
        Assertions.assertEquals("wz", model.hierarchyLevel());
        Assertions.assertEquals("baiuebbaumny", model.solutionScope());
        Assertions.assertEquals(ResourceState.ACTIVE, model.state());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.Target;
import com.azure.resourcemanager.workloadorchestration.models.TargetProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class TargetsCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"description\":\"yapucygvoa\",\"displayName\":\"yunssx\",\"contextId\":\"ghiee\",\"targetSpecification\":{},\"capabilities\":[\"gvvpasek\",\"gbuxantuygdh\",\"aq\",\"pirpiwrqof\"],\"hierarchyLevel\":\"lopmjnlexwhcbjpi\",\"status\":{\"lastModified\":\"2021-06-11T05:51:42Z\",\"deployed\":1918901831,\"expectedRunningJobId\":1317886169,\"runningJobId\":1171605092,\"status\":\"t\",\"statusDetails\":\"oyin\",\"generation\":2062009256,\"targetStatuses\":[{\"name\":\"cyrduczkg\",\"status\":\"xyf\",\"componentStatuses\":[{}]},{\"name\":\"vcrrpcj\",\"status\":\"bstvje\",\"componentStatuses\":[{},{},{},{}]}]},\"solutionScope\":\"mvvfko\",\"state\":\"inactive\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"tuidvrmazlpd\",\"extendedLocation\":{\"name\":\"exymzvla\",\"type\":\"EdgeZone\"},\"location\":\"bhpwvqsgnyy\",\"tags\":{\"atlb\":\"ivensrpmeyyvpk\",\"gsksrfhf\":\"jp\"},\"id\":\"olmk\",\"name\":\"bnxwc\",\"type\":\"ommpvfqaw\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Target response = manager.targets()
            .define("jelaqacigele")
            .withRegion("wcjjncqt")
            .withExistingResourceGroup("dnafcbqwre")
            .withTags(mapOf("gat", "izvg", "grebwggahttzlsw", "uuvbx", "oqza", "ajqfutlx", "zfrgqhaohcm", "unwqr"))
            .withProperties(new TargetProperties().withDescription("d")
                .withDisplayName("vqvwzkjopwbe")
                .withContextId("nrlkwzdqy")
                .withTargetSpecification(mapOf())
                .withCapabilities(Arrays.asList("eakxcptsoqfyi", "seqchkrt"))
                .withHierarchyLevel("zrazisgyk")
                .withSolutionScope("cgdz")
                .withState(ResourceState.ACTIVE))
            .withExtendedLocation(
                new ExtendedLocation().withName("fljhznamtua").withType(ExtendedLocationType.CUSTOM_LOCATION))
            .create();

        Assertions.assertEquals("bhpwvqsgnyy", response.location());
        Assertions.assertEquals("ivensrpmeyyvpk", response.tags().get("atlb"));
        Assertions.assertEquals("yapucygvoa", response.properties().description());
        Assertions.assertEquals("yunssx", response.properties().displayName());
        Assertions.assertEquals("ghiee", response.properties().contextId());
        Assertions.assertEquals("gvvpasek", response.properties().capabilities().get(0));
        Assertions.assertEquals("lopmjnlexwhcbjpi", response.properties().hierarchyLevel());
        Assertions.assertEquals("mvvfko", response.properties().solutionScope());
        Assertions.assertEquals(ResourceState.INACTIVE, response.properties().state());
        Assertions.assertEquals("exymzvla", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.extendedLocation().type());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsGetByResourceGroupWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.Target;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class TargetsGetByResourceGroupWithResponseMockTests {
    @Test
    public void testGetByResourceGroupWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"description\":\"kwcegyamlbn\",\"displayName\":\"eqacjjvpilguooq\",\"contextId\":\"agmdit\",\"targetSpecification\":{},\"capabilities\":[\"iookjbsah\",\"tdtpdelqacslmo\",\"oebn\"],\"hierarchyLevel\":\"xofvcjk\",\"status\":{\"lastModified\":\"2021-04-17T05:22:10Z\",\"deployed\":781083421,\"expectedRunningJobId\":1982278594,\"runningJobId\":1368173114,\"status\":\"w\",\"statusDetails\":\"mdujtmvcopexcm\",\"generation\":1949452896,\"targetStatuses\":[{\"name\":\"hlkyqltqsrog\",\"status\":\"wkffdjkt\",\"componentStatuses\":[{},{}]}]},\"solutionScope\":\"dfvclglxnfu\",\"state\":\"active\",\"provisioningState\":\"Canceled\"},\"eTag\":\"sqo\",\"extendedLocation\":{\"name\":\"fikayiansharujtj\",\"type\":\"CustomLocation\"},\"location\":\"fzyjqt\",\"tags\":{\"qqekewvnqvcdlgu\":\"kpqhjpenuygbq\",\"nlaxpunjqikcz\":\"ucmfdj\",\"xmfcsserxhtv\":\"vitac\",\"tsjgqrsx\":\"oxhlw\"},\"id\":\"p\",\"name\":\"uuuybnchrsziz\",\"type\":\"yuel\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Target response = manager.targets()
            .getByResourceGroupWithResponse("kqzeqyjleziunjx", "fza", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("fzyjqt", response.location());
        Assertions.assertEquals("kpqhjpenuygbq", response.tags().get("qqekewvnqvcdlgu"));
        Assertions.assertEquals("kwcegyamlbn", response.properties().description());
        Assertions.assertEquals("eqacjjvpilguooq", response.properties().displayName());
        Assertions.assertEquals("agmdit", response.properties().contextId());
        Assertions.assertEquals("iookjbsah", response.properties().capabilities().get(0));
        Assertions.assertEquals("xofvcjk", response.properties().hierarchyLevel());
        Assertions.assertEquals("dfvclglxnfu", response.properties().solutionScope());
        Assertions.assertEquals(ResourceState.ACTIVE, response.properties().state());
        Assertions.assertEquals("fikayiansharujtj", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsListByResourceGroupMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.Target;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class TargetsListByResourceGroupMockTests {
    @Test
    public void testListByResourceGroup() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"description\":\"lgmtrwahzjmucf\",\"displayName\":\"byrplrohkpig\",\"contextId\":\"fusuckzmkwklsno\",\"targetSpecification\":{},\"capabilities\":[\"mqeq\",\"lhhjnh\"],\"hierarchyLevel\":\"wy\",\"status\":{\"lastModified\":\"2021-06-11T23:55:26Z\",\"deployed\":1760985730,\"expectedRunningJobId\":837661803,\"runningJobId\":705392339,\"status\":\"vqtanarfdlpuk\",\"statusDetails\":\"yrneizjcpeo\",\"generation\":45100221,\"targetStatuses\":[{\"name\":\"brouxdd\",\"status\":\"fhp\",\"componentStatuses\":[{},{}]},{\"name\":\"jzoywjxhp\",\"status\":\"lontacnpq\",\"componentStatuses\":[{},{},{}]}]},\"solutionScope\":\"tuevrh\",\"state\":\"active\",\"provisioningState\":\"Succeeded\"},\"eTag\":\"gwxhnsduugwbsreu\",\"extendedLocation\":{\"name\":\"q\",\"type\":\"CustomLocation\"},\"location\":\"arenlvhhtklnvnaf\",\"tags\":{\"lcqxypokk\":\"yfedevjbo\",\"zng\":\"minqcym\"},\"id\":\"bdxxe\",\"name\":\"unin\",\"type\":\"udbchaqdtv\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Target> response
            = manager.targets().listByResourceGroup("etndnbfqyggagf", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("arenlvhhtklnvnaf", response.iterator().next().location());
        Assertions.assertEquals("yfedevjbo", response.iterator().next().tags().get("lcqxypokk"));
        Assertions.assertEquals("lgmtrwahzjmucf", response.iterator().next().properties().description());
        Assertions.assertEquals("byrplrohkpig", response.iterator().next().properties().displayName());
        Assertions.assertEquals("fusuckzmkwklsno", response.iterator().next().properties().contextId());
        Assertions.assertEquals("mqeq", response.iterator().next().properties().capabilities().get(0));
        Assertions.assertEquals("wy", response.iterator().next().properties().hierarchyLevel());
        Assertions.assertEquals("tuevrh", response.iterator().next().properties().solutionScope());
        Assertions.assertEquals(ResourceState.ACTIVE, response.iterator().next().properties().state());
        Assertions.assertEquals("q", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION,
            response.iterator().next().extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsListMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.ResourceState;
import com.azure.resourcemanager.workloadorchestration.models.Target;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class TargetsListMockTests {
    @Test
    public void testList() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"description\":\"crqctmxxdtddmflh\",\"displayName\":\"ytxzvtznapxbanno\",\"contextId\":\"voxczytpr\",\"targetSpecification\":{},\"capabilities\":[\"vroevytlyo\",\"rrrouuxvnsa\",\"bcrymodizrx\",\"lobdxna\"],\"hierarchyLevel\":\"pmkmlmvevfx\",\"status\":{\"lastModified\":\"2021-01-31T11:09:27Z\",\"deployed\":1939182119,\"expectedRunningJobId\":315314299,\"runningJobId\":252805227,\"status\":\"hrdd\",\"statusDetails\":\"fg\",\"generation\":354945221,\"targetStatuses\":[{\"name\":\"cbb\",\"status\":\"qcy\",\"componentStatuses\":[{},{},{}]},{\"name\":\"qofyuicdhzbdy\",\"status\":\"wgbdvibidmhmwffp\",\"componentStatuses\":[{},{}]},{\"name\":\"vapckccrrvwey\",\"status\":\"oy\",\"componentStatuses\":[{}]}]},\"solutionScope\":\"haim\",\"state\":\"active\",\"provisioningState\":\"Deleting\"},\"eTag\":\"boshbragapyyrmfs\",\"extendedLocation\":{\"name\":\"pavbo\",\"type\":\"EdgeZone\"},\"location\":\"pdbwnupgahxkum\",\"tags\":{\"dmmcpugmehqep\":\"caac\",\"hbzehewho\":\"u\",\"qnbldxe\":\"hnl\",\"orim\":\"clgsc\"},\"id\":\"rsrrmoucsofldp\",\"name\":\"viyfcaabeolhbhlv\",\"type\":\"mxuq\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Target> response = manager.targets().list(com.azure.core.util.Context.NONE);

        Assertions.assertEquals("pdbwnupgahxkum", response.iterator().next().location());
        Assertions.assertEquals("caac", response.iterator().next().tags().get("dmmcpugmehqep"));
        Assertions.assertEquals("crqctmxxdtddmflh", response.iterator().next().properties().description());
        Assertions.assertEquals("ytxzvtznapxbanno", response.iterator().next().properties().displayName());
        Assertions.assertEquals("voxczytpr", response.iterator().next().properties().contextId());
        Assertions.assertEquals("vroevytlyo", response.iterator().next().properties().capabilities().get(0));
        Assertions.assertEquals("pmkmlmvevfx", response.iterator().next().properties().hierarchyLevel());
        Assertions.assertEquals("haim", response.iterator().next().properties().solutionScope());
        Assertions.assertEquals(ResourceState.ACTIVE, response.iterator().next().properties().state());
        Assertions.assertEquals("pavbo", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.iterator().next().extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetSnapshotTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.TargetSnapshot;
import org.junit.jupiter.api.Assertions;

public final class TargetSnapshotTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        TargetSnapshot model = BinaryData
            .fromString("{\"targetId\":\"hostgktstvdxecl\",\"targetSpecification\":{},\"solutionScope\":\"bcvhzlhpl\"}")
            .toObject(TargetSnapshot.class);
        Assertions.assertEquals("hostgktstvdxecl", model.targetId());
        Assertions.assertEquals("bcvhzlhpl", model.solutionScope());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetsResolveConfigurationMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ResolvedConfiguration;
import com.azure.resourcemanager.workloadorchestration.models.SolutionDependencyParameter;
import com.azure.resourcemanager.workloadorchestration.models.SolutionTemplateParameter;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class TargetsResolveConfigurationMockTests {
    @Test
    public void testResolveConfiguration() throws Exception {
        String responseStr = "{\"configuration\":\"vagbwidqlvhukove\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        ResolvedConfiguration response = manager.targets()
            .resolveConfiguration("bsxtkcudfbsfarfs", "owlkjxnqpv",
                new SolutionTemplateParameter().withSolutionTemplateVersionId("gf")
                    .withSolutionInstanceName("mhqykizmdksa")
                    .withSolutionDependencies(Arrays.asList(
                        new SolutionDependencyParameter().withSolutionVersionId("luqvoxmycjimryv")
                            .withSolutionTemplateId("cwwp")
                            .withSolutionTemplateVersion("zgwe")
                            .withSolutionInstanceName("dsxwefoh")
                            .withTargetId("bvopwndyqle")
                            .withDependencies(Arrays.asList(
                                new SolutionDependencyParameter().withSolutionVersionId("lmtkhlowkxx")
                                    .withSolutionTemplateId("br")
                                    .withSolutionTemplateVersion("jmzsyzfh")
                                    .withSolutionInstanceName("lhikcyychunsj")
                                    .withTargetId("jrtwsz")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("icphvtrrmhw")
                                    .withSolutionTemplateId("fdpyflubh")
                                    .withSolutionTemplateVersion("glrocuy")
                                    .withSolutionInstanceName("whhmemhooc")
                                    .withTargetId("tnpqmemczjk")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())),
                                new SolutionDependencyParameter().withSolutionVersionId("yujxsglhsrrry")
                                    .withSolutionTemplateId("ylmbkzudni")
                                    .withSolutionTemplateVersion("fihotj")
                                    .withSolutionInstanceName("lpxuzzjgnrefq")
                                    .withTargetId("qotoihiqakydiwfb")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter())))),
                        new SolutionDependencyParameter().withSolutionVersionId("zdq")
                            .withSolutionTemplateId("hcspo")
                            .withSolutionTemplateVersion("qaxsipietgbebjf")
                            .withSolutionInstanceName("bmoichd")
                            .withTargetId("nfpubntnbatz")
                            .withDependencies(
                                Arrays.asList(new SolutionDependencyParameter().withSolutionVersionId("owsaaelcattcjuh")
                                    .withSolutionTemplateId("rvkmjcwmjvlgfggc")
                                    .withSolutionTemplateVersion("yylizrz")
                                    .withSolutionInstanceName("psfxsf")
                                    .withTargetId("tl")
                                    .withDependencies(Arrays.asList(new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter(), new SolutionDependencyParameter(),
                                        new SolutionDependencyParameter())))))),
                com.azure.core.util.Context.NONE);

        Assertions.assertEquals("vagbwidqlvhukove", response.configuration());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TargetStatusTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.TargetStatus;
import org.junit.jupiter.api.Assertions;

public final class TargetStatusTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        TargetStatus model = BinaryData.fromString(
            "{\"name\":\"fudwpznt\",\"status\":\"dzhlrq\",\"componentStatuses\":[{\"name\":\"kfrlhrxsbky\",\"status\":\"ycanuzbpzkafku\"},{\"name\":\"crnwbmeh\",\"status\":\"eyvjusrtslhspkde\"},{\"name\":\"aofmxagkvtme\",\"status\":\"qkrhahvljua\"}]}")
            .toObject(TargetStatus.class);
        Assertions.assertEquals("fudwpznt", model.name());
        Assertions.assertEquals("dzhlrq", model.status());
        Assertions.assertEquals("kfrlhrxsbky", model.componentStatuses().get(0).name());
        Assertions.assertEquals("ycanuzbpzkafku", model.componentStatuses().get(0).status());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TaskOptionTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode;
import com.azure.resourcemanager.workloadorchestration.models.TaskOption;
import org.junit.jupiter.api.Assertions;

public final class TaskOptionTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        TaskOption model = BinaryData.fromString(
            "{\"concurrency\":1774852320,\"errorAction\":{\"mode\":\"stopOnNFailures\",\"maxToleratedFailures\":1188867128}}")
            .toObject(TaskOption.class);
        Assertions.assertEquals(1774852320, model.concurrency());
        Assertions.assertEquals(ErrorActionMode.STOP_ON_NFAILURES, model.errorAction().mode());
        Assertions.assertEquals(1188867128, model.errorAction().maxToleratedFailures());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        TaskOption model = new TaskOption().withConcurrency(1774852320)
            .withErrorAction(
                new ErrorAction().withMode(ErrorActionMode.STOP_ON_NFAILURES).withMaxToleratedFailures(1188867128));
        model = BinaryData.fromObject(model).toObject(TaskOption.class);
        Assertions.assertEquals(1774852320, model.concurrency());
        Assertions.assertEquals(ErrorActionMode.STOP_ON_NFAILURES, model.errorAction().mode());
        Assertions.assertEquals(1188867128, model.errorAction().maxToleratedFailures());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/TaskSpecTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.TaskSpec;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class TaskSpecTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        TaskSpec model
            = BinaryData.fromString("{\"name\":\"nzjvusfzldm\",\"targetId\":\"uxylfsbtkadpy\",\"specification\":{}}")
                .toObject(TaskSpec.class);
        Assertions.assertEquals("nzjvusfzldm", model.name());
        Assertions.assertEquals("uxylfsbtkadpy", model.targetId());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        TaskSpec model
            = new TaskSpec().withName("nzjvusfzldm").withTargetId("uxylfsbtkadpy").withSpecification(mapOf());
        model = BinaryData.fromObject(model).toObject(TaskSpec.class);
        Assertions.assertEquals("nzjvusfzldm", model.name());
        Assertions.assertEquals("uxylfsbtkadpy", model.targetId());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/UninstallSolutionParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.UninstallSolutionParameter;
import org.junit.jupiter.api.Assertions;

public final class UninstallSolutionParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        UninstallSolutionParameter model
            = BinaryData.fromString("{\"solutionTemplateId\":\"cgwrtzjuz\",\"solutionInstanceName\":\"yzm\"}")
                .toObject(UninstallSolutionParameter.class);
        Assertions.assertEquals("cgwrtzjuz", model.solutionTemplateId());
        Assertions.assertEquals("yzm", model.solutionInstanceName());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        UninstallSolutionParameter model
            = new UninstallSolutionParameter().withSolutionTemplateId("cgwrtzjuz").withSolutionInstanceName("yzm");
        model = BinaryData.fromObject(model).toObject(UninstallSolutionParameter.class);
        Assertions.assertEquals("cgwrtzjuz", model.solutionTemplateId());
        Assertions.assertEquals("yzm", model.solutionInstanceName());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/VersionParameterTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.VersionParameter;
import org.junit.jupiter.api.Assertions;

public final class VersionParameterTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        VersionParameter model = BinaryData.fromString("{\"version\":\"hxqh\"}").toObject(VersionParameter.class);
        Assertions.assertEquals("hxqh", model.version());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        VersionParameter model = new VersionParameter().withVersion("hxqh");
        model = BinaryData.fromObject(model).toObject(VersionParameter.class);
        Assertions.assertEquals("hxqh", model.version());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowInner;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties;
import org.junit.jupiter.api.Assertions;

public final class WorkflowInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        WorkflowInner model = BinaryData.fromString(
            "{\"properties\":{\"workflowTemplateId\":\"rkambt\",\"provisioningState\":\"Deleting\"},\"extendedLocation\":{\"name\":\"vmnvu\",\"type\":\"CustomLocation\"},\"eTag\":\"vldspa\",\"id\":\"jbkkdmflvestmjl\",\"name\":\"rriloz\",\"type\":\"peewchpxlkt\"}")
            .toObject(WorkflowInner.class);
        Assertions.assertEquals("vmnvu", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.extendedLocation().type());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        WorkflowInner model = new WorkflowInner().withProperties(new WorkflowProperties())
            .withExtendedLocation(
                new ExtendedLocation().withName("vmnvu").withType(ExtendedLocationType.CUSTOM_LOCATION));
        model = BinaryData.fromObject(model).toObject(WorkflowInner.class);
        Assertions.assertEquals("vmnvu", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.WorkflowListResult;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import org.junit.jupiter.api.Assertions;

public final class WorkflowListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        WorkflowListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"workflowTemplateId\":\"tcktyhjtqedcgzu\",\"provisioningState\":\"InProgress\"},\"extendedLocation\":{\"name\":\"rqzz\",\"type\":\"CustomLocation\"},\"eTag\":\"vpglydz\",\"id\":\"rvqeevtoepryutn\",\"name\":\"ytp\",\"type\":\"dmovzvfva\"}],\"nextLink\":\"zqadf\"}")
            .toObject(WorkflowListResult.class);
        Assertions.assertEquals("rqzz", model.value().get(0).extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.value().get(0).extendedLocation().type());
        Assertions.assertEquals("zqadf", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties;

public final class WorkflowPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        WorkflowProperties model
            = BinaryData.fromString("{\"workflowTemplateId\":\"uziycsl\",\"provisioningState\":\"Deleting\"}")
                .toObject(WorkflowProperties.class);
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        WorkflowProperties model = new WorkflowProperties();
        model = BinaryData.fromObject(model).toObject(WorkflowProperties.class);
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowsCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.Workflow;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class WorkflowsCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"workflowTemplateId\":\"xhmw\",\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"ky\",\"type\":\"CustomLocation\"},\"eTag\":\"xkxhnegknjzrbhtm\",\"id\":\"lvukaobrlb\",\"name\":\"gsnbagnchjh\",\"type\":\"emuowakyw\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Workflow response = manager.workflows()
            .define("vxhmtfhocnxzcmj")
            .withExistingContext("lbnwtpcpahp", "z")
            .withProperties(new WorkflowProperties())
            .withExtendedLocation(new ExtendedLocation().withName("d").withType(ExtendedLocationType.CUSTOM_LOCATION))
            .create();

        Assertions.assertEquals("ky", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowsGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.Workflow;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class WorkflowsGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"workflowTemplateId\":\"s\",\"provisioningState\":\"Canceled\"},\"extendedLocation\":{\"name\":\"qazu\",\"type\":\"EdgeZone\"},\"eTag\":\"xzkrrcoi\",\"id\":\"bamnppcc\",\"name\":\"kuztdsbezaxyfu\",\"type\":\"zxuizhyhnepkpe\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        Workflow response
            = manager.workflows().getWithResponse("z", "xiid", "scz", com.azure.core.util.Context.NONE).getValue();

        Assertions.assertEquals("qazu", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowsListByContextMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.Workflow;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class WorkflowsListByContextMockTests {
    @Test
    public void testListByContext() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"workflowTemplateId\":\"tmmkosz\",\"provisioningState\":\"Initialized\"},\"extendedLocation\":{\"name\":\"nsntrpcaqki\",\"type\":\"EdgeZone\"},\"eTag\":\"btfmhklbnldpvcbh\",\"id\":\"zyqu\",\"name\":\"usqxutrpbrr\",\"type\":\"yuuatvlmbjwcolbm\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<Workflow> response
            = manager.workflows().listByContext("iarxqiubxdukec", "xdazv", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("nsntrpcaqki", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.iterator().next().extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionInnerTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.fluent.models.WorkflowVersionInner;
import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.StageSpec;
import com.azure.resourcemanager.workloadorchestration.models.TaskOption;
import com.azure.resourcemanager.workloadorchestration.models.TaskSpec;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class WorkflowVersionInnerTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        WorkflowVersionInner model = BinaryData.fromString(
            "{\"properties\":{\"revision\":318308535,\"configuration\":\"iglaecx\",\"stageSpec\":[{\"name\":\"t\",\"specification\":{},\"tasks\":[{\"name\":\"vzm\",\"targetId\":\"t\",\"specification\":{}}],\"taskOption\":{\"concurrency\":60135256,\"errorAction\":{\"mode\":\"silentlyContinue\",\"maxToleratedFailures\":1646739085}}},{\"name\":\"clnpkci\",\"specification\":{},\"tasks\":[{\"name\":\"ykhyawfvjlboxqvk\",\"targetId\":\"mxho\",\"specification\":{}},{\"name\":\"ynhdwdigum\",\"targetId\":\"raauzzpt\",\"specification\":{}}],\"taskOption\":{\"concurrency\":2034990044,\"errorAction\":{\"mode\":\"silentlyContinue\",\"maxToleratedFailures\":1254202777}}},{\"name\":\"wwvaiqyuvvfonk\",\"specification\":{},\"tasks\":[{\"name\":\"ikvylauya\",\"targetId\":\"uwmncs\",\"specification\":{}}],\"taskOption\":{\"concurrency\":2120109491,\"errorAction\":{\"mode\":\"stopOnAnyFailure\",\"maxToleratedFailures\":263453714}}}],\"reviewId\":\"krsgsgb\",\"state\":\"Failed\",\"specification\":{},\"provisioningState\":\"InProgress\"},\"extendedLocation\":{\"name\":\"dgkynscliqhzvhxn\",\"type\":\"EdgeZone\"},\"eTag\":\"tkubotppn\",\"id\":\"xz\",\"name\":\"hihfrbbcevqagtlt\",\"type\":\"hlfkqojpy\"}")
            .toObject(WorkflowVersionInner.class);
        Assertions.assertEquals("t", model.properties().stageSpec().get(0).name());
        Assertions.assertEquals("vzm", model.properties().stageSpec().get(0).tasks().get(0).name());
        Assertions.assertEquals("t", model.properties().stageSpec().get(0).tasks().get(0).targetId());
        Assertions.assertEquals(60135256, model.properties().stageSpec().get(0).taskOption().concurrency());
        Assertions.assertEquals(ErrorActionMode.SILENTLY_CONTINUE,
            model.properties().stageSpec().get(0).taskOption().errorAction().mode());
        Assertions.assertEquals(1646739085,
            model.properties().stageSpec().get(0).taskOption().errorAction().maxToleratedFailures());
        Assertions.assertEquals("dgkynscliqhzvhxn", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.extendedLocation().type());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        WorkflowVersionInner model = new WorkflowVersionInner()
            .withProperties(new WorkflowVersionProperties().withStageSpec(Arrays.asList(
                new StageSpec().withName("t")
                    .withSpecification(mapOf())
                    .withTasks(
                        Arrays.asList(new TaskSpec().withName("vzm").withTargetId("t").withSpecification(mapOf())))
                    .withTaskOption(new TaskOption().withConcurrency(60135256)
                        .withErrorAction(new ErrorAction().withMode(ErrorActionMode.SILENTLY_CONTINUE)
                            .withMaxToleratedFailures(1646739085))),
                new StageSpec().withName("clnpkci")
                    .withSpecification(mapOf())
                    .withTasks(Arrays.asList(
                        new TaskSpec().withName("ykhyawfvjlboxqvk").withTargetId("mxho").withSpecification(mapOf()),
                        new TaskSpec().withName("ynhdwdigum").withTargetId("raauzzpt").withSpecification(mapOf())))
                    .withTaskOption(new TaskOption().withConcurrency(2034990044)
                        .withErrorAction(new ErrorAction().withMode(ErrorActionMode.SILENTLY_CONTINUE)
                            .withMaxToleratedFailures(1254202777))),
                new StageSpec().withName("wwvaiqyuvvfonk")
                    .withSpecification(mapOf())
                    .withTasks(Arrays
                        .asList(new TaskSpec().withName("ikvylauya").withTargetId("uwmncs").withSpecification(mapOf())))
                    .withTaskOption(new TaskOption().withConcurrency(2120109491)
                        .withErrorAction(new ErrorAction().withMode(ErrorActionMode.STOP_ON_ANY_FAILURE)
                            .withMaxToleratedFailures(263453714)))))
                .withSpecification(mapOf()))
            .withExtendedLocation(
                new ExtendedLocation().withName("dgkynscliqhzvhxn").withType(ExtendedLocationType.EDGE_ZONE));
        model = BinaryData.fromObject(model).toObject(WorkflowVersionInner.class);
        Assertions.assertEquals("t", model.properties().stageSpec().get(0).name());
        Assertions.assertEquals("vzm", model.properties().stageSpec().get(0).tasks().get(0).name());
        Assertions.assertEquals("t", model.properties().stageSpec().get(0).tasks().get(0).targetId());
        Assertions.assertEquals(60135256, model.properties().stageSpec().get(0).taskOption().concurrency());
        Assertions.assertEquals(ErrorActionMode.SILENTLY_CONTINUE,
            model.properties().stageSpec().get(0).taskOption().errorAction().mode());
        Assertions.assertEquals(1646739085,
            model.properties().stageSpec().get(0).taskOption().errorAction().maxToleratedFailures());
        Assertions.assertEquals("dgkynscliqhzvhxn", model.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, model.extendedLocation().type());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionListResultTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.implementation.models.WorkflowVersionListResult;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import org.junit.jupiter.api.Assertions;

public final class WorkflowVersionListResultTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        WorkflowVersionListResult model = BinaryData.fromString(
            "{\"value\":[{\"properties\":{\"revision\":1010221539,\"configuration\":\"cmisofie\",\"stageSpec\":[{\"name\":\"efojyqdhcupl\",\"specification\":{},\"tasks\":[{\"name\":\"khihihlhzds\",\"specification\":{}},{\"name\":\"tzbsrgnowcjhf\",\"specification\":{}},{\"name\":\"mvec\",\"specification\":{}},{\"name\":\"ctxmwoteyowcluq\",\"specification\":{}}],\"taskOption\":{}}],\"reviewId\":\"kqvgqouw\",\"state\":\"Deploying\",\"specification\":{},\"provisioningState\":\"Initialized\"},\"extendedLocation\":{\"name\":\"ivqikfxcvhr\",\"type\":\"CustomLocation\"},\"eTag\":\"huagrttikteusqc\",\"id\":\"vyklxuby\",\"name\":\"affmmfblcqc\",\"type\":\"ubgq\"},{\"properties\":{\"revision\":1835409247,\"configuration\":\"lmetttwgdslqxi\",\"stageSpec\":[{\"name\":\"rmooizqse\",\"specification\":{},\"tasks\":[{\"name\":\"tcxapzhyrpetogeb\",\"specification\":{}},{\"name\":\"oxslh\",\"specification\":{}},{\"name\":\"nhl\",\"specification\":{}}],\"taskOption\":{}},{\"name\":\"rqnkkzjcjbtr\",\"specification\":{},\"tasks\":[{\"name\":\"vibr\",\"specification\":{}}],\"taskOption\":{}}],\"reviewId\":\"s\",\"state\":\"ReadyToUpgrade\",\"specification\":{},\"provisioningState\":\"Canceled\"},\"extendedLocation\":{\"name\":\"kxzt\",\"type\":\"CustomLocation\"},\"eTag\":\"bklftidgfcwqmpim\",\"id\":\"xzhemjyh\",\"name\":\"hujswtwkozzwcul\",\"type\":\"bawpfajnjwltlwt\"},{\"properties\":{\"revision\":1694247660,\"configuration\":\"talhsnvkcdmxzr\",\"stageSpec\":[{\"name\":\"aimlnwiaaom\",\"specification\":{},\"tasks\":[{\"name\":\"z\",\"specification\":{}}],\"taskOption\":{}},{\"name\":\"cse\",\"specification\":{},\"tasks\":[{\"name\":\"pjhlf\",\"specification\":{}},{\"name\":\"swpchwahfbousn\",\"specification\":{}},{\"name\":\"epgfew\",\"specification\":{}},{\"name\":\"twly\",\"specification\":{}}],\"taskOption\":{}}],\"reviewId\":\"cxy\",\"state\":\"ReadyToDeploy\",\"specification\":{},\"provisioningState\":\"Failed\"},\"extendedLocation\":{\"name\":\"mmbcxfhbcp\",\"type\":\"EdgeZone\"},\"eTag\":\"vxcjzhqizxfpxtgq\",\"id\":\"javftjuhdqa\",\"name\":\"k\",\"type\":\"tgguwpijrajcivmm\"}],\"nextLink\":\"f\"}")
            .toObject(WorkflowVersionListResult.class);
        Assertions.assertEquals("efojyqdhcupl", model.value().get(0).properties().stageSpec().get(0).name());
        Assertions.assertEquals("khihihlhzds",
            model.value().get(0).properties().stageSpec().get(0).tasks().get(0).name());
        Assertions.assertEquals("ivqikfxcvhr", model.value().get(0).extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, model.value().get(0).extendedLocation().type());
        Assertions.assertEquals("f", model.nextLink());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionPropertiesTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.util.BinaryData;
import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ErrorActionMode;
import com.azure.resourcemanager.workloadorchestration.models.StageSpec;
import com.azure.resourcemanager.workloadorchestration.models.TaskOption;
import com.azure.resourcemanager.workloadorchestration.models.TaskSpec;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;

public final class WorkflowVersionPropertiesTests {
    @org.junit.jupiter.api.Test
    public void testDeserialize() throws Exception {
        WorkflowVersionProperties model = BinaryData.fromString(
            "{\"revision\":811580474,\"configuration\":\"rdcnifmzzsdy\",\"stageSpec\":[{\"name\":\"rnysux\",\"specification\":{},\"tasks\":[{\"name\":\"wgck\",\"targetId\":\"cxvdfffwafqrouda\",\"specification\":{}},{\"name\":\"avehhrvkbunzo\",\"targetId\":\"dhcxgkmoy\",\"specification\":{}},{\"name\":\"dyuib\",\"targetId\":\"fdn\",\"specification\":{}},{\"name\":\"ydvfvfcjnae\",\"targetId\":\"srvhmgorffuki\",\"specification\":{}}],\"taskOption\":{\"concurrency\":1204565564,\"errorAction\":{\"mode\":\"silentlyContinue\",\"maxToleratedFailures\":1363348487}}}],\"reviewId\":\"faxvxil\",\"state\":\"InReview\",\"specification\":{},\"provisioningState\":\"Failed\"}")
            .toObject(WorkflowVersionProperties.class);
        Assertions.assertEquals("rnysux", model.stageSpec().get(0).name());
        Assertions.assertEquals("wgck", model.stageSpec().get(0).tasks().get(0).name());
        Assertions.assertEquals("cxvdfffwafqrouda", model.stageSpec().get(0).tasks().get(0).targetId());
        Assertions.assertEquals(1204565564, model.stageSpec().get(0).taskOption().concurrency());
        Assertions.assertEquals(ErrorActionMode.SILENTLY_CONTINUE,
            model.stageSpec().get(0).taskOption().errorAction().mode());
        Assertions.assertEquals(1363348487, model.stageSpec().get(0).taskOption().errorAction().maxToleratedFailures());
    }

    @org.junit.jupiter.api.Test
    public void testSerialize() throws Exception {
        WorkflowVersionProperties model
            = new WorkflowVersionProperties().withStageSpec(Arrays.asList(new StageSpec().withName("rnysux")
                .withSpecification(mapOf())
                .withTasks(Arrays.asList(
                    new TaskSpec().withName("wgck").withTargetId("cxvdfffwafqrouda").withSpecification(mapOf()),
                    new TaskSpec().withName("avehhrvkbunzo").withTargetId("dhcxgkmoy").withSpecification(mapOf()),
                    new TaskSpec().withName("dyuib").withTargetId("fdn").withSpecification(mapOf()),
                    new TaskSpec().withName("ydvfvfcjnae").withTargetId("srvhmgorffuki").withSpecification(mapOf())))
                .withTaskOption(new TaskOption().withConcurrency(1204565564)
                    .withErrorAction(new ErrorAction().withMode(ErrorActionMode.SILENTLY_CONTINUE)
                        .withMaxToleratedFailures(1363348487)))))
                .withSpecification(mapOf());
        model = BinaryData.fromObject(model).toObject(WorkflowVersionProperties.class);
        Assertions.assertEquals("rnysux", model.stageSpec().get(0).name());
        Assertions.assertEquals("wgck", model.stageSpec().get(0).tasks().get(0).name());
        Assertions.assertEquals("cxvdfffwafqrouda", model.stageSpec().get(0).tasks().get(0).targetId());
        Assertions.assertEquals(1204565564, model.stageSpec().get(0).taskOption().concurrency());
        Assertions.assertEquals(ErrorActionMode.SILENTLY_CONTINUE,
            model.stageSpec().get(0).taskOption().errorAction().mode());
        Assertions.assertEquals(1363348487, model.stageSpec().get(0).taskOption().errorAction().maxToleratedFailures());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionsCreateOrUpdateMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ErrorAction;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocation;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.StageSpec;
import com.azure.resourcemanager.workloadorchestration.models.TaskOption;
import com.azure.resourcemanager.workloadorchestration.models.TaskSpec;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersion;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersionProperties;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class WorkflowVersionsCreateOrUpdateMockTests {
    @Test
    public void testCreateOrUpdate() throws Exception {
        String responseStr
            = "{\"properties\":{\"revision\":1589873134,\"configuration\":\"cm\",\"stageSpec\":[{\"name\":\"rndb\",\"specification\":{},\"tasks\":[{\"name\":\"fltfnnxr\",\"specification\":{}},{\"name\":\"adj\",\"specification\":{}},{\"name\":\"ynnfmuiii\",\"specification\":{}},{\"name\":\"ipfohykfkx\",\"specification\":{}}],\"taskOption\":{\"concurrency\":1232113097,\"errorAction\":{}}},{\"name\":\"wjiutgnjiz\",\"specification\":{},\"tasks\":[{\"name\":\"iy\",\"specification\":{}},{\"name\":\"rvzb\",\"specification\":{}},{\"name\":\"uyrsrziuctix\",\"specification\":{}},{\"name\":\"bdsuifr\",\"specification\":{}}],\"taskOption\":{\"concurrency\":1996304749,\"errorAction\":{}}},{\"name\":\"pezkis\",\"specification\":{},\"tasks\":[{\"name\":\"g\",\"specification\":{}},{\"name\":\"syparybjufp\",\"specification\":{}}],\"taskOption\":{\"concurrency\":1317353251,\"errorAction\":{}}},{\"name\":\"jnciui\",\"specification\":{},\"tasks\":[{\"name\":\"aswvppis\",\"specification\":{}},{\"name\":\"qzlgcndhzxrrfcfs\",\"specification\":{}}],\"taskOption\":{\"concurrency\":809769529,\"errorAction\":{}}}],\"reviewId\":\"nxu\",\"state\":\"UpgradeInReview\",\"specification\":{},\"provisioningState\":\"Succeeded\"},\"extendedLocation\":{\"name\":\"sbzxl\",\"type\":\"CustomLocation\"},\"eTag\":\"omeikjcl\",\"id\":\"acnmwpfsuqtaaz\",\"name\":\"qbxyxoyfpuqqi\",\"type\":\"ezxlhdjzqdca\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        WorkflowVersion response = manager.workflowVersions()
            .define("jcx")
            .withExistingWorkflow("ktyjmf", "zlfsyqkfrbzgowo", "qmje")
            .withProperties(new WorkflowVersionProperties()
                .withStageSpec(Arrays.asList(new StageSpec()
                    .withName("ceagbjqvlsumywz")
                    .withSpecification(mapOf())
                    .withTasks(Arrays.asList(new TaskSpec().withName("onoyjf").withSpecification(mapOf())))
                    .withTaskOption(new TaskOption().withConcurrency(1141136911).withErrorAction(new ErrorAction())),
                    new StageSpec().withName("yznclkfkee")
                        .withSpecification(mapOf())
                        .withTasks(Arrays.asList(new TaskSpec().withName("e").withSpecification(mapOf()),
                            new TaskSpec().withName("tuoqujlyegqavni").withSpecification(mapOf())))
                        .withTaskOption(
                            new TaskOption().withConcurrency(1510649527).withErrorAction(new ErrorAction()))))
                .withSpecification(mapOf()))
            .withExtendedLocation(
                new ExtendedLocation().withName("vabm").withType(ExtendedLocationType.CUSTOM_LOCATION))
            .create();

        Assertions.assertEquals("rndb", response.properties().stageSpec().get(0).name());
        Assertions.assertEquals("fltfnnxr", response.properties().stageSpec().get(0).tasks().get(0).name());
        Assertions.assertEquals(1232113097, response.properties().stageSpec().get(0).taskOption().concurrency());
        Assertions.assertEquals("sbzxl", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, response.extendedLocation().type());
    }

    // Use "Map.of" if available
    @SuppressWarnings("unchecked")
    private static <T> Map<String, T> mapOf(Object... inputs) {
        Map<String, T> map = new HashMap<>();
        for (int i = 0; i < inputs.length; i += 2) {
            String key = (String) inputs[i];
            T value = (T) inputs[i + 1];
            map.put(key, value);
        }
        return map;
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionsGetWithResponseMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersion;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class WorkflowVersionsGetWithResponseMockTests {
    @Test
    public void testGetWithResponse() throws Exception {
        String responseStr
            = "{\"properties\":{\"revision\":1660876742,\"configuration\":\"dkkgjiiytssikizb\",\"stageSpec\":[{\"name\":\"fqb\",\"specification\":{},\"tasks\":[{\"name\":\"gmqsorhcekxg\",\"specification\":{}},{\"name\":\"lykmxcpwzvmdo\",\"specification\":{}}],\"taskOption\":{\"concurrency\":502016456,\"errorAction\":{}}},{\"name\":\"iw\",\"specification\":{},\"tasks\":[{\"name\":\"oncqbazqicqch\",\"specification\":{}},{\"name\":\"gtvxbyj\",\"specification\":{}},{\"name\":\"nepubdpkxyqvgx\",\"specification\":{}}],\"taskOption\":{\"concurrency\":1008631704,\"errorAction\":{}}},{\"name\":\"tvo\",\"specification\":{},\"tasks\":[{\"name\":\"uwsaifmcwn\",\"specification\":{}},{\"name\":\"s\",\"specification\":{}}],\"taskOption\":{\"concurrency\":914020378,\"errorAction\":{}}}],\"reviewId\":\"cvk\",\"state\":\"ExternalValidationFailed\",\"specification\":{},\"provisioningState\":\"Canceled\"},\"extendedLocation\":{\"name\":\"jy\",\"type\":\"CustomLocation\"},\"eTag\":\"velsz\",\"id\":\"qzevxoqeint\",\"name\":\"waljglzoblqwaaf\",\"type\":\"qulhmzy\"}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        WorkflowVersion response = manager.workflowVersions()
            .getWithResponse("lhjym", "cgqtag", "rclsso", "jomevtfycnlb", com.azure.core.util.Context.NONE)
            .getValue();

        Assertions.assertEquals("fqb", response.properties().stageSpec().get(0).name());
        Assertions.assertEquals("gmqsorhcekxg", response.properties().stageSpec().get(0).tasks().get(0).name());
        Assertions.assertEquals(502016456, response.properties().stageSpec().get(0).taskOption().concurrency());
        Assertions.assertEquals("jy", response.extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.CUSTOM_LOCATION, response.extendedLocation().type());
    }
}



================================================
FILE: azure-resourcemanager-workloadorchestration/src/test/java/com/azure/resourcemanager/workloadorchestration/generated/WorkflowVersionsListByWorkflowMockTests.java
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.resourcemanager.workloadorchestration.generated;

import com.azure.core.credential.AccessToken;
import com.azure.core.http.HttpClient;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.management.profile.AzureProfile;
import com.azure.core.models.AzureCloud;
import com.azure.core.test.http.MockHttpResponse;
import com.azure.resourcemanager.workloadorchestration.WorkloadOrchestrationManager;
import com.azure.resourcemanager.workloadorchestration.models.ExtendedLocationType;
import com.azure.resourcemanager.workloadorchestration.models.WorkflowVersion;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;

public final class WorkflowVersionsListByWorkflowMockTests {
    @Test
    public void testListByWorkflow() throws Exception {
        String responseStr
            = "{\"value\":[{\"properties\":{\"revision\":1995657676,\"configuration\":\"saetgzdgvpyig\",\"stageSpec\":[{\"name\":\"qqil\",\"specification\":{},\"tasks\":[{\"name\":\"wjoe\",\"specification\":{}},{\"name\":\"xngucaifpaurwwgi\",\"specification\":{}},{\"name\":\"fjqq\",\"specification\":{}}],\"taskOption\":{\"concurrency\":2083533019,\"errorAction\":{}}},{\"name\":\"xwxdcvjwc\",\"specification\":{},\"tasks\":[{\"name\":\"eciqchxr\",\"specification\":{}},{\"name\":\"uicdsiwdfmmpzhzz\",\"specification\":{}},{\"name\":\"vywrgyngydgr\",\"specification\":{}},{\"name\":\"x\",\"specification\":{}}],\"taskOption\":{\"concurrency\":84373044,\"errorAction\":{}}},{\"name\":\"qao\",\"specification\":{},\"tasks\":[{\"name\":\"clamgglvlmfejdoq\",\"specification\":{}},{\"name\":\"ykglt\",\"specification\":{}},{\"name\":\"gxhqfgqkayejs\",\"specification\":{}}],\"taskOption\":{\"concurrency\":1396514650,\"errorAction\":{}}},{\"name\":\"lwfgziiu\",\"specification\":{},\"tasks\":[{\"name\":\"eatlijjjrtvamcas\",\"specification\":{}},{\"name\":\"knxkvccxetyvkunm\",\"specification\":{}},{\"name\":\"gno\",\"specification\":{}},{\"name\":\"ikkgqo\",\"specification\":{}}],\"taskOption\":{\"concurrency\":1080786088,\"errorAction\":{}}}],\"reviewId\":\"dedvabbxbhme\",\"state\":\"Deploying\",\"specification\":{},\"provisioningState\":\"Deleting\"},\"extendedLocation\":{\"name\":\"fcfxzirzzihvwy\",\"type\":\"EdgeZone\"},\"eTag\":\"u\",\"id\":\"slczwciidjsllf\",\"name\":\"yvdmvx\",\"type\":\"dqacfrgnawbabgf\"}]}";

        HttpClient httpClient
            = response -> Mono.just(new MockHttpResponse(response, 200, responseStr.getBytes(StandardCharsets.UTF_8)));
        WorkloadOrchestrationManager manager = WorkloadOrchestrationManager.configure()
            .withHttpClient(httpClient)
            .authenticate(tokenRequestContext -> Mono.just(new AccessToken("this_is_a_token", OffsetDateTime.MAX)),
                new AzureProfile("", "", AzureCloud.AZURE_PUBLIC_CLOUD));

        PagedIterable<WorkflowVersion> response = manager.workflowVersions()
            .listByWorkflow("bhdvafjrqpjiy", "qjcrgaxwmzwdf", "bnrzorpdltbqctq", com.azure.core.util.Context.NONE);

        Assertions.assertEquals("qqil", response.iterator().next().properties().stageSpec().get(0).name());
        Assertions.assertEquals("wjoe",
            response.iterator().next().properties().stageSpec().get(0).tasks().get(0).name());
        Assertions.assertEquals(2083533019,
            response.iterator().next().properties().stageSpec().get(0).taskOption().concurrency());
        Assertions.assertEquals("fcfxzirzzihvwy", response.iterator().next().extendedLocation().name());
        Assertions.assertEquals(ExtendedLocationType.EDGE_ZONE, response.iterator().next().extendedLocation().type());
    }
}


