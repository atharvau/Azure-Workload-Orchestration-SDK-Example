(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/configtemplates_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// ConfigTemplatesServer is a fake server for instances of the armworkloadorchestration.ConfigTemplatesClient type.
type ConfigTemplatesServer struct {
	// BeginCreateOrUpdate is the fake for method ConfigTemplatesClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, configTemplateName string, resource armworkloadorchestration.ConfigTemplate, options *armworkloadorchestration.ConfigTemplatesClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.ConfigTemplatesClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginCreateVersion is the fake for method ConfigTemplatesClient.BeginCreateVersion
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginCreateVersion func(ctx context.Context, resourceGroupName string, configTemplateName string, body armworkloadorchestration.ConfigTemplateVersionWithUpdateType, options *armworkloadorchestration.ConfigTemplatesClientBeginCreateVersionOptions) (resp azfake.PollerResponder[armworkloadorchestration.ConfigTemplatesClientCreateVersionResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method ConfigTemplatesClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, configTemplateName string, options *armworkloadorchestration.ConfigTemplatesClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.ConfigTemplatesClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method ConfigTemplatesClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, configTemplateName string, options *armworkloadorchestration.ConfigTemplatesClientGetOptions) (resp azfake.Responder[armworkloadorchestration.ConfigTemplatesClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByResourceGroupPager is the fake for method ConfigTemplatesClient.NewListByResourceGroupPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByResourceGroupPager func(resourceGroupName string, options *armworkloadorchestration.ConfigTemplatesClientListByResourceGroupOptions) (resp azfake.PagerResponder[armworkloadorchestration.ConfigTemplatesClientListByResourceGroupResponse])

	// NewListBySubscriptionPager is the fake for method ConfigTemplatesClient.NewListBySubscriptionPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySubscriptionPager func(options *armworkloadorchestration.ConfigTemplatesClientListBySubscriptionOptions) (resp azfake.PagerResponder[armworkloadorchestration.ConfigTemplatesClientListBySubscriptionResponse])

	// RemoveVersion is the fake for method ConfigTemplatesClient.RemoveVersion
	// HTTP status codes to indicate success: http.StatusOK
	RemoveVersion func(ctx context.Context, resourceGroupName string, configTemplateName string, body armworkloadorchestration.VersionParameter, options *armworkloadorchestration.ConfigTemplatesClientRemoveVersionOptions) (resp azfake.Responder[armworkloadorchestration.ConfigTemplatesClientRemoveVersionResponse], errResp azfake.ErrorResponder)

	// Update is the fake for method ConfigTemplatesClient.Update
	// HTTP status codes to indicate success: http.StatusOK
	Update func(ctx context.Context, resourceGroupName string, configTemplateName string, properties armworkloadorchestration.ConfigTemplateUpdate, options *armworkloadorchestration.ConfigTemplatesClientUpdateOptions) (resp azfake.Responder[armworkloadorchestration.ConfigTemplatesClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewConfigTemplatesServerTransport creates a new instance of ConfigTemplatesServerTransport with the provided implementation.
// The returned ConfigTemplatesServerTransport instance is connected to an instance of armworkloadorchestration.ConfigTemplatesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewConfigTemplatesServerTransport(srv *ConfigTemplatesServer) *ConfigTemplatesServerTransport {
	return &ConfigTemplatesServerTransport{
		srv:                         srv,
		beginCreateOrUpdate:         newTracker[azfake.PollerResponder[armworkloadorchestration.ConfigTemplatesClientCreateOrUpdateResponse]](),
		beginCreateVersion:          newTracker[azfake.PollerResponder[armworkloadorchestration.ConfigTemplatesClientCreateVersionResponse]](),
		beginDelete:                 newTracker[azfake.PollerResponder[armworkloadorchestration.ConfigTemplatesClientDeleteResponse]](),
		newListByResourceGroupPager: newTracker[azfake.PagerResponder[armworkloadorchestration.ConfigTemplatesClientListByResourceGroupResponse]](),
		newListBySubscriptionPager:  newTracker[azfake.PagerResponder[armworkloadorchestration.ConfigTemplatesClientListBySubscriptionResponse]](),
	}
}

// ConfigTemplatesServerTransport connects instances of armworkloadorchestration.ConfigTemplatesClient to instances of ConfigTemplatesServer.
// Don't use this type directly, use NewConfigTemplatesServerTransport instead.
type ConfigTemplatesServerTransport struct {
	srv                         *ConfigTemplatesServer
	beginCreateOrUpdate         *tracker[azfake.PollerResponder[armworkloadorchestration.ConfigTemplatesClientCreateOrUpdateResponse]]
	beginCreateVersion          *tracker[azfake.PollerResponder[armworkloadorchestration.ConfigTemplatesClientCreateVersionResponse]]
	beginDelete                 *tracker[azfake.PollerResponder[armworkloadorchestration.ConfigTemplatesClientDeleteResponse]]
	newListByResourceGroupPager *tracker[azfake.PagerResponder[armworkloadorchestration.ConfigTemplatesClientListByResourceGroupResponse]]
	newListBySubscriptionPager  *tracker[azfake.PagerResponder[armworkloadorchestration.ConfigTemplatesClientListBySubscriptionResponse]]
}

// Do implements the policy.Transporter interface for ConfigTemplatesServerTransport.
func (c *ConfigTemplatesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return c.dispatchToMethodFake(req, method)
}

func (c *ConfigTemplatesServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if configTemplatesServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = configTemplatesServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "ConfigTemplatesClient.BeginCreateOrUpdate":
				res.resp, res.err = c.dispatchBeginCreateOrUpdate(req)
			case "ConfigTemplatesClient.BeginCreateVersion":
				res.resp, res.err = c.dispatchBeginCreateVersion(req)
			case "ConfigTemplatesClient.BeginDelete":
				res.resp, res.err = c.dispatchBeginDelete(req)
			case "ConfigTemplatesClient.Get":
				res.resp, res.err = c.dispatchGet(req)
			case "ConfigTemplatesClient.NewListByResourceGroupPager":
				res.resp, res.err = c.dispatchNewListByResourceGroupPager(req)
			case "ConfigTemplatesClient.NewListBySubscriptionPager":
				res.resp, res.err = c.dispatchNewListBySubscriptionPager(req)
			case "ConfigTemplatesClient.RemoveVersion":
				res.resp, res.err = c.dispatchRemoveVersion(req)
			case "ConfigTemplatesClient.Update":
				res.resp, res.err = c.dispatchUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (c *ConfigTemplatesServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if c.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := c.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates/(?P<configTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.ConfigTemplate](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		configTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("configTemplateName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, configTemplateNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		c.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		c.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		c.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (c *ConfigTemplatesServerTransport) dispatchBeginCreateVersion(req *http.Request) (*http.Response, error) {
	if c.srv.BeginCreateVersion == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateVersion not implemented")}
	}
	beginCreateVersion := c.beginCreateVersion.get(req)
	if beginCreateVersion == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates/(?P<configTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/createVersion`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.ConfigTemplateVersionWithUpdateType](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		configTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("configTemplateName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginCreateVersion(req.Context(), resourceGroupNameParam, configTemplateNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateVersion = &respr
		c.beginCreateVersion.add(req, beginCreateVersion)
	}

	resp, err := server.PollerResponderNext(beginCreateVersion, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginCreateVersion.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateVersion) {
		c.beginCreateVersion.remove(req)
	}

	return resp, nil
}

func (c *ConfigTemplatesServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if c.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := c.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates/(?P<configTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		configTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("configTemplateName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginDelete(req.Context(), resourceGroupNameParam, configTemplateNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		c.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		c.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		c.beginDelete.remove(req)
	}

	return resp, nil
}

func (c *ConfigTemplatesServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if c.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates/(?P<configTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	configTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("configTemplateName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := c.srv.Get(req.Context(), resourceGroupNameParam, configTemplateNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).ConfigTemplate, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *ConfigTemplatesServerTransport) dispatchNewListByResourceGroupPager(req *http.Request) (*http.Response, error) {
	if c.srv.NewListByResourceGroupPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByResourceGroupPager not implemented")}
	}
	newListByResourceGroupPager := c.newListByResourceGroupPager.get(req)
	if newListByResourceGroupPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resp := c.srv.NewListByResourceGroupPager(resourceGroupNameParam, nil)
		newListByResourceGroupPager = &resp
		c.newListByResourceGroupPager.add(req, newListByResourceGroupPager)
		server.PagerResponderInjectNextLinks(newListByResourceGroupPager, req, func(page *armworkloadorchestration.ConfigTemplatesClientListByResourceGroupResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByResourceGroupPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		c.newListByResourceGroupPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByResourceGroupPager) {
		c.newListByResourceGroupPager.remove(req)
	}
	return resp, nil
}

func (c *ConfigTemplatesServerTransport) dispatchNewListBySubscriptionPager(req *http.Request) (*http.Response, error) {
	if c.srv.NewListBySubscriptionPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListBySubscriptionPager not implemented")}
	}
	newListBySubscriptionPager := c.newListBySubscriptionPager.get(req)
	if newListBySubscriptionPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resp := c.srv.NewListBySubscriptionPager(nil)
		newListBySubscriptionPager = &resp
		c.newListBySubscriptionPager.add(req, newListBySubscriptionPager)
		server.PagerResponderInjectNextLinks(newListBySubscriptionPager, req, func(page *armworkloadorchestration.ConfigTemplatesClientListBySubscriptionResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListBySubscriptionPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		c.newListBySubscriptionPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListBySubscriptionPager) {
		c.newListBySubscriptionPager.remove(req)
	}
	return resp, nil
}

func (c *ConfigTemplatesServerTransport) dispatchRemoveVersion(req *http.Request) (*http.Response, error) {
	if c.srv.RemoveVersion == nil {
		return nil, &nonRetriableError{errors.New("fake for method RemoveVersion not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates/(?P<configTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/removeVersion`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.VersionParameter](req)
	if err != nil {
		return nil, err
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	configTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("configTemplateName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := c.srv.RemoveVersion(req.Context(), resourceGroupNameParam, configTemplateNameParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).RemoveVersionResponse, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *ConfigTemplatesServerTransport) dispatchUpdate(req *http.Request) (*http.Response, error) {
	if c.srv.Update == nil {
		return nil, &nonRetriableError{errors.New("fake for method Update not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates/(?P<configTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.ConfigTemplateUpdate](req)
	if err != nil {
		return nil, err
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	configTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("configTemplateName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := c.srv.Update(req.Context(), resourceGroupNameParam, configTemplateNameParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).ConfigTemplate, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to ConfigTemplatesServerTransport
var configTemplatesServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/configtemplateversions_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// ConfigTemplateVersionsServer is a fake server for instances of the armworkloadorchestration.ConfigTemplateVersionsClient type.
type ConfigTemplateVersionsServer struct {
	// Get is the fake for method ConfigTemplateVersionsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, configTemplateName string, configTemplateVersionName string, options *armworkloadorchestration.ConfigTemplateVersionsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.ConfigTemplateVersionsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByConfigTemplatePager is the fake for method ConfigTemplateVersionsClient.NewListByConfigTemplatePager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByConfigTemplatePager func(resourceGroupName string, configTemplateName string, options *armworkloadorchestration.ConfigTemplateVersionsClientListByConfigTemplateOptions) (resp azfake.PagerResponder[armworkloadorchestration.ConfigTemplateVersionsClientListByConfigTemplateResponse])
}

// NewConfigTemplateVersionsServerTransport creates a new instance of ConfigTemplateVersionsServerTransport with the provided implementation.
// The returned ConfigTemplateVersionsServerTransport instance is connected to an instance of armworkloadorchestration.ConfigTemplateVersionsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewConfigTemplateVersionsServerTransport(srv *ConfigTemplateVersionsServer) *ConfigTemplateVersionsServerTransport {
	return &ConfigTemplateVersionsServerTransport{
		srv:                          srv,
		newListByConfigTemplatePager: newTracker[azfake.PagerResponder[armworkloadorchestration.ConfigTemplateVersionsClientListByConfigTemplateResponse]](),
	}
}

// ConfigTemplateVersionsServerTransport connects instances of armworkloadorchestration.ConfigTemplateVersionsClient to instances of ConfigTemplateVersionsServer.
// Don't use this type directly, use NewConfigTemplateVersionsServerTransport instead.
type ConfigTemplateVersionsServerTransport struct {
	srv                          *ConfigTemplateVersionsServer
	newListByConfigTemplatePager *tracker[azfake.PagerResponder[armworkloadorchestration.ConfigTemplateVersionsClientListByConfigTemplateResponse]]
}

// Do implements the policy.Transporter interface for ConfigTemplateVersionsServerTransport.
func (c *ConfigTemplateVersionsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return c.dispatchToMethodFake(req, method)
}

func (c *ConfigTemplateVersionsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if configTemplateVersionsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = configTemplateVersionsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "ConfigTemplateVersionsClient.Get":
				res.resp, res.err = c.dispatchGet(req)
			case "ConfigTemplateVersionsClient.NewListByConfigTemplatePager":
				res.resp, res.err = c.dispatchNewListByConfigTemplatePager(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (c *ConfigTemplateVersionsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if c.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates/(?P<configTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<configTemplateVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	configTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("configTemplateName")])
	if err != nil {
		return nil, err
	}
	configTemplateVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("configTemplateVersionName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := c.srv.Get(req.Context(), resourceGroupNameParam, configTemplateNameParam, configTemplateVersionNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).ConfigTemplateVersion, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *ConfigTemplateVersionsServerTransport) dispatchNewListByConfigTemplatePager(req *http.Request) (*http.Response, error) {
	if c.srv.NewListByConfigTemplatePager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByConfigTemplatePager not implemented")}
	}
	newListByConfigTemplatePager := c.newListByConfigTemplatePager.get(req)
	if newListByConfigTemplatePager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/configTemplates/(?P<configTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		configTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("configTemplateName")])
		if err != nil {
			return nil, err
		}
		resp := c.srv.NewListByConfigTemplatePager(resourceGroupNameParam, configTemplateNameParam, nil)
		newListByConfigTemplatePager = &resp
		c.newListByConfigTemplatePager.add(req, newListByConfigTemplatePager)
		server.PagerResponderInjectNextLinks(newListByConfigTemplatePager, req, func(page *armworkloadorchestration.ConfigTemplateVersionsClientListByConfigTemplateResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByConfigTemplatePager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		c.newListByConfigTemplatePager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByConfigTemplatePager) {
		c.newListByConfigTemplatePager.remove(req)
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to ConfigTemplateVersionsServerTransport
var configTemplateVersionsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/contexts_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// ContextsServer is a fake server for instances of the armworkloadorchestration.ContextsClient type.
type ContextsServer struct {
	// BeginCreateOrUpdate is the fake for method ContextsClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, contextName string, resource armworkloadorchestration.Context, options *armworkloadorchestration.ContextsClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.ContextsClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method ContextsClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, contextName string, options *armworkloadorchestration.ContextsClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.ContextsClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method ContextsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, contextName string, options *armworkloadorchestration.ContextsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.ContextsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByResourceGroupPager is the fake for method ContextsClient.NewListByResourceGroupPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByResourceGroupPager func(resourceGroupName string, options *armworkloadorchestration.ContextsClientListByResourceGroupOptions) (resp azfake.PagerResponder[armworkloadorchestration.ContextsClientListByResourceGroupResponse])

	// NewListBySubscriptionPager is the fake for method ContextsClient.NewListBySubscriptionPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySubscriptionPager func(options *armworkloadorchestration.ContextsClientListBySubscriptionOptions) (resp azfake.PagerResponder[armworkloadorchestration.ContextsClientListBySubscriptionResponse])

	// BeginUpdate is the fake for method ContextsClient.BeginUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdate func(ctx context.Context, resourceGroupName string, contextName string, properties armworkloadorchestration.ContextUpdate, options *armworkloadorchestration.ContextsClientBeginUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.ContextsClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewContextsServerTransport creates a new instance of ContextsServerTransport with the provided implementation.
// The returned ContextsServerTransport instance is connected to an instance of armworkloadorchestration.ContextsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewContextsServerTransport(srv *ContextsServer) *ContextsServerTransport {
	return &ContextsServerTransport{
		srv:                         srv,
		beginCreateOrUpdate:         newTracker[azfake.PollerResponder[armworkloadorchestration.ContextsClientCreateOrUpdateResponse]](),
		beginDelete:                 newTracker[azfake.PollerResponder[armworkloadorchestration.ContextsClientDeleteResponse]](),
		newListByResourceGroupPager: newTracker[azfake.PagerResponder[armworkloadorchestration.ContextsClientListByResourceGroupResponse]](),
		newListBySubscriptionPager:  newTracker[azfake.PagerResponder[armworkloadorchestration.ContextsClientListBySubscriptionResponse]](),
		beginUpdate:                 newTracker[azfake.PollerResponder[armworkloadorchestration.ContextsClientUpdateResponse]](),
	}
}

// ContextsServerTransport connects instances of armworkloadorchestration.ContextsClient to instances of ContextsServer.
// Don't use this type directly, use NewContextsServerTransport instead.
type ContextsServerTransport struct {
	srv                         *ContextsServer
	beginCreateOrUpdate         *tracker[azfake.PollerResponder[armworkloadorchestration.ContextsClientCreateOrUpdateResponse]]
	beginDelete                 *tracker[azfake.PollerResponder[armworkloadorchestration.ContextsClientDeleteResponse]]
	newListByResourceGroupPager *tracker[azfake.PagerResponder[armworkloadorchestration.ContextsClientListByResourceGroupResponse]]
	newListBySubscriptionPager  *tracker[azfake.PagerResponder[armworkloadorchestration.ContextsClientListBySubscriptionResponse]]
	beginUpdate                 *tracker[azfake.PollerResponder[armworkloadorchestration.ContextsClientUpdateResponse]]
}

// Do implements the policy.Transporter interface for ContextsServerTransport.
func (c *ContextsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return c.dispatchToMethodFake(req, method)
}

func (c *ContextsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if contextsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = contextsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "ContextsClient.BeginCreateOrUpdate":
				res.resp, res.err = c.dispatchBeginCreateOrUpdate(req)
			case "ContextsClient.BeginDelete":
				res.resp, res.err = c.dispatchBeginDelete(req)
			case "ContextsClient.Get":
				res.resp, res.err = c.dispatchGet(req)
			case "ContextsClient.NewListByResourceGroupPager":
				res.resp, res.err = c.dispatchNewListByResourceGroupPager(req)
			case "ContextsClient.NewListBySubscriptionPager":
				res.resp, res.err = c.dispatchNewListBySubscriptionPager(req)
			case "ContextsClient.BeginUpdate":
				res.resp, res.err = c.dispatchBeginUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (c *ContextsServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if c.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := c.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.Context](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, contextNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		c.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		c.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		c.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (c *ContextsServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if c.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := c.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginDelete(req.Context(), resourceGroupNameParam, contextNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		c.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		c.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		c.beginDelete.remove(req)
	}

	return resp, nil
}

func (c *ContextsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if c.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := c.srv.Get(req.Context(), resourceGroupNameParam, contextNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Context, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *ContextsServerTransport) dispatchNewListByResourceGroupPager(req *http.Request) (*http.Response, error) {
	if c.srv.NewListByResourceGroupPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByResourceGroupPager not implemented")}
	}
	newListByResourceGroupPager := c.newListByResourceGroupPager.get(req)
	if newListByResourceGroupPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resp := c.srv.NewListByResourceGroupPager(resourceGroupNameParam, nil)
		newListByResourceGroupPager = &resp
		c.newListByResourceGroupPager.add(req, newListByResourceGroupPager)
		server.PagerResponderInjectNextLinks(newListByResourceGroupPager, req, func(page *armworkloadorchestration.ContextsClientListByResourceGroupResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByResourceGroupPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		c.newListByResourceGroupPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByResourceGroupPager) {
		c.newListByResourceGroupPager.remove(req)
	}
	return resp, nil
}

func (c *ContextsServerTransport) dispatchNewListBySubscriptionPager(req *http.Request) (*http.Response, error) {
	if c.srv.NewListBySubscriptionPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListBySubscriptionPager not implemented")}
	}
	newListBySubscriptionPager := c.newListBySubscriptionPager.get(req)
	if newListBySubscriptionPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resp := c.srv.NewListBySubscriptionPager(nil)
		newListBySubscriptionPager = &resp
		c.newListBySubscriptionPager.add(req, newListBySubscriptionPager)
		server.PagerResponderInjectNextLinks(newListBySubscriptionPager, req, func(page *armworkloadorchestration.ContextsClientListBySubscriptionResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListBySubscriptionPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		c.newListBySubscriptionPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListBySubscriptionPager) {
		c.newListBySubscriptionPager.remove(req)
	}
	return resp, nil
}

func (c *ContextsServerTransport) dispatchBeginUpdate(req *http.Request) (*http.Response, error) {
	if c.srv.BeginUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdate not implemented")}
	}
	beginUpdate := c.beginUpdate.get(req)
	if beginUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.ContextUpdate](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := c.srv.BeginUpdate(req.Context(), resourceGroupNameParam, contextNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginUpdate = &respr
		c.beginUpdate.add(req, beginUpdate)
	}

	resp, err := server.PollerResponderNext(beginUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		c.beginUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginUpdate) {
		c.beginUpdate.remove(req)
	}

	return resp, nil
}

// set this to conditionally intercept incoming requests to ContextsServerTransport
var contextsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/diagnostics_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// DiagnosticsServer is a fake server for instances of the armworkloadorchestration.DiagnosticsClient type.
type DiagnosticsServer struct {
	// BeginCreateOrUpdate is the fake for method DiagnosticsClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, diagnosticName string, resource armworkloadorchestration.Diagnostic, options *armworkloadorchestration.DiagnosticsClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.DiagnosticsClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method DiagnosticsClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, diagnosticName string, options *armworkloadorchestration.DiagnosticsClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.DiagnosticsClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method DiagnosticsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, diagnosticName string, options *armworkloadorchestration.DiagnosticsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.DiagnosticsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByResourceGroupPager is the fake for method DiagnosticsClient.NewListByResourceGroupPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByResourceGroupPager func(resourceGroupName string, options *armworkloadorchestration.DiagnosticsClientListByResourceGroupOptions) (resp azfake.PagerResponder[armworkloadorchestration.DiagnosticsClientListByResourceGroupResponse])

	// NewListBySubscriptionPager is the fake for method DiagnosticsClient.NewListBySubscriptionPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySubscriptionPager func(options *armworkloadorchestration.DiagnosticsClientListBySubscriptionOptions) (resp azfake.PagerResponder[armworkloadorchestration.DiagnosticsClientListBySubscriptionResponse])

	// BeginUpdate is the fake for method DiagnosticsClient.BeginUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdate func(ctx context.Context, resourceGroupName string, diagnosticName string, properties armworkloadorchestration.DiagnosticUpdate, options *armworkloadorchestration.DiagnosticsClientBeginUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.DiagnosticsClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewDiagnosticsServerTransport creates a new instance of DiagnosticsServerTransport with the provided implementation.
// The returned DiagnosticsServerTransport instance is connected to an instance of armworkloadorchestration.DiagnosticsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewDiagnosticsServerTransport(srv *DiagnosticsServer) *DiagnosticsServerTransport {
	return &DiagnosticsServerTransport{
		srv:                         srv,
		beginCreateOrUpdate:         newTracker[azfake.PollerResponder[armworkloadorchestration.DiagnosticsClientCreateOrUpdateResponse]](),
		beginDelete:                 newTracker[azfake.PollerResponder[armworkloadorchestration.DiagnosticsClientDeleteResponse]](),
		newListByResourceGroupPager: newTracker[azfake.PagerResponder[armworkloadorchestration.DiagnosticsClientListByResourceGroupResponse]](),
		newListBySubscriptionPager:  newTracker[azfake.PagerResponder[armworkloadorchestration.DiagnosticsClientListBySubscriptionResponse]](),
		beginUpdate:                 newTracker[azfake.PollerResponder[armworkloadorchestration.DiagnosticsClientUpdateResponse]](),
	}
}

// DiagnosticsServerTransport connects instances of armworkloadorchestration.DiagnosticsClient to instances of DiagnosticsServer.
// Don't use this type directly, use NewDiagnosticsServerTransport instead.
type DiagnosticsServerTransport struct {
	srv                         *DiagnosticsServer
	beginCreateOrUpdate         *tracker[azfake.PollerResponder[armworkloadorchestration.DiagnosticsClientCreateOrUpdateResponse]]
	beginDelete                 *tracker[azfake.PollerResponder[armworkloadorchestration.DiagnosticsClientDeleteResponse]]
	newListByResourceGroupPager *tracker[azfake.PagerResponder[armworkloadorchestration.DiagnosticsClientListByResourceGroupResponse]]
	newListBySubscriptionPager  *tracker[azfake.PagerResponder[armworkloadorchestration.DiagnosticsClientListBySubscriptionResponse]]
	beginUpdate                 *tracker[azfake.PollerResponder[armworkloadorchestration.DiagnosticsClientUpdateResponse]]
}

// Do implements the policy.Transporter interface for DiagnosticsServerTransport.
func (d *DiagnosticsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return d.dispatchToMethodFake(req, method)
}

func (d *DiagnosticsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if diagnosticsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = diagnosticsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "DiagnosticsClient.BeginCreateOrUpdate":
				res.resp, res.err = d.dispatchBeginCreateOrUpdate(req)
			case "DiagnosticsClient.BeginDelete":
				res.resp, res.err = d.dispatchBeginDelete(req)
			case "DiagnosticsClient.Get":
				res.resp, res.err = d.dispatchGet(req)
			case "DiagnosticsClient.NewListByResourceGroupPager":
				res.resp, res.err = d.dispatchNewListByResourceGroupPager(req)
			case "DiagnosticsClient.NewListBySubscriptionPager":
				res.resp, res.err = d.dispatchNewListBySubscriptionPager(req)
			case "DiagnosticsClient.BeginUpdate":
				res.resp, res.err = d.dispatchBeginUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (d *DiagnosticsServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if d.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := d.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/diagnostics/(?P<diagnosticName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.Diagnostic](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		diagnosticNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("diagnosticName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, diagnosticNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		d.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		d.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		d.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (d *DiagnosticsServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if d.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := d.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/diagnostics/(?P<diagnosticName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		diagnosticNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("diagnosticName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginDelete(req.Context(), resourceGroupNameParam, diagnosticNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		d.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		d.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		d.beginDelete.remove(req)
	}

	return resp, nil
}

func (d *DiagnosticsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if d.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/diagnostics/(?P<diagnosticName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	diagnosticNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("diagnosticName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.Get(req.Context(), resourceGroupNameParam, diagnosticNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Diagnostic, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DiagnosticsServerTransport) dispatchNewListByResourceGroupPager(req *http.Request) (*http.Response, error) {
	if d.srv.NewListByResourceGroupPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByResourceGroupPager not implemented")}
	}
	newListByResourceGroupPager := d.newListByResourceGroupPager.get(req)
	if newListByResourceGroupPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/diagnostics`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resp := d.srv.NewListByResourceGroupPager(resourceGroupNameParam, nil)
		newListByResourceGroupPager = &resp
		d.newListByResourceGroupPager.add(req, newListByResourceGroupPager)
		server.PagerResponderInjectNextLinks(newListByResourceGroupPager, req, func(page *armworkloadorchestration.DiagnosticsClientListByResourceGroupResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByResourceGroupPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		d.newListByResourceGroupPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByResourceGroupPager) {
		d.newListByResourceGroupPager.remove(req)
	}
	return resp, nil
}

func (d *DiagnosticsServerTransport) dispatchNewListBySubscriptionPager(req *http.Request) (*http.Response, error) {
	if d.srv.NewListBySubscriptionPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListBySubscriptionPager not implemented")}
	}
	newListBySubscriptionPager := d.newListBySubscriptionPager.get(req)
	if newListBySubscriptionPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/diagnostics`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resp := d.srv.NewListBySubscriptionPager(nil)
		newListBySubscriptionPager = &resp
		d.newListBySubscriptionPager.add(req, newListBySubscriptionPager)
		server.PagerResponderInjectNextLinks(newListBySubscriptionPager, req, func(page *armworkloadorchestration.DiagnosticsClientListBySubscriptionResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListBySubscriptionPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		d.newListBySubscriptionPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListBySubscriptionPager) {
		d.newListBySubscriptionPager.remove(req)
	}
	return resp, nil
}

func (d *DiagnosticsServerTransport) dispatchBeginUpdate(req *http.Request) (*http.Response, error) {
	if d.srv.BeginUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdate not implemented")}
	}
	beginUpdate := d.beginUpdate.get(req)
	if beginUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/diagnostics/(?P<diagnosticName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.DiagnosticUpdate](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		diagnosticNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("diagnosticName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginUpdate(req.Context(), resourceGroupNameParam, diagnosticNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginUpdate = &respr
		d.beginUpdate.add(req, beginUpdate)
	}

	resp, err := server.PollerResponderNext(beginUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		d.beginUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginUpdate) {
		d.beginUpdate.remove(req)
	}

	return resp, nil
}

// set this to conditionally intercept incoming requests to DiagnosticsServerTransport
var diagnosticsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/dynamicschemas_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// DynamicSchemasServer is a fake server for instances of the armworkloadorchestration.DynamicSchemasClient type.
type DynamicSchemasServer struct {
	// BeginCreateOrUpdate is the fake for method DynamicSchemasClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, schemaName string, dynamicSchemaName string, resource armworkloadorchestration.DynamicSchema, options *armworkloadorchestration.DynamicSchemasClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.DynamicSchemasClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method DynamicSchemasClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, schemaName string, dynamicSchemaName string, options *armworkloadorchestration.DynamicSchemasClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.DynamicSchemasClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method DynamicSchemasClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, schemaName string, dynamicSchemaName string, options *armworkloadorchestration.DynamicSchemasClientGetOptions) (resp azfake.Responder[armworkloadorchestration.DynamicSchemasClientGetResponse], errResp azfake.ErrorResponder)

	// NewListBySchemaPager is the fake for method DynamicSchemasClient.NewListBySchemaPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySchemaPager func(resourceGroupName string, schemaName string, options *armworkloadorchestration.DynamicSchemasClientListBySchemaOptions) (resp azfake.PagerResponder[armworkloadorchestration.DynamicSchemasClientListBySchemaResponse])

	// Update is the fake for method DynamicSchemasClient.Update
	// HTTP status codes to indicate success: http.StatusOK
	Update func(ctx context.Context, resourceGroupName string, schemaName string, dynamicSchemaName string, properties armworkloadorchestration.DynamicSchema, options *armworkloadorchestration.DynamicSchemasClientUpdateOptions) (resp azfake.Responder[armworkloadorchestration.DynamicSchemasClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewDynamicSchemasServerTransport creates a new instance of DynamicSchemasServerTransport with the provided implementation.
// The returned DynamicSchemasServerTransport instance is connected to an instance of armworkloadorchestration.DynamicSchemasClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewDynamicSchemasServerTransport(srv *DynamicSchemasServer) *DynamicSchemasServerTransport {
	return &DynamicSchemasServerTransport{
		srv:                  srv,
		beginCreateOrUpdate:  newTracker[azfake.PollerResponder[armworkloadorchestration.DynamicSchemasClientCreateOrUpdateResponse]](),
		beginDelete:          newTracker[azfake.PollerResponder[armworkloadorchestration.DynamicSchemasClientDeleteResponse]](),
		newListBySchemaPager: newTracker[azfake.PagerResponder[armworkloadorchestration.DynamicSchemasClientListBySchemaResponse]](),
	}
}

// DynamicSchemasServerTransport connects instances of armworkloadorchestration.DynamicSchemasClient to instances of DynamicSchemasServer.
// Don't use this type directly, use NewDynamicSchemasServerTransport instead.
type DynamicSchemasServerTransport struct {
	srv                  *DynamicSchemasServer
	beginCreateOrUpdate  *tracker[azfake.PollerResponder[armworkloadorchestration.DynamicSchemasClientCreateOrUpdateResponse]]
	beginDelete          *tracker[azfake.PollerResponder[armworkloadorchestration.DynamicSchemasClientDeleteResponse]]
	newListBySchemaPager *tracker[azfake.PagerResponder[armworkloadorchestration.DynamicSchemasClientListBySchemaResponse]]
}

// Do implements the policy.Transporter interface for DynamicSchemasServerTransport.
func (d *DynamicSchemasServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return d.dispatchToMethodFake(req, method)
}

func (d *DynamicSchemasServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if dynamicSchemasServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = dynamicSchemasServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "DynamicSchemasClient.BeginCreateOrUpdate":
				res.resp, res.err = d.dispatchBeginCreateOrUpdate(req)
			case "DynamicSchemasClient.BeginDelete":
				res.resp, res.err = d.dispatchBeginDelete(req)
			case "DynamicSchemasClient.Get":
				res.resp, res.err = d.dispatchGet(req)
			case "DynamicSchemasClient.NewListBySchemaPager":
				res.resp, res.err = d.dispatchNewListBySchemaPager(req)
			case "DynamicSchemasClient.Update":
				res.resp, res.err = d.dispatchUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (d *DynamicSchemasServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if d.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := d.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas/(?P<dynamicSchemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.DynamicSchema](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		dynamicSchemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, schemaNameParam, dynamicSchemaNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		d.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		d.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		d.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (d *DynamicSchemasServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if d.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := d.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas/(?P<dynamicSchemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		dynamicSchemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginDelete(req.Context(), resourceGroupNameParam, schemaNameParam, dynamicSchemaNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		d.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		d.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		d.beginDelete.remove(req)
	}

	return resp, nil
}

func (d *DynamicSchemasServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if d.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas/(?P<dynamicSchemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
	if err != nil {
		return nil, err
	}
	dynamicSchemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.Get(req.Context(), resourceGroupNameParam, schemaNameParam, dynamicSchemaNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DynamicSchema, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DynamicSchemasServerTransport) dispatchNewListBySchemaPager(req *http.Request) (*http.Response, error) {
	if d.srv.NewListBySchemaPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListBySchemaPager not implemented")}
	}
	newListBySchemaPager := d.newListBySchemaPager.get(req)
	if newListBySchemaPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		resp := d.srv.NewListBySchemaPager(resourceGroupNameParam, schemaNameParam, nil)
		newListBySchemaPager = &resp
		d.newListBySchemaPager.add(req, newListBySchemaPager)
		server.PagerResponderInjectNextLinks(newListBySchemaPager, req, func(page *armworkloadorchestration.DynamicSchemasClientListBySchemaResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListBySchemaPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		d.newListBySchemaPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListBySchemaPager) {
		d.newListBySchemaPager.remove(req)
	}
	return resp, nil
}

func (d *DynamicSchemasServerTransport) dispatchUpdate(req *http.Request) (*http.Response, error) {
	if d.srv.Update == nil {
		return nil, &nonRetriableError{errors.New("fake for method Update not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas/(?P<dynamicSchemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.DynamicSchema](req)
	if err != nil {
		return nil, err
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
	if err != nil {
		return nil, err
	}
	dynamicSchemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.Update(req.Context(), resourceGroupNameParam, schemaNameParam, dynamicSchemaNameParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DynamicSchema, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to DynamicSchemasServerTransport
var dynamicSchemasServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/dynamicschemaversions_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// DynamicSchemaVersionsServer is a fake server for instances of the armworkloadorchestration.DynamicSchemaVersionsClient type.
type DynamicSchemaVersionsServer struct {
	// BeginCreateOrUpdate is the fake for method DynamicSchemaVersionsClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, schemaName string, dynamicSchemaName string, dynamicSchemaVersionName string, resource armworkloadorchestration.DynamicSchemaVersion, options *armworkloadorchestration.DynamicSchemaVersionsClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.DynamicSchemaVersionsClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method DynamicSchemaVersionsClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, schemaName string, dynamicSchemaName string, dynamicSchemaVersionName string, options *armworkloadorchestration.DynamicSchemaVersionsClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.DynamicSchemaVersionsClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method DynamicSchemaVersionsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, schemaName string, dynamicSchemaName string, dynamicSchemaVersionName string, options *armworkloadorchestration.DynamicSchemaVersionsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.DynamicSchemaVersionsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByDynamicSchemaPager is the fake for method DynamicSchemaVersionsClient.NewListByDynamicSchemaPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByDynamicSchemaPager func(resourceGroupName string, schemaName string, dynamicSchemaName string, options *armworkloadorchestration.DynamicSchemaVersionsClientListByDynamicSchemaOptions) (resp azfake.PagerResponder[armworkloadorchestration.DynamicSchemaVersionsClientListByDynamicSchemaResponse])

	// Update is the fake for method DynamicSchemaVersionsClient.Update
	// HTTP status codes to indicate success: http.StatusOK
	Update func(ctx context.Context, resourceGroupName string, schemaName string, dynamicSchemaName string, dynamicSchemaVersionName string, properties armworkloadorchestration.DynamicSchemaVersion, options *armworkloadorchestration.DynamicSchemaVersionsClientUpdateOptions) (resp azfake.Responder[armworkloadorchestration.DynamicSchemaVersionsClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewDynamicSchemaVersionsServerTransport creates a new instance of DynamicSchemaVersionsServerTransport with the provided implementation.
// The returned DynamicSchemaVersionsServerTransport instance is connected to an instance of armworkloadorchestration.DynamicSchemaVersionsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewDynamicSchemaVersionsServerTransport(srv *DynamicSchemaVersionsServer) *DynamicSchemaVersionsServerTransport {
	return &DynamicSchemaVersionsServerTransport{
		srv:                         srv,
		beginCreateOrUpdate:         newTracker[azfake.PollerResponder[armworkloadorchestration.DynamicSchemaVersionsClientCreateOrUpdateResponse]](),
		beginDelete:                 newTracker[azfake.PollerResponder[armworkloadorchestration.DynamicSchemaVersionsClientDeleteResponse]](),
		newListByDynamicSchemaPager: newTracker[azfake.PagerResponder[armworkloadorchestration.DynamicSchemaVersionsClientListByDynamicSchemaResponse]](),
	}
}

// DynamicSchemaVersionsServerTransport connects instances of armworkloadorchestration.DynamicSchemaVersionsClient to instances of DynamicSchemaVersionsServer.
// Don't use this type directly, use NewDynamicSchemaVersionsServerTransport instead.
type DynamicSchemaVersionsServerTransport struct {
	srv                         *DynamicSchemaVersionsServer
	beginCreateOrUpdate         *tracker[azfake.PollerResponder[armworkloadorchestration.DynamicSchemaVersionsClientCreateOrUpdateResponse]]
	beginDelete                 *tracker[azfake.PollerResponder[armworkloadorchestration.DynamicSchemaVersionsClientDeleteResponse]]
	newListByDynamicSchemaPager *tracker[azfake.PagerResponder[armworkloadorchestration.DynamicSchemaVersionsClientListByDynamicSchemaResponse]]
}

// Do implements the policy.Transporter interface for DynamicSchemaVersionsServerTransport.
func (d *DynamicSchemaVersionsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return d.dispatchToMethodFake(req, method)
}

func (d *DynamicSchemaVersionsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if dynamicSchemaVersionsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = dynamicSchemaVersionsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "DynamicSchemaVersionsClient.BeginCreateOrUpdate":
				res.resp, res.err = d.dispatchBeginCreateOrUpdate(req)
			case "DynamicSchemaVersionsClient.BeginDelete":
				res.resp, res.err = d.dispatchBeginDelete(req)
			case "DynamicSchemaVersionsClient.Get":
				res.resp, res.err = d.dispatchGet(req)
			case "DynamicSchemaVersionsClient.NewListByDynamicSchemaPager":
				res.resp, res.err = d.dispatchNewListByDynamicSchemaPager(req)
			case "DynamicSchemaVersionsClient.Update":
				res.resp, res.err = d.dispatchUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (d *DynamicSchemaVersionsServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if d.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := d.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas/(?P<dynamicSchemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<dynamicSchemaVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 6 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.DynamicSchemaVersion](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		dynamicSchemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaName")])
		if err != nil {
			return nil, err
		}
		dynamicSchemaVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaVersionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, schemaNameParam, dynamicSchemaNameParam, dynamicSchemaVersionNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		d.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		d.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		d.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (d *DynamicSchemaVersionsServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if d.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := d.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas/(?P<dynamicSchemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<dynamicSchemaVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 6 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		dynamicSchemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaName")])
		if err != nil {
			return nil, err
		}
		dynamicSchemaVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaVersionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginDelete(req.Context(), resourceGroupNameParam, schemaNameParam, dynamicSchemaNameParam, dynamicSchemaVersionNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		d.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		d.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		d.beginDelete.remove(req)
	}

	return resp, nil
}

func (d *DynamicSchemaVersionsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if d.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas/(?P<dynamicSchemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<dynamicSchemaVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 6 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
	if err != nil {
		return nil, err
	}
	dynamicSchemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaName")])
	if err != nil {
		return nil, err
	}
	dynamicSchemaVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaVersionName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.Get(req.Context(), resourceGroupNameParam, schemaNameParam, dynamicSchemaNameParam, dynamicSchemaVersionNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DynamicSchemaVersion, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DynamicSchemaVersionsServerTransport) dispatchNewListByDynamicSchemaPager(req *http.Request) (*http.Response, error) {
	if d.srv.NewListByDynamicSchemaPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByDynamicSchemaPager not implemented")}
	}
	newListByDynamicSchemaPager := d.newListByDynamicSchemaPager.get(req)
	if newListByDynamicSchemaPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas/(?P<dynamicSchemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		dynamicSchemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaName")])
		if err != nil {
			return nil, err
		}
		resp := d.srv.NewListByDynamicSchemaPager(resourceGroupNameParam, schemaNameParam, dynamicSchemaNameParam, nil)
		newListByDynamicSchemaPager = &resp
		d.newListByDynamicSchemaPager.add(req, newListByDynamicSchemaPager)
		server.PagerResponderInjectNextLinks(newListByDynamicSchemaPager, req, func(page *armworkloadorchestration.DynamicSchemaVersionsClientListByDynamicSchemaResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByDynamicSchemaPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		d.newListByDynamicSchemaPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByDynamicSchemaPager) {
		d.newListByDynamicSchemaPager.remove(req)
	}
	return resp, nil
}

func (d *DynamicSchemaVersionsServerTransport) dispatchUpdate(req *http.Request) (*http.Response, error) {
	if d.srv.Update == nil {
		return nil, &nonRetriableError{errors.New("fake for method Update not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/dynamicSchemas/(?P<dynamicSchemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<dynamicSchemaVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 6 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.DynamicSchemaVersion](req)
	if err != nil {
		return nil, err
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
	if err != nil {
		return nil, err
	}
	dynamicSchemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaName")])
	if err != nil {
		return nil, err
	}
	dynamicSchemaVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("dynamicSchemaVersionName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.Update(req.Context(), resourceGroupNameParam, schemaNameParam, dynamicSchemaNameParam, dynamicSchemaVersionNameParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DynamicSchemaVersion, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to DynamicSchemaVersionsServerTransport
var dynamicSchemaVersionsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/executions_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// ExecutionsServer is a fake server for instances of the armworkloadorchestration.ExecutionsClient type.
type ExecutionsServer struct {
	// BeginCreateOrUpdate is the fake for method ExecutionsClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, contextName string, workflowName string, versionName string, executionName string, resource armworkloadorchestration.Execution, options *armworkloadorchestration.ExecutionsClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.ExecutionsClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method ExecutionsClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, contextName string, workflowName string, versionName string, executionName string, options *armworkloadorchestration.ExecutionsClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.ExecutionsClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method ExecutionsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, contextName string, workflowName string, versionName string, executionName string, options *armworkloadorchestration.ExecutionsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.ExecutionsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByWorkflowVersionPager is the fake for method ExecutionsClient.NewListByWorkflowVersionPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByWorkflowVersionPager func(resourceGroupName string, contextName string, workflowName string, versionName string, options *armworkloadorchestration.ExecutionsClientListByWorkflowVersionOptions) (resp azfake.PagerResponder[armworkloadorchestration.ExecutionsClientListByWorkflowVersionResponse])

	// BeginUpdate is the fake for method ExecutionsClient.BeginUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdate func(ctx context.Context, resourceGroupName string, contextName string, workflowName string, versionName string, executionName string, properties armworkloadorchestration.Execution, options *armworkloadorchestration.ExecutionsClientBeginUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.ExecutionsClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewExecutionsServerTransport creates a new instance of ExecutionsServerTransport with the provided implementation.
// The returned ExecutionsServerTransport instance is connected to an instance of armworkloadorchestration.ExecutionsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewExecutionsServerTransport(srv *ExecutionsServer) *ExecutionsServerTransport {
	return &ExecutionsServerTransport{
		srv:                           srv,
		beginCreateOrUpdate:           newTracker[azfake.PollerResponder[armworkloadorchestration.ExecutionsClientCreateOrUpdateResponse]](),
		beginDelete:                   newTracker[azfake.PollerResponder[armworkloadorchestration.ExecutionsClientDeleteResponse]](),
		newListByWorkflowVersionPager: newTracker[azfake.PagerResponder[armworkloadorchestration.ExecutionsClientListByWorkflowVersionResponse]](),
		beginUpdate:                   newTracker[azfake.PollerResponder[armworkloadorchestration.ExecutionsClientUpdateResponse]](),
	}
}

// ExecutionsServerTransport connects instances of armworkloadorchestration.ExecutionsClient to instances of ExecutionsServer.
// Don't use this type directly, use NewExecutionsServerTransport instead.
type ExecutionsServerTransport struct {
	srv                           *ExecutionsServer
	beginCreateOrUpdate           *tracker[azfake.PollerResponder[armworkloadorchestration.ExecutionsClientCreateOrUpdateResponse]]
	beginDelete                   *tracker[azfake.PollerResponder[armworkloadorchestration.ExecutionsClientDeleteResponse]]
	newListByWorkflowVersionPager *tracker[azfake.PagerResponder[armworkloadorchestration.ExecutionsClientListByWorkflowVersionResponse]]
	beginUpdate                   *tracker[azfake.PollerResponder[armworkloadorchestration.ExecutionsClientUpdateResponse]]
}

// Do implements the policy.Transporter interface for ExecutionsServerTransport.
func (e *ExecutionsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return e.dispatchToMethodFake(req, method)
}

func (e *ExecutionsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if executionsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = executionsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "ExecutionsClient.BeginCreateOrUpdate":
				res.resp, res.err = e.dispatchBeginCreateOrUpdate(req)
			case "ExecutionsClient.BeginDelete":
				res.resp, res.err = e.dispatchBeginDelete(req)
			case "ExecutionsClient.Get":
				res.resp, res.err = e.dispatchGet(req)
			case "ExecutionsClient.NewListByWorkflowVersionPager":
				res.resp, res.err = e.dispatchNewListByWorkflowVersionPager(req)
			case "ExecutionsClient.BeginUpdate":
				res.resp, res.err = e.dispatchBeginUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (e *ExecutionsServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if e.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := e.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/workflows/(?P<workflowName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<versionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/executions/(?P<executionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 7 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.Execution](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		workflowNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("workflowName")])
		if err != nil {
			return nil, err
		}
		versionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("versionName")])
		if err != nil {
			return nil, err
		}
		executionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("executionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := e.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, contextNameParam, workflowNameParam, versionNameParam, executionNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		e.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		e.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		e.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (e *ExecutionsServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if e.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := e.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/workflows/(?P<workflowName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<versionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/executions/(?P<executionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 7 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		workflowNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("workflowName")])
		if err != nil {
			return nil, err
		}
		versionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("versionName")])
		if err != nil {
			return nil, err
		}
		executionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("executionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := e.srv.BeginDelete(req.Context(), resourceGroupNameParam, contextNameParam, workflowNameParam, versionNameParam, executionNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		e.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		e.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		e.beginDelete.remove(req)
	}

	return resp, nil
}

func (e *ExecutionsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if e.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/workflows/(?P<workflowName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<versionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/executions/(?P<executionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 7 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
	if err != nil {
		return nil, err
	}
	workflowNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("workflowName")])
	if err != nil {
		return nil, err
	}
	versionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("versionName")])
	if err != nil {
		return nil, err
	}
	executionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("executionName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := e.srv.Get(req.Context(), resourceGroupNameParam, contextNameParam, workflowNameParam, versionNameParam, executionNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Execution, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (e *ExecutionsServerTransport) dispatchNewListByWorkflowVersionPager(req *http.Request) (*http.Response, error) {
	if e.srv.NewListByWorkflowVersionPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByWorkflowVersionPager not implemented")}
	}
	newListByWorkflowVersionPager := e.newListByWorkflowVersionPager.get(req)
	if newListByWorkflowVersionPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/workflows/(?P<workflowName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<versionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/executions`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 6 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		workflowNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("workflowName")])
		if err != nil {
			return nil, err
		}
		versionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("versionName")])
		if err != nil {
			return nil, err
		}
		resp := e.srv.NewListByWorkflowVersionPager(resourceGroupNameParam, contextNameParam, workflowNameParam, versionNameParam, nil)
		newListByWorkflowVersionPager = &resp
		e.newListByWorkflowVersionPager.add(req, newListByWorkflowVersionPager)
		server.PagerResponderInjectNextLinks(newListByWorkflowVersionPager, req, func(page *armworkloadorchestration.ExecutionsClientListByWorkflowVersionResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByWorkflowVersionPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		e.newListByWorkflowVersionPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByWorkflowVersionPager) {
		e.newListByWorkflowVersionPager.remove(req)
	}
	return resp, nil
}

func (e *ExecutionsServerTransport) dispatchBeginUpdate(req *http.Request) (*http.Response, error) {
	if e.srv.BeginUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdate not implemented")}
	}
	beginUpdate := e.beginUpdate.get(req)
	if beginUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/workflows/(?P<workflowName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<versionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/executions/(?P<executionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 7 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.Execution](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		workflowNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("workflowName")])
		if err != nil {
			return nil, err
		}
		versionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("versionName")])
		if err != nil {
			return nil, err
		}
		executionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("executionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := e.srv.BeginUpdate(req.Context(), resourceGroupNameParam, contextNameParam, workflowNameParam, versionNameParam, executionNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginUpdate = &respr
		e.beginUpdate.add(req, beginUpdate)
	}

	resp, err := server.PollerResponderNext(beginUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		e.beginUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginUpdate) {
		e.beginUpdate.remove(req)
	}

	return resp, nil
}

// set this to conditionally intercept incoming requests to ExecutionsServerTransport
var executionsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/instancehistories_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// InstanceHistoriesServer is a fake server for instances of the armworkloadorchestration.InstanceHistoriesClient type.
type InstanceHistoriesServer struct {
	// Get is the fake for method InstanceHistoriesClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, instanceName string, instanceHistoryName string, options *armworkloadorchestration.InstanceHistoriesClientGetOptions) (resp azfake.Responder[armworkloadorchestration.InstanceHistoriesClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByInstancePager is the fake for method InstanceHistoriesClient.NewListByInstancePager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByInstancePager func(resourceGroupName string, targetName string, solutionName string, instanceName string, options *armworkloadorchestration.InstanceHistoriesClientListByInstanceOptions) (resp azfake.PagerResponder[armworkloadorchestration.InstanceHistoriesClientListByInstanceResponse])
}

// NewInstanceHistoriesServerTransport creates a new instance of InstanceHistoriesServerTransport with the provided implementation.
// The returned InstanceHistoriesServerTransport instance is connected to an instance of armworkloadorchestration.InstanceHistoriesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewInstanceHistoriesServerTransport(srv *InstanceHistoriesServer) *InstanceHistoriesServerTransport {
	return &InstanceHistoriesServerTransport{
		srv:                    srv,
		newListByInstancePager: newTracker[azfake.PagerResponder[armworkloadorchestration.InstanceHistoriesClientListByInstanceResponse]](),
	}
}

// InstanceHistoriesServerTransport connects instances of armworkloadorchestration.InstanceHistoriesClient to instances of InstanceHistoriesServer.
// Don't use this type directly, use NewInstanceHistoriesServerTransport instead.
type InstanceHistoriesServerTransport struct {
	srv                    *InstanceHistoriesServer
	newListByInstancePager *tracker[azfake.PagerResponder[armworkloadorchestration.InstanceHistoriesClientListByInstanceResponse]]
}

// Do implements the policy.Transporter interface for InstanceHistoriesServerTransport.
func (i *InstanceHistoriesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return i.dispatchToMethodFake(req, method)
}

func (i *InstanceHistoriesServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if instanceHistoriesServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = instanceHistoriesServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "InstanceHistoriesClient.Get":
				res.resp, res.err = i.dispatchGet(req)
			case "InstanceHistoriesClient.NewListByInstancePager":
				res.resp, res.err = i.dispatchNewListByInstancePager(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (i *InstanceHistoriesServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if i.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/instances/(?P<instanceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/histories/(?P<instanceHistoryName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 7 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
	if err != nil {
		return nil, err
	}
	solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
	if err != nil {
		return nil, err
	}
	instanceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("instanceName")])
	if err != nil {
		return nil, err
	}
	instanceHistoryNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("instanceHistoryName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := i.srv.Get(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, instanceNameParam, instanceHistoryNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).InstanceHistory, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (i *InstanceHistoriesServerTransport) dispatchNewListByInstancePager(req *http.Request) (*http.Response, error) {
	if i.srv.NewListByInstancePager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByInstancePager not implemented")}
	}
	newListByInstancePager := i.newListByInstancePager.get(req)
	if newListByInstancePager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/instances/(?P<instanceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/histories`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 6 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		instanceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("instanceName")])
		if err != nil {
			return nil, err
		}
		resp := i.srv.NewListByInstancePager(resourceGroupNameParam, targetNameParam, solutionNameParam, instanceNameParam, nil)
		newListByInstancePager = &resp
		i.newListByInstancePager.add(req, newListByInstancePager)
		server.PagerResponderInjectNextLinks(newListByInstancePager, req, func(page *armworkloadorchestration.InstanceHistoriesClientListByInstanceResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByInstancePager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		i.newListByInstancePager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByInstancePager) {
		i.newListByInstancePager.remove(req)
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to InstanceHistoriesServerTransport
var instanceHistoriesServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/instances_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// InstancesServer is a fake server for instances of the armworkloadorchestration.InstancesClient type.
type InstancesServer struct {
	// BeginCreateOrUpdate is the fake for method InstancesClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, instanceName string, resource armworkloadorchestration.Instance, options *armworkloadorchestration.InstancesClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.InstancesClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method InstancesClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, instanceName string, options *armworkloadorchestration.InstancesClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.InstancesClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method InstancesClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, instanceName string, options *armworkloadorchestration.InstancesClientGetOptions) (resp azfake.Responder[armworkloadorchestration.InstancesClientGetResponse], errResp azfake.ErrorResponder)

	// NewListBySolutionPager is the fake for method InstancesClient.NewListBySolutionPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySolutionPager func(resourceGroupName string, targetName string, solutionName string, options *armworkloadorchestration.InstancesClientListBySolutionOptions) (resp azfake.PagerResponder[armworkloadorchestration.InstancesClientListBySolutionResponse])

	// BeginUpdate is the fake for method InstancesClient.BeginUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdate func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, instanceName string, properties armworkloadorchestration.Instance, options *armworkloadorchestration.InstancesClientBeginUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.InstancesClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewInstancesServerTransport creates a new instance of InstancesServerTransport with the provided implementation.
// The returned InstancesServerTransport instance is connected to an instance of armworkloadorchestration.InstancesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewInstancesServerTransport(srv *InstancesServer) *InstancesServerTransport {
	return &InstancesServerTransport{
		srv:                    srv,
		beginCreateOrUpdate:    newTracker[azfake.PollerResponder[armworkloadorchestration.InstancesClientCreateOrUpdateResponse]](),
		beginDelete:            newTracker[azfake.PollerResponder[armworkloadorchestration.InstancesClientDeleteResponse]](),
		newListBySolutionPager: newTracker[azfake.PagerResponder[armworkloadorchestration.InstancesClientListBySolutionResponse]](),
		beginUpdate:            newTracker[azfake.PollerResponder[armworkloadorchestration.InstancesClientUpdateResponse]](),
	}
}

// InstancesServerTransport connects instances of armworkloadorchestration.InstancesClient to instances of InstancesServer.
// Don't use this type directly, use NewInstancesServerTransport instead.
type InstancesServerTransport struct {
	srv                    *InstancesServer
	beginCreateOrUpdate    *tracker[azfake.PollerResponder[armworkloadorchestration.InstancesClientCreateOrUpdateResponse]]
	beginDelete            *tracker[azfake.PollerResponder[armworkloadorchestration.InstancesClientDeleteResponse]]
	newListBySolutionPager *tracker[azfake.PagerResponder[armworkloadorchestration.InstancesClientListBySolutionResponse]]
	beginUpdate            *tracker[azfake.PollerResponder[armworkloadorchestration.InstancesClientUpdateResponse]]
}

// Do implements the policy.Transporter interface for InstancesServerTransport.
func (i *InstancesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return i.dispatchToMethodFake(req, method)
}

func (i *InstancesServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if instancesServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = instancesServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "InstancesClient.BeginCreateOrUpdate":
				res.resp, res.err = i.dispatchBeginCreateOrUpdate(req)
			case "InstancesClient.BeginDelete":
				res.resp, res.err = i.dispatchBeginDelete(req)
			case "InstancesClient.Get":
				res.resp, res.err = i.dispatchGet(req)
			case "InstancesClient.NewListBySolutionPager":
				res.resp, res.err = i.dispatchNewListBySolutionPager(req)
			case "InstancesClient.BeginUpdate":
				res.resp, res.err = i.dispatchBeginUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (i *InstancesServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if i.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := i.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/instances/(?P<instanceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 6 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.Instance](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		instanceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("instanceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := i.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, instanceNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		i.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		i.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		i.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (i *InstancesServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if i.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := i.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/instances/(?P<instanceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 6 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		instanceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("instanceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := i.srv.BeginDelete(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, instanceNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		i.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		i.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		i.beginDelete.remove(req)
	}

	return resp, nil
}

func (i *InstancesServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if i.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/instances/(?P<instanceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 6 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
	if err != nil {
		return nil, err
	}
	solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
	if err != nil {
		return nil, err
	}
	instanceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("instanceName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := i.srv.Get(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, instanceNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Instance, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (i *InstancesServerTransport) dispatchNewListBySolutionPager(req *http.Request) (*http.Response, error) {
	if i.srv.NewListBySolutionPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListBySolutionPager not implemented")}
	}
	newListBySolutionPager := i.newListBySolutionPager.get(req)
	if newListBySolutionPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/instances`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		resp := i.srv.NewListBySolutionPager(resourceGroupNameParam, targetNameParam, solutionNameParam, nil)
		newListBySolutionPager = &resp
		i.newListBySolutionPager.add(req, newListBySolutionPager)
		server.PagerResponderInjectNextLinks(newListBySolutionPager, req, func(page *armworkloadorchestration.InstancesClientListBySolutionResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListBySolutionPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		i.newListBySolutionPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListBySolutionPager) {
		i.newListBySolutionPager.remove(req)
	}
	return resp, nil
}

func (i *InstancesServerTransport) dispatchBeginUpdate(req *http.Request) (*http.Response, error) {
	if i.srv.BeginUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdate not implemented")}
	}
	beginUpdate := i.beginUpdate.get(req)
	if beginUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/instances/(?P<instanceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 6 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.Instance](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		instanceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("instanceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := i.srv.BeginUpdate(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, instanceNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginUpdate = &respr
		i.beginUpdate.add(req, beginUpdate)
	}

	resp, err := server.PollerResponderNext(beginUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		i.beginUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginUpdate) {
		i.beginUpdate.remove(req)
	}

	return resp, nil
}

// set this to conditionally intercept incoming requests to InstancesServerTransport
var instancesServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/internal.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"net/http"
	"sync"
)

type result struct {
	resp *http.Response
	err  error
}

type nonRetriableError struct {
	error
}

func (nonRetriableError) NonRetriable() {
	// marker method
}

func contains[T comparable](s []T, v T) bool {
	for _, vv := range s {
		if vv == v {
			return true
		}
	}
	return false
}

func parseOptional[T any](v string, parse func(v string) (T, error)) (*T, error) {
	if v == "" {
		return nil, nil
	}
	t, err := parse(v)
	if err != nil {
		return nil, err
	}
	return &t, err
}

func newTracker[T any]() *tracker[T] {
	return &tracker[T]{
		items: map[string]*T{},
	}
}

type tracker[T any] struct {
	items map[string]*T
	mu    sync.Mutex
}

func (p *tracker[T]) get(req *http.Request) *T {
	p.mu.Lock()
	defer p.mu.Unlock()
	if item, ok := p.items[server.SanitizePagerPollerPath(req.URL.Path)]; ok {
		return item
	}
	return nil
}

func (p *tracker[T]) add(req *http.Request, item *T) {
	p.mu.Lock()
	defer p.mu.Unlock()
	p.items[server.SanitizePagerPollerPath(req.URL.Path)] = item
}

func (p *tracker[T]) remove(req *http.Request) {
	p.mu.Lock()
	defer p.mu.Unlock()
	delete(p.items, server.SanitizePagerPollerPath(req.URL.Path))
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/jobs_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// JobsServer is a fake server for instances of the armworkloadorchestration.JobsClient type.
type JobsServer struct {
	// Get is the fake for method JobsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceURI string, jobName string, options *armworkloadorchestration.JobsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.JobsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByTargetPager is the fake for method JobsClient.NewListByTargetPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByTargetPager func(resourceURI string, options *armworkloadorchestration.JobsClientListByTargetOptions) (resp azfake.PagerResponder[armworkloadorchestration.JobsClientListByTargetResponse])
}

// NewJobsServerTransport creates a new instance of JobsServerTransport with the provided implementation.
// The returned JobsServerTransport instance is connected to an instance of armworkloadorchestration.JobsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewJobsServerTransport(srv *JobsServer) *JobsServerTransport {
	return &JobsServerTransport{
		srv:                  srv,
		newListByTargetPager: newTracker[azfake.PagerResponder[armworkloadorchestration.JobsClientListByTargetResponse]](),
	}
}

// JobsServerTransport connects instances of armworkloadorchestration.JobsClient to instances of JobsServer.
// Don't use this type directly, use NewJobsServerTransport instead.
type JobsServerTransport struct {
	srv                  *JobsServer
	newListByTargetPager *tracker[azfake.PagerResponder[armworkloadorchestration.JobsClientListByTargetResponse]]
}

// Do implements the policy.Transporter interface for JobsServerTransport.
func (j *JobsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return j.dispatchToMethodFake(req, method)
}

func (j *JobsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if jobsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = jobsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "JobsClient.Get":
				res.resp, res.err = j.dispatchGet(req)
			case "JobsClient.NewListByTargetPager":
				res.resp, res.err = j.dispatchNewListByTargetPager(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (j *JobsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if j.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/(?P<resourceUri>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/jobs/(?P<jobName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceURIParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceUri")])
	if err != nil {
		return nil, err
	}
	jobNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("jobName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := j.srv.Get(req.Context(), resourceURIParam, jobNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Job, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (j *JobsServerTransport) dispatchNewListByTargetPager(req *http.Request) (*http.Response, error) {
	if j.srv.NewListByTargetPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByTargetPager not implemented")}
	}
	newListByTargetPager := j.newListByTargetPager.get(req)
	if newListByTargetPager == nil {
		const regexStr = `/(?P<resourceUri>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/jobs`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceURIParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceUri")])
		if err != nil {
			return nil, err
		}
		resp := j.srv.NewListByTargetPager(resourceURIParam, nil)
		newListByTargetPager = &resp
		j.newListByTargetPager.add(req, newListByTargetPager)
		server.PagerResponderInjectNextLinks(newListByTargetPager, req, func(page *armworkloadorchestration.JobsClientListByTargetResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByTargetPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		j.newListByTargetPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByTargetPager) {
		j.newListByTargetPager.remove(req)
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to JobsServerTransport
var jobsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/schemareferences_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// SchemaReferencesServer is a fake server for instances of the armworkloadorchestration.SchemaReferencesClient type.
type SchemaReferencesServer struct {
	// Get is the fake for method SchemaReferencesClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceURI string, schemaReferenceName string, options *armworkloadorchestration.SchemaReferencesClientGetOptions) (resp azfake.Responder[armworkloadorchestration.SchemaReferencesClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByResourceGroupPager is the fake for method SchemaReferencesClient.NewListByResourceGroupPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByResourceGroupPager func(resourceURI string, options *armworkloadorchestration.SchemaReferencesClientListByResourceGroupOptions) (resp azfake.PagerResponder[armworkloadorchestration.SchemaReferencesClientListByResourceGroupResponse])
}

// NewSchemaReferencesServerTransport creates a new instance of SchemaReferencesServerTransport with the provided implementation.
// The returned SchemaReferencesServerTransport instance is connected to an instance of armworkloadorchestration.SchemaReferencesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewSchemaReferencesServerTransport(srv *SchemaReferencesServer) *SchemaReferencesServerTransport {
	return &SchemaReferencesServerTransport{
		srv:                         srv,
		newListByResourceGroupPager: newTracker[azfake.PagerResponder[armworkloadorchestration.SchemaReferencesClientListByResourceGroupResponse]](),
	}
}

// SchemaReferencesServerTransport connects instances of armworkloadorchestration.SchemaReferencesClient to instances of SchemaReferencesServer.
// Don't use this type directly, use NewSchemaReferencesServerTransport instead.
type SchemaReferencesServerTransport struct {
	srv                         *SchemaReferencesServer
	newListByResourceGroupPager *tracker[azfake.PagerResponder[armworkloadorchestration.SchemaReferencesClientListByResourceGroupResponse]]
}

// Do implements the policy.Transporter interface for SchemaReferencesServerTransport.
func (s *SchemaReferencesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToMethodFake(req, method)
}

func (s *SchemaReferencesServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if schemaReferencesServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = schemaReferencesServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "SchemaReferencesClient.Get":
				res.resp, res.err = s.dispatchGet(req)
			case "SchemaReferencesClient.NewListByResourceGroupPager":
				res.resp, res.err = s.dispatchNewListByResourceGroupPager(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *SchemaReferencesServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if s.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/(?P<resourceUri>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemaReferences/(?P<schemaReferenceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceURIParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceUri")])
	if err != nil {
		return nil, err
	}
	schemaReferenceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaReferenceName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Get(req.Context(), resourceURIParam, schemaReferenceNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SchemaReference, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SchemaReferencesServerTransport) dispatchNewListByResourceGroupPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewListByResourceGroupPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByResourceGroupPager not implemented")}
	}
	newListByResourceGroupPager := s.newListByResourceGroupPager.get(req)
	if newListByResourceGroupPager == nil {
		const regexStr = `/(?P<resourceUri>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemaReferences`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceURIParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceUri")])
		if err != nil {
			return nil, err
		}
		resp := s.srv.NewListByResourceGroupPager(resourceURIParam, nil)
		newListByResourceGroupPager = &resp
		s.newListByResourceGroupPager.add(req, newListByResourceGroupPager)
		server.PagerResponderInjectNextLinks(newListByResourceGroupPager, req, func(page *armworkloadorchestration.SchemaReferencesClientListByResourceGroupResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByResourceGroupPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		s.newListByResourceGroupPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByResourceGroupPager) {
		s.newListByResourceGroupPager.remove(req)
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to SchemaReferencesServerTransport
var schemaReferencesServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/schemas_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// SchemasServer is a fake server for instances of the armworkloadorchestration.SchemasClient type.
type SchemasServer struct {
	// BeginCreateOrUpdate is the fake for method SchemasClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, schemaName string, resource armworkloadorchestration.Schema, options *armworkloadorchestration.SchemasClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.SchemasClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginCreateVersion is the fake for method SchemasClient.BeginCreateVersion
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginCreateVersion func(ctx context.Context, resourceGroupName string, schemaName string, body armworkloadorchestration.SchemaVersionWithUpdateType, options *armworkloadorchestration.SchemasClientBeginCreateVersionOptions) (resp azfake.PollerResponder[armworkloadorchestration.SchemasClientCreateVersionResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method SchemasClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, schemaName string, options *armworkloadorchestration.SchemasClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.SchemasClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method SchemasClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, schemaName string, options *armworkloadorchestration.SchemasClientGetOptions) (resp azfake.Responder[armworkloadorchestration.SchemasClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByResourceGroupPager is the fake for method SchemasClient.NewListByResourceGroupPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByResourceGroupPager func(resourceGroupName string, options *armworkloadorchestration.SchemasClientListByResourceGroupOptions) (resp azfake.PagerResponder[armworkloadorchestration.SchemasClientListByResourceGroupResponse])

	// NewListBySubscriptionPager is the fake for method SchemasClient.NewListBySubscriptionPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySubscriptionPager func(options *armworkloadorchestration.SchemasClientListBySubscriptionOptions) (resp azfake.PagerResponder[armworkloadorchestration.SchemasClientListBySubscriptionResponse])

	// RemoveVersion is the fake for method SchemasClient.RemoveVersion
	// HTTP status codes to indicate success: http.StatusOK
	RemoveVersion func(ctx context.Context, resourceGroupName string, schemaName string, body armworkloadorchestration.VersionParameter, options *armworkloadorchestration.SchemasClientRemoveVersionOptions) (resp azfake.Responder[armworkloadorchestration.SchemasClientRemoveVersionResponse], errResp azfake.ErrorResponder)

	// Update is the fake for method SchemasClient.Update
	// HTTP status codes to indicate success: http.StatusOK
	Update func(ctx context.Context, resourceGroupName string, schemaName string, properties armworkloadorchestration.SchemaUpdate, options *armworkloadorchestration.SchemasClientUpdateOptions) (resp azfake.Responder[armworkloadorchestration.SchemasClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewSchemasServerTransport creates a new instance of SchemasServerTransport with the provided implementation.
// The returned SchemasServerTransport instance is connected to an instance of armworkloadorchestration.SchemasClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewSchemasServerTransport(srv *SchemasServer) *SchemasServerTransport {
	return &SchemasServerTransport{
		srv:                         srv,
		beginCreateOrUpdate:         newTracker[azfake.PollerResponder[armworkloadorchestration.SchemasClientCreateOrUpdateResponse]](),
		beginCreateVersion:          newTracker[azfake.PollerResponder[armworkloadorchestration.SchemasClientCreateVersionResponse]](),
		beginDelete:                 newTracker[azfake.PollerResponder[armworkloadorchestration.SchemasClientDeleteResponse]](),
		newListByResourceGroupPager: newTracker[azfake.PagerResponder[armworkloadorchestration.SchemasClientListByResourceGroupResponse]](),
		newListBySubscriptionPager:  newTracker[azfake.PagerResponder[armworkloadorchestration.SchemasClientListBySubscriptionResponse]](),
	}
}

// SchemasServerTransport connects instances of armworkloadorchestration.SchemasClient to instances of SchemasServer.
// Don't use this type directly, use NewSchemasServerTransport instead.
type SchemasServerTransport struct {
	srv                         *SchemasServer
	beginCreateOrUpdate         *tracker[azfake.PollerResponder[armworkloadorchestration.SchemasClientCreateOrUpdateResponse]]
	beginCreateVersion          *tracker[azfake.PollerResponder[armworkloadorchestration.SchemasClientCreateVersionResponse]]
	beginDelete                 *tracker[azfake.PollerResponder[armworkloadorchestration.SchemasClientDeleteResponse]]
	newListByResourceGroupPager *tracker[azfake.PagerResponder[armworkloadorchestration.SchemasClientListByResourceGroupResponse]]
	newListBySubscriptionPager  *tracker[azfake.PagerResponder[armworkloadorchestration.SchemasClientListBySubscriptionResponse]]
}

// Do implements the policy.Transporter interface for SchemasServerTransport.
func (s *SchemasServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToMethodFake(req, method)
}

func (s *SchemasServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if schemasServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = schemasServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "SchemasClient.BeginCreateOrUpdate":
				res.resp, res.err = s.dispatchBeginCreateOrUpdate(req)
			case "SchemasClient.BeginCreateVersion":
				res.resp, res.err = s.dispatchBeginCreateVersion(req)
			case "SchemasClient.BeginDelete":
				res.resp, res.err = s.dispatchBeginDelete(req)
			case "SchemasClient.Get":
				res.resp, res.err = s.dispatchGet(req)
			case "SchemasClient.NewListByResourceGroupPager":
				res.resp, res.err = s.dispatchNewListByResourceGroupPager(req)
			case "SchemasClient.NewListBySubscriptionPager":
				res.resp, res.err = s.dispatchNewListBySubscriptionPager(req)
			case "SchemasClient.RemoveVersion":
				res.resp, res.err = s.dispatchRemoveVersion(req)
			case "SchemasClient.Update":
				res.resp, res.err = s.dispatchUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *SchemasServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := s.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.Schema](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, schemaNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		s.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		s.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		s.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (s *SchemasServerTransport) dispatchBeginCreateVersion(req *http.Request) (*http.Response, error) {
	if s.srv.BeginCreateVersion == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateVersion not implemented")}
	}
	beginCreateVersion := s.beginCreateVersion.get(req)
	if beginCreateVersion == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/createVersion`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SchemaVersionWithUpdateType](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginCreateVersion(req.Context(), resourceGroupNameParam, schemaNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateVersion = &respr
		s.beginCreateVersion.add(req, beginCreateVersion)
	}

	resp, err := server.PollerResponderNext(beginCreateVersion, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		s.beginCreateVersion.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateVersion) {
		s.beginCreateVersion.remove(req)
	}

	return resp, nil
}

func (s *SchemasServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if s.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := s.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginDelete(req.Context(), resourceGroupNameParam, schemaNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		s.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		s.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		s.beginDelete.remove(req)
	}

	return resp, nil
}

func (s *SchemasServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if s.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Get(req.Context(), resourceGroupNameParam, schemaNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Schema, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SchemasServerTransport) dispatchNewListByResourceGroupPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewListByResourceGroupPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByResourceGroupPager not implemented")}
	}
	newListByResourceGroupPager := s.newListByResourceGroupPager.get(req)
	if newListByResourceGroupPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resp := s.srv.NewListByResourceGroupPager(resourceGroupNameParam, nil)
		newListByResourceGroupPager = &resp
		s.newListByResourceGroupPager.add(req, newListByResourceGroupPager)
		server.PagerResponderInjectNextLinks(newListByResourceGroupPager, req, func(page *armworkloadorchestration.SchemasClientListByResourceGroupResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByResourceGroupPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		s.newListByResourceGroupPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByResourceGroupPager) {
		s.newListByResourceGroupPager.remove(req)
	}
	return resp, nil
}

func (s *SchemasServerTransport) dispatchNewListBySubscriptionPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewListBySubscriptionPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListBySubscriptionPager not implemented")}
	}
	newListBySubscriptionPager := s.newListBySubscriptionPager.get(req)
	if newListBySubscriptionPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resp := s.srv.NewListBySubscriptionPager(nil)
		newListBySubscriptionPager = &resp
		s.newListBySubscriptionPager.add(req, newListBySubscriptionPager)
		server.PagerResponderInjectNextLinks(newListBySubscriptionPager, req, func(page *armworkloadorchestration.SchemasClientListBySubscriptionResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListBySubscriptionPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		s.newListBySubscriptionPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListBySubscriptionPager) {
		s.newListBySubscriptionPager.remove(req)
	}
	return resp, nil
}

func (s *SchemasServerTransport) dispatchRemoveVersion(req *http.Request) (*http.Response, error) {
	if s.srv.RemoveVersion == nil {
		return nil, &nonRetriableError{errors.New("fake for method RemoveVersion not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/removeVersion`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.VersionParameter](req)
	if err != nil {
		return nil, err
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.RemoveVersion(req.Context(), resourceGroupNameParam, schemaNameParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).RemoveVersionResponse, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SchemasServerTransport) dispatchUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.Update == nil {
		return nil, &nonRetriableError{errors.New("fake for method Update not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SchemaUpdate](req)
	if err != nil {
		return nil, err
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Update(req.Context(), resourceGroupNameParam, schemaNameParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Schema, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to SchemasServerTransport
var schemasServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/schemaversions_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// SchemaVersionsServer is a fake server for instances of the armworkloadorchestration.SchemaVersionsClient type.
type SchemaVersionsServer struct {
	// BeginCreateOrUpdate is the fake for method SchemaVersionsClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, schemaName string, schemaVersionName string, resource armworkloadorchestration.SchemaVersion, options *armworkloadorchestration.SchemaVersionsClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.SchemaVersionsClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method SchemaVersionsClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, schemaName string, schemaVersionName string, options *armworkloadorchestration.SchemaVersionsClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.SchemaVersionsClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method SchemaVersionsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, schemaName string, schemaVersionName string, options *armworkloadorchestration.SchemaVersionsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.SchemaVersionsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListBySchemaPager is the fake for method SchemaVersionsClient.NewListBySchemaPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySchemaPager func(resourceGroupName string, schemaName string, options *armworkloadorchestration.SchemaVersionsClientListBySchemaOptions) (resp azfake.PagerResponder[armworkloadorchestration.SchemaVersionsClientListBySchemaResponse])

	// Update is the fake for method SchemaVersionsClient.Update
	// HTTP status codes to indicate success: http.StatusOK
	Update func(ctx context.Context, resourceGroupName string, schemaName string, schemaVersionName string, properties armworkloadorchestration.SchemaVersion, options *armworkloadorchestration.SchemaVersionsClientUpdateOptions) (resp azfake.Responder[armworkloadorchestration.SchemaVersionsClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewSchemaVersionsServerTransport creates a new instance of SchemaVersionsServerTransport with the provided implementation.
// The returned SchemaVersionsServerTransport instance is connected to an instance of armworkloadorchestration.SchemaVersionsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewSchemaVersionsServerTransport(srv *SchemaVersionsServer) *SchemaVersionsServerTransport {
	return &SchemaVersionsServerTransport{
		srv:                  srv,
		beginCreateOrUpdate:  newTracker[azfake.PollerResponder[armworkloadorchestration.SchemaVersionsClientCreateOrUpdateResponse]](),
		beginDelete:          newTracker[azfake.PollerResponder[armworkloadorchestration.SchemaVersionsClientDeleteResponse]](),
		newListBySchemaPager: newTracker[azfake.PagerResponder[armworkloadorchestration.SchemaVersionsClientListBySchemaResponse]](),
	}
}

// SchemaVersionsServerTransport connects instances of armworkloadorchestration.SchemaVersionsClient to instances of SchemaVersionsServer.
// Don't use this type directly, use NewSchemaVersionsServerTransport instead.
type SchemaVersionsServerTransport struct {
	srv                  *SchemaVersionsServer
	beginCreateOrUpdate  *tracker[azfake.PollerResponder[armworkloadorchestration.SchemaVersionsClientCreateOrUpdateResponse]]
	beginDelete          *tracker[azfake.PollerResponder[armworkloadorchestration.SchemaVersionsClientDeleteResponse]]
	newListBySchemaPager *tracker[azfake.PagerResponder[armworkloadorchestration.SchemaVersionsClientListBySchemaResponse]]
}

// Do implements the policy.Transporter interface for SchemaVersionsServerTransport.
func (s *SchemaVersionsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToMethodFake(req, method)
}

func (s *SchemaVersionsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if schemaVersionsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = schemaVersionsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "SchemaVersionsClient.BeginCreateOrUpdate":
				res.resp, res.err = s.dispatchBeginCreateOrUpdate(req)
			case "SchemaVersionsClient.BeginDelete":
				res.resp, res.err = s.dispatchBeginDelete(req)
			case "SchemaVersionsClient.Get":
				res.resp, res.err = s.dispatchGet(req)
			case "SchemaVersionsClient.NewListBySchemaPager":
				res.resp, res.err = s.dispatchNewListBySchemaPager(req)
			case "SchemaVersionsClient.Update":
				res.resp, res.err = s.dispatchUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *SchemaVersionsServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := s.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<schemaVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SchemaVersion](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		schemaVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaVersionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, schemaNameParam, schemaVersionNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		s.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		s.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		s.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (s *SchemaVersionsServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if s.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := s.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<schemaVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		schemaVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaVersionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginDelete(req.Context(), resourceGroupNameParam, schemaNameParam, schemaVersionNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		s.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		s.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		s.beginDelete.remove(req)
	}

	return resp, nil
}

func (s *SchemaVersionsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if s.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<schemaVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
	if err != nil {
		return nil, err
	}
	schemaVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaVersionName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Get(req.Context(), resourceGroupNameParam, schemaNameParam, schemaVersionNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SchemaVersion, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SchemaVersionsServerTransport) dispatchNewListBySchemaPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewListBySchemaPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListBySchemaPager not implemented")}
	}
	newListBySchemaPager := s.newListBySchemaPager.get(req)
	if newListBySchemaPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
		if err != nil {
			return nil, err
		}
		resp := s.srv.NewListBySchemaPager(resourceGroupNameParam, schemaNameParam, nil)
		newListBySchemaPager = &resp
		s.newListBySchemaPager.add(req, newListBySchemaPager)
		server.PagerResponderInjectNextLinks(newListBySchemaPager, req, func(page *armworkloadorchestration.SchemaVersionsClientListBySchemaResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListBySchemaPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		s.newListBySchemaPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListBySchemaPager) {
		s.newListBySchemaPager.remove(req)
	}
	return resp, nil
}

func (s *SchemaVersionsServerTransport) dispatchUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.Update == nil {
		return nil, &nonRetriableError{errors.New("fake for method Update not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/schemas/(?P<schemaName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<schemaVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SchemaVersion](req)
	if err != nil {
		return nil, err
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	schemaNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaName")])
	if err != nil {
		return nil, err
	}
	schemaVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("schemaVersionName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Update(req.Context(), resourceGroupNameParam, schemaNameParam, schemaVersionNameParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SchemaVersion, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to SchemaVersionsServerTransport
var schemaVersionsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/server_factory.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strings"
	"sync"
)

// ServerFactory is a fake server for instances of the armworkloadorchestration.ClientFactory type.
type ServerFactory struct {
	// ConfigTemplateVersionsServer contains the fakes for client ConfigTemplateVersionsClient
	ConfigTemplateVersionsServer ConfigTemplateVersionsServer

	// ConfigTemplatesServer contains the fakes for client ConfigTemplatesClient
	ConfigTemplatesServer ConfigTemplatesServer

	// ContextsServer contains the fakes for client ContextsClient
	ContextsServer ContextsServer

	// DiagnosticsServer contains the fakes for client DiagnosticsClient
	DiagnosticsServer DiagnosticsServer

	// DynamicSchemaVersionsServer contains the fakes for client DynamicSchemaVersionsClient
	DynamicSchemaVersionsServer DynamicSchemaVersionsServer

	// DynamicSchemasServer contains the fakes for client DynamicSchemasClient
	DynamicSchemasServer DynamicSchemasServer

	// ExecutionsServer contains the fakes for client ExecutionsClient
	ExecutionsServer ExecutionsServer

	// InstanceHistoriesServer contains the fakes for client InstanceHistoriesClient
	InstanceHistoriesServer InstanceHistoriesServer

	// InstancesServer contains the fakes for client InstancesClient
	InstancesServer InstancesServer

	// JobsServer contains the fakes for client JobsClient
	JobsServer JobsServer

	// SchemaReferencesServer contains the fakes for client SchemaReferencesClient
	SchemaReferencesServer SchemaReferencesServer

	// SchemaVersionsServer contains the fakes for client SchemaVersionsClient
	SchemaVersionsServer SchemaVersionsServer

	// SchemasServer contains the fakes for client SchemasClient
	SchemasServer SchemasServer

	// SiteReferencesServer contains the fakes for client SiteReferencesClient
	SiteReferencesServer SiteReferencesServer

	// SolutionTemplateVersionsServer contains the fakes for client SolutionTemplateVersionsClient
	SolutionTemplateVersionsServer SolutionTemplateVersionsServer

	// SolutionTemplatesServer contains the fakes for client SolutionTemplatesClient
	SolutionTemplatesServer SolutionTemplatesServer

	// SolutionVersionsServer contains the fakes for client SolutionVersionsClient
	SolutionVersionsServer SolutionVersionsServer

	// SolutionsServer contains the fakes for client SolutionsClient
	SolutionsServer SolutionsServer

	// TargetsServer contains the fakes for client TargetsClient
	TargetsServer TargetsServer

	// WorkflowVersionsServer contains the fakes for client WorkflowVersionsClient
	WorkflowVersionsServer WorkflowVersionsServer

	// WorkflowsServer contains the fakes for client WorkflowsClient
	WorkflowsServer WorkflowsServer
}

// NewServerFactoryTransport creates a new instance of ServerFactoryTransport with the provided implementation.
// The returned ServerFactoryTransport instance is connected to an instance of armworkloadorchestration.ClientFactory via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewServerFactoryTransport(srv *ServerFactory) *ServerFactoryTransport {
	return &ServerFactoryTransport{
		srv: srv,
	}
}

// ServerFactoryTransport connects instances of armworkloadorchestration.ClientFactory to instances of ServerFactory.
// Don't use this type directly, use NewServerFactoryTransport instead.
type ServerFactoryTransport struct {
	srv                              *ServerFactory
	trMu                             sync.Mutex
	trConfigTemplateVersionsServer   *ConfigTemplateVersionsServerTransport
	trConfigTemplatesServer          *ConfigTemplatesServerTransport
	trContextsServer                 *ContextsServerTransport
	trDiagnosticsServer              *DiagnosticsServerTransport
	trDynamicSchemaVersionsServer    *DynamicSchemaVersionsServerTransport
	trDynamicSchemasServer           *DynamicSchemasServerTransport
	trExecutionsServer               *ExecutionsServerTransport
	trInstanceHistoriesServer        *InstanceHistoriesServerTransport
	trInstancesServer                *InstancesServerTransport
	trJobsServer                     *JobsServerTransport
	trSchemaReferencesServer         *SchemaReferencesServerTransport
	trSchemaVersionsServer           *SchemaVersionsServerTransport
	trSchemasServer                  *SchemasServerTransport
	trSiteReferencesServer           *SiteReferencesServerTransport
	trSolutionTemplateVersionsServer *SolutionTemplateVersionsServerTransport
	trSolutionTemplatesServer        *SolutionTemplatesServerTransport
	trSolutionVersionsServer         *SolutionVersionsServerTransport
	trSolutionsServer                *SolutionsServerTransport
	trTargetsServer                  *TargetsServerTransport
	trWorkflowVersionsServer         *WorkflowVersionsServerTransport
	trWorkflowsServer                *WorkflowsServerTransport
}

// Do implements the policy.Transporter interface for ServerFactoryTransport.
func (s *ServerFactoryTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	client := method[:strings.Index(method, ".")]
	var resp *http.Response
	var err error

	switch client {
	case "ConfigTemplateVersionsClient":
		initServer(s, &s.trConfigTemplateVersionsServer, func() *ConfigTemplateVersionsServerTransport {
			return NewConfigTemplateVersionsServerTransport(&s.srv.ConfigTemplateVersionsServer)
		})
		resp, err = s.trConfigTemplateVersionsServer.Do(req)
	case "ConfigTemplatesClient":
		initServer(s, &s.trConfigTemplatesServer, func() *ConfigTemplatesServerTransport {
			return NewConfigTemplatesServerTransport(&s.srv.ConfigTemplatesServer)
		})
		resp, err = s.trConfigTemplatesServer.Do(req)
	case "ContextsClient":
		initServer(s, &s.trContextsServer, func() *ContextsServerTransport { return NewContextsServerTransport(&s.srv.ContextsServer) })
		resp, err = s.trContextsServer.Do(req)
	case "DiagnosticsClient":
		initServer(s, &s.trDiagnosticsServer, func() *DiagnosticsServerTransport { return NewDiagnosticsServerTransport(&s.srv.DiagnosticsServer) })
		resp, err = s.trDiagnosticsServer.Do(req)
	case "DynamicSchemaVersionsClient":
		initServer(s, &s.trDynamicSchemaVersionsServer, func() *DynamicSchemaVersionsServerTransport {
			return NewDynamicSchemaVersionsServerTransport(&s.srv.DynamicSchemaVersionsServer)
		})
		resp, err = s.trDynamicSchemaVersionsServer.Do(req)
	case "DynamicSchemasClient":
		initServer(s, &s.trDynamicSchemasServer, func() *DynamicSchemasServerTransport {
			return NewDynamicSchemasServerTransport(&s.srv.DynamicSchemasServer)
		})
		resp, err = s.trDynamicSchemasServer.Do(req)
	case "ExecutionsClient":
		initServer(s, &s.trExecutionsServer, func() *ExecutionsServerTransport { return NewExecutionsServerTransport(&s.srv.ExecutionsServer) })
		resp, err = s.trExecutionsServer.Do(req)
	case "InstanceHistoriesClient":
		initServer(s, &s.trInstanceHistoriesServer, func() *InstanceHistoriesServerTransport {
			return NewInstanceHistoriesServerTransport(&s.srv.InstanceHistoriesServer)
		})
		resp, err = s.trInstanceHistoriesServer.Do(req)
	case "InstancesClient":
		initServer(s, &s.trInstancesServer, func() *InstancesServerTransport { return NewInstancesServerTransport(&s.srv.InstancesServer) })
		resp, err = s.trInstancesServer.Do(req)
	case "JobsClient":
		initServer(s, &s.trJobsServer, func() *JobsServerTransport { return NewJobsServerTransport(&s.srv.JobsServer) })
		resp, err = s.trJobsServer.Do(req)
	case "SchemaReferencesClient":
		initServer(s, &s.trSchemaReferencesServer, func() *SchemaReferencesServerTransport {
			return NewSchemaReferencesServerTransport(&s.srv.SchemaReferencesServer)
		})
		resp, err = s.trSchemaReferencesServer.Do(req)
	case "SchemaVersionsClient":
		initServer(s, &s.trSchemaVersionsServer, func() *SchemaVersionsServerTransport {
			return NewSchemaVersionsServerTransport(&s.srv.SchemaVersionsServer)
		})
		resp, err = s.trSchemaVersionsServer.Do(req)
	case "SchemasClient":
		initServer(s, &s.trSchemasServer, func() *SchemasServerTransport { return NewSchemasServerTransport(&s.srv.SchemasServer) })
		resp, err = s.trSchemasServer.Do(req)
	case "SiteReferencesClient":
		initServer(s, &s.trSiteReferencesServer, func() *SiteReferencesServerTransport {
			return NewSiteReferencesServerTransport(&s.srv.SiteReferencesServer)
		})
		resp, err = s.trSiteReferencesServer.Do(req)
	case "SolutionTemplateVersionsClient":
		initServer(s, &s.trSolutionTemplateVersionsServer, func() *SolutionTemplateVersionsServerTransport {
			return NewSolutionTemplateVersionsServerTransport(&s.srv.SolutionTemplateVersionsServer)
		})
		resp, err = s.trSolutionTemplateVersionsServer.Do(req)
	case "SolutionTemplatesClient":
		initServer(s, &s.trSolutionTemplatesServer, func() *SolutionTemplatesServerTransport {
			return NewSolutionTemplatesServerTransport(&s.srv.SolutionTemplatesServer)
		})
		resp, err = s.trSolutionTemplatesServer.Do(req)
	case "SolutionVersionsClient":
		initServer(s, &s.trSolutionVersionsServer, func() *SolutionVersionsServerTransport {
			return NewSolutionVersionsServerTransport(&s.srv.SolutionVersionsServer)
		})
		resp, err = s.trSolutionVersionsServer.Do(req)
	case "SolutionsClient":
		initServer(s, &s.trSolutionsServer, func() *SolutionsServerTransport { return NewSolutionsServerTransport(&s.srv.SolutionsServer) })
		resp, err = s.trSolutionsServer.Do(req)
	case "TargetsClient":
		initServer(s, &s.trTargetsServer, func() *TargetsServerTransport { return NewTargetsServerTransport(&s.srv.TargetsServer) })
		resp, err = s.trTargetsServer.Do(req)
	case "WorkflowVersionsClient":
		initServer(s, &s.trWorkflowVersionsServer, func() *WorkflowVersionsServerTransport {
			return NewWorkflowVersionsServerTransport(&s.srv.WorkflowVersionsServer)
		})
		resp, err = s.trWorkflowVersionsServer.Do(req)
	case "WorkflowsClient":
		initServer(s, &s.trWorkflowsServer, func() *WorkflowsServerTransport { return NewWorkflowsServerTransport(&s.srv.WorkflowsServer) })
		resp, err = s.trWorkflowsServer.Do(req)
	default:
		err = fmt.Errorf("unhandled client %s", client)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func initServer[T any](s *ServerFactoryTransport, dst **T, src func() *T) {
	s.trMu.Lock()
	if *dst == nil {
		*dst = src()
	}
	s.trMu.Unlock()
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/sitereferences_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// SiteReferencesServer is a fake server for instances of the armworkloadorchestration.SiteReferencesClient type.
type SiteReferencesServer struct {
	// BeginCreateOrUpdate is the fake for method SiteReferencesClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, contextName string, siteReferenceName string, resource armworkloadorchestration.SiteReference, options *armworkloadorchestration.SiteReferencesClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.SiteReferencesClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method SiteReferencesClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, contextName string, siteReferenceName string, options *armworkloadorchestration.SiteReferencesClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.SiteReferencesClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method SiteReferencesClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, contextName string, siteReferenceName string, options *armworkloadorchestration.SiteReferencesClientGetOptions) (resp azfake.Responder[armworkloadorchestration.SiteReferencesClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByContextPager is the fake for method SiteReferencesClient.NewListByContextPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByContextPager func(resourceGroupName string, contextName string, options *armworkloadorchestration.SiteReferencesClientListByContextOptions) (resp azfake.PagerResponder[armworkloadorchestration.SiteReferencesClientListByContextResponse])

	// BeginUpdate is the fake for method SiteReferencesClient.BeginUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdate func(ctx context.Context, resourceGroupName string, contextName string, siteReferenceName string, properties armworkloadorchestration.SiteReference, options *armworkloadorchestration.SiteReferencesClientBeginUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.SiteReferencesClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewSiteReferencesServerTransport creates a new instance of SiteReferencesServerTransport with the provided implementation.
// The returned SiteReferencesServerTransport instance is connected to an instance of armworkloadorchestration.SiteReferencesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewSiteReferencesServerTransport(srv *SiteReferencesServer) *SiteReferencesServerTransport {
	return &SiteReferencesServerTransport{
		srv:                   srv,
		beginCreateOrUpdate:   newTracker[azfake.PollerResponder[armworkloadorchestration.SiteReferencesClientCreateOrUpdateResponse]](),
		beginDelete:           newTracker[azfake.PollerResponder[armworkloadorchestration.SiteReferencesClientDeleteResponse]](),
		newListByContextPager: newTracker[azfake.PagerResponder[armworkloadorchestration.SiteReferencesClientListByContextResponse]](),
		beginUpdate:           newTracker[azfake.PollerResponder[armworkloadorchestration.SiteReferencesClientUpdateResponse]](),
	}
}

// SiteReferencesServerTransport connects instances of armworkloadorchestration.SiteReferencesClient to instances of SiteReferencesServer.
// Don't use this type directly, use NewSiteReferencesServerTransport instead.
type SiteReferencesServerTransport struct {
	srv                   *SiteReferencesServer
	beginCreateOrUpdate   *tracker[azfake.PollerResponder[armworkloadorchestration.SiteReferencesClientCreateOrUpdateResponse]]
	beginDelete           *tracker[azfake.PollerResponder[armworkloadorchestration.SiteReferencesClientDeleteResponse]]
	newListByContextPager *tracker[azfake.PagerResponder[armworkloadorchestration.SiteReferencesClientListByContextResponse]]
	beginUpdate           *tracker[azfake.PollerResponder[armworkloadorchestration.SiteReferencesClientUpdateResponse]]
}

// Do implements the policy.Transporter interface for SiteReferencesServerTransport.
func (s *SiteReferencesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToMethodFake(req, method)
}

func (s *SiteReferencesServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if siteReferencesServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = siteReferencesServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "SiteReferencesClient.BeginCreateOrUpdate":
				res.resp, res.err = s.dispatchBeginCreateOrUpdate(req)
			case "SiteReferencesClient.BeginDelete":
				res.resp, res.err = s.dispatchBeginDelete(req)
			case "SiteReferencesClient.Get":
				res.resp, res.err = s.dispatchGet(req)
			case "SiteReferencesClient.NewListByContextPager":
				res.resp, res.err = s.dispatchNewListByContextPager(req)
			case "SiteReferencesClient.BeginUpdate":
				res.resp, res.err = s.dispatchBeginUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *SiteReferencesServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := s.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/siteReferences/(?P<siteReferenceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SiteReference](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		siteReferenceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("siteReferenceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, contextNameParam, siteReferenceNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		s.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		s.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		s.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (s *SiteReferencesServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if s.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := s.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/siteReferences/(?P<siteReferenceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		siteReferenceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("siteReferenceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginDelete(req.Context(), resourceGroupNameParam, contextNameParam, siteReferenceNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		s.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		s.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		s.beginDelete.remove(req)
	}

	return resp, nil
}

func (s *SiteReferencesServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if s.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/siteReferences/(?P<siteReferenceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
	if err != nil {
		return nil, err
	}
	siteReferenceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("siteReferenceName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Get(req.Context(), resourceGroupNameParam, contextNameParam, siteReferenceNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SiteReference, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SiteReferencesServerTransport) dispatchNewListByContextPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewListByContextPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByContextPager not implemented")}
	}
	newListByContextPager := s.newListByContextPager.get(req)
	if newListByContextPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/siteReferences`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		resp := s.srv.NewListByContextPager(resourceGroupNameParam, contextNameParam, nil)
		newListByContextPager = &resp
		s.newListByContextPager.add(req, newListByContextPager)
		server.PagerResponderInjectNextLinks(newListByContextPager, req, func(page *armworkloadorchestration.SiteReferencesClientListByContextResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByContextPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		s.newListByContextPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByContextPager) {
		s.newListByContextPager.remove(req)
	}
	return resp, nil
}

func (s *SiteReferencesServerTransport) dispatchBeginUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.BeginUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdate not implemented")}
	}
	beginUpdate := s.beginUpdate.get(req)
	if beginUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/contexts/(?P<contextName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/siteReferences/(?P<siteReferenceName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SiteReference](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		contextNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("contextName")])
		if err != nil {
			return nil, err
		}
		siteReferenceNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("siteReferenceName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginUpdate(req.Context(), resourceGroupNameParam, contextNameParam, siteReferenceNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginUpdate = &respr
		s.beginUpdate.add(req, beginUpdate)
	}

	resp, err := server.PollerResponderNext(beginUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		s.beginUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginUpdate) {
		s.beginUpdate.remove(req)
	}

	return resp, nil
}

// set this to conditionally intercept incoming requests to SiteReferencesServerTransport
var siteReferencesServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/solutions_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// SolutionsServer is a fake server for instances of the armworkloadorchestration.SolutionsClient type.
type SolutionsServer struct {
	// BeginCreateOrUpdate is the fake for method SolutionsClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, resource armworkloadorchestration.Solution, options *armworkloadorchestration.SolutionsClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionsClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method SolutionsClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, options *armworkloadorchestration.SolutionsClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionsClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method SolutionsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, options *armworkloadorchestration.SolutionsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.SolutionsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByTargetPager is the fake for method SolutionsClient.NewListByTargetPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByTargetPager func(resourceGroupName string, targetName string, options *armworkloadorchestration.SolutionsClientListByTargetOptions) (resp azfake.PagerResponder[armworkloadorchestration.SolutionsClientListByTargetResponse])

	// BeginUpdate is the fake for method SolutionsClient.BeginUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdate func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, properties armworkloadorchestration.SolutionUpdate, options *armworkloadorchestration.SolutionsClientBeginUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionsClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewSolutionsServerTransport creates a new instance of SolutionsServerTransport with the provided implementation.
// The returned SolutionsServerTransport instance is connected to an instance of armworkloadorchestration.SolutionsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewSolutionsServerTransport(srv *SolutionsServer) *SolutionsServerTransport {
	return &SolutionsServerTransport{
		srv:                  srv,
		beginCreateOrUpdate:  newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionsClientCreateOrUpdateResponse]](),
		beginDelete:          newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionsClientDeleteResponse]](),
		newListByTargetPager: newTracker[azfake.PagerResponder[armworkloadorchestration.SolutionsClientListByTargetResponse]](),
		beginUpdate:          newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionsClientUpdateResponse]](),
	}
}

// SolutionsServerTransport connects instances of armworkloadorchestration.SolutionsClient to instances of SolutionsServer.
// Don't use this type directly, use NewSolutionsServerTransport instead.
type SolutionsServerTransport struct {
	srv                  *SolutionsServer
	beginCreateOrUpdate  *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionsClientCreateOrUpdateResponse]]
	beginDelete          *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionsClientDeleteResponse]]
	newListByTargetPager *tracker[azfake.PagerResponder[armworkloadorchestration.SolutionsClientListByTargetResponse]]
	beginUpdate          *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionsClientUpdateResponse]]
}

// Do implements the policy.Transporter interface for SolutionsServerTransport.
func (s *SolutionsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToMethodFake(req, method)
}

func (s *SolutionsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if solutionsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = solutionsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "SolutionsClient.BeginCreateOrUpdate":
				res.resp, res.err = s.dispatchBeginCreateOrUpdate(req)
			case "SolutionsClient.BeginDelete":
				res.resp, res.err = s.dispatchBeginDelete(req)
			case "SolutionsClient.Get":
				res.resp, res.err = s.dispatchGet(req)
			case "SolutionsClient.NewListByTargetPager":
				res.resp, res.err = s.dispatchNewListByTargetPager(req)
			case "SolutionsClient.BeginUpdate":
				res.resp, res.err = s.dispatchBeginUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *SolutionsServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := s.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.Solution](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		s.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		s.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		s.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (s *SolutionsServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if s.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := s.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginDelete(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		s.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		s.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		s.beginDelete.remove(req)
	}

	return resp, nil
}

func (s *SolutionsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if s.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
	if err != nil {
		return nil, err
	}
	solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Get(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Solution, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SolutionsServerTransport) dispatchNewListByTargetPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewListByTargetPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByTargetPager not implemented")}
	}
	newListByTargetPager := s.newListByTargetPager.get(req)
	if newListByTargetPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		resp := s.srv.NewListByTargetPager(resourceGroupNameParam, targetNameParam, nil)
		newListByTargetPager = &resp
		s.newListByTargetPager.add(req, newListByTargetPager)
		server.PagerResponderInjectNextLinks(newListByTargetPager, req, func(page *armworkloadorchestration.SolutionsClientListByTargetResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByTargetPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		s.newListByTargetPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByTargetPager) {
		s.newListByTargetPager.remove(req)
	}
	return resp, nil
}

func (s *SolutionsServerTransport) dispatchBeginUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.BeginUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginUpdate not implemented")}
	}
	beginUpdate := s.beginUpdate.get(req)
	if beginUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SolutionUpdate](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginUpdate(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginUpdate = &respr
		s.beginUpdate.add(req, beginUpdate)
	}

	resp, err := server.PollerResponderNext(beginUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		s.beginUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginUpdate) {
		s.beginUpdate.remove(req)
	}

	return resp, nil
}

// set this to conditionally intercept incoming requests to SolutionsServerTransport
var solutionsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/solutiontemplates_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// SolutionTemplatesServer is a fake server for instances of the armworkloadorchestration.SolutionTemplatesClient type.
type SolutionTemplatesServer struct {
	// BeginCreateOrUpdate is the fake for method SolutionTemplatesClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, solutionTemplateName string, resource armworkloadorchestration.SolutionTemplate, options *armworkloadorchestration.SolutionTemplatesClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginCreateVersion is the fake for method SolutionTemplatesClient.BeginCreateVersion
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginCreateVersion func(ctx context.Context, resourceGroupName string, solutionTemplateName string, body armworkloadorchestration.SolutionTemplateVersionWithUpdateType, options *armworkloadorchestration.SolutionTemplatesClientBeginCreateVersionOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientCreateVersionResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method SolutionTemplatesClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, solutionTemplateName string, options *armworkloadorchestration.SolutionTemplatesClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method SolutionTemplatesClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, solutionTemplateName string, options *armworkloadorchestration.SolutionTemplatesClientGetOptions) (resp azfake.Responder[armworkloadorchestration.SolutionTemplatesClientGetResponse], errResp azfake.ErrorResponder)

	// NewListByResourceGroupPager is the fake for method SolutionTemplatesClient.NewListByResourceGroupPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListByResourceGroupPager func(resourceGroupName string, options *armworkloadorchestration.SolutionTemplatesClientListByResourceGroupOptions) (resp azfake.PagerResponder[armworkloadorchestration.SolutionTemplatesClientListByResourceGroupResponse])

	// NewListBySubscriptionPager is the fake for method SolutionTemplatesClient.NewListBySubscriptionPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySubscriptionPager func(options *armworkloadorchestration.SolutionTemplatesClientListBySubscriptionOptions) (resp azfake.PagerResponder[armworkloadorchestration.SolutionTemplatesClientListBySubscriptionResponse])

	// BeginRemoveVersion is the fake for method SolutionTemplatesClient.BeginRemoveVersion
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginRemoveVersion func(ctx context.Context, resourceGroupName string, solutionTemplateName string, body armworkloadorchestration.VersionParameter, options *armworkloadorchestration.SolutionTemplatesClientBeginRemoveVersionOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientRemoveVersionResponse], errResp azfake.ErrorResponder)

	// Update is the fake for method SolutionTemplatesClient.Update
	// HTTP status codes to indicate success: http.StatusOK
	Update func(ctx context.Context, resourceGroupName string, solutionTemplateName string, properties armworkloadorchestration.SolutionTemplateUpdate, options *armworkloadorchestration.SolutionTemplatesClientUpdateOptions) (resp azfake.Responder[armworkloadorchestration.SolutionTemplatesClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewSolutionTemplatesServerTransport creates a new instance of SolutionTemplatesServerTransport with the provided implementation.
// The returned SolutionTemplatesServerTransport instance is connected to an instance of armworkloadorchestration.SolutionTemplatesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewSolutionTemplatesServerTransport(srv *SolutionTemplatesServer) *SolutionTemplatesServerTransport {
	return &SolutionTemplatesServerTransport{
		srv:                         srv,
		beginCreateOrUpdate:         newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientCreateOrUpdateResponse]](),
		beginCreateVersion:          newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientCreateVersionResponse]](),
		beginDelete:                 newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientDeleteResponse]](),
		newListByResourceGroupPager: newTracker[azfake.PagerResponder[armworkloadorchestration.SolutionTemplatesClientListByResourceGroupResponse]](),
		newListBySubscriptionPager:  newTracker[azfake.PagerResponder[armworkloadorchestration.SolutionTemplatesClientListBySubscriptionResponse]](),
		beginRemoveVersion:          newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientRemoveVersionResponse]](),
	}
}

// SolutionTemplatesServerTransport connects instances of armworkloadorchestration.SolutionTemplatesClient to instances of SolutionTemplatesServer.
// Don't use this type directly, use NewSolutionTemplatesServerTransport instead.
type SolutionTemplatesServerTransport struct {
	srv                         *SolutionTemplatesServer
	beginCreateOrUpdate         *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientCreateOrUpdateResponse]]
	beginCreateVersion          *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientCreateVersionResponse]]
	beginDelete                 *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientDeleteResponse]]
	newListByResourceGroupPager *tracker[azfake.PagerResponder[armworkloadorchestration.SolutionTemplatesClientListByResourceGroupResponse]]
	newListBySubscriptionPager  *tracker[azfake.PagerResponder[armworkloadorchestration.SolutionTemplatesClientListBySubscriptionResponse]]
	beginRemoveVersion          *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplatesClientRemoveVersionResponse]]
}

// Do implements the policy.Transporter interface for SolutionTemplatesServerTransport.
func (s *SolutionTemplatesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToMethodFake(req, method)
}

func (s *SolutionTemplatesServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if solutionTemplatesServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = solutionTemplatesServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "SolutionTemplatesClient.BeginCreateOrUpdate":
				res.resp, res.err = s.dispatchBeginCreateOrUpdate(req)
			case "SolutionTemplatesClient.BeginCreateVersion":
				res.resp, res.err = s.dispatchBeginCreateVersion(req)
			case "SolutionTemplatesClient.BeginDelete":
				res.resp, res.err = s.dispatchBeginDelete(req)
			case "SolutionTemplatesClient.Get":
				res.resp, res.err = s.dispatchGet(req)
			case "SolutionTemplatesClient.NewListByResourceGroupPager":
				res.resp, res.err = s.dispatchNewListByResourceGroupPager(req)
			case "SolutionTemplatesClient.NewListBySubscriptionPager":
				res.resp, res.err = s.dispatchNewListBySubscriptionPager(req)
			case "SolutionTemplatesClient.BeginRemoveVersion":
				res.resp, res.err = s.dispatchBeginRemoveVersion(req)
			case "SolutionTemplatesClient.Update":
				res.resp, res.err = s.dispatchUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *SolutionTemplatesServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := s.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SolutionTemplate](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, solutionTemplateNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		s.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		s.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		s.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (s *SolutionTemplatesServerTransport) dispatchBeginCreateVersion(req *http.Request) (*http.Response, error) {
	if s.srv.BeginCreateVersion == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateVersion not implemented")}
	}
	beginCreateVersion := s.beginCreateVersion.get(req)
	if beginCreateVersion == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/createVersion`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SolutionTemplateVersionWithUpdateType](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginCreateVersion(req.Context(), resourceGroupNameParam, solutionTemplateNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateVersion = &respr
		s.beginCreateVersion.add(req, beginCreateVersion)
	}

	resp, err := server.PollerResponderNext(beginCreateVersion, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		s.beginCreateVersion.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateVersion) {
		s.beginCreateVersion.remove(req)
	}

	return resp, nil
}

func (s *SolutionTemplatesServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if s.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := s.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginDelete(req.Context(), resourceGroupNameParam, solutionTemplateNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		s.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		s.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		s.beginDelete.remove(req)
	}

	return resp, nil
}

func (s *SolutionTemplatesServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if s.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Get(req.Context(), resourceGroupNameParam, solutionTemplateNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SolutionTemplate, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SolutionTemplatesServerTransport) dispatchNewListByResourceGroupPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewListByResourceGroupPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListByResourceGroupPager not implemented")}
	}
	newListByResourceGroupPager := s.newListByResourceGroupPager.get(req)
	if newListByResourceGroupPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 3 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		resp := s.srv.NewListByResourceGroupPager(resourceGroupNameParam, nil)
		newListByResourceGroupPager = &resp
		s.newListByResourceGroupPager.add(req, newListByResourceGroupPager)
		server.PagerResponderInjectNextLinks(newListByResourceGroupPager, req, func(page *armworkloadorchestration.SolutionTemplatesClientListByResourceGroupResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListByResourceGroupPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		s.newListByResourceGroupPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListByResourceGroupPager) {
		s.newListByResourceGroupPager.remove(req)
	}
	return resp, nil
}

func (s *SolutionTemplatesServerTransport) dispatchNewListBySubscriptionPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewListBySubscriptionPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListBySubscriptionPager not implemented")}
	}
	newListBySubscriptionPager := s.newListBySubscriptionPager.get(req)
	if newListBySubscriptionPager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resp := s.srv.NewListBySubscriptionPager(nil)
		newListBySubscriptionPager = &resp
		s.newListBySubscriptionPager.add(req, newListBySubscriptionPager)
		server.PagerResponderInjectNextLinks(newListBySubscriptionPager, req, func(page *armworkloadorchestration.SolutionTemplatesClientListBySubscriptionResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListBySubscriptionPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		s.newListBySubscriptionPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListBySubscriptionPager) {
		s.newListBySubscriptionPager.remove(req)
	}
	return resp, nil
}

func (s *SolutionTemplatesServerTransport) dispatchBeginRemoveVersion(req *http.Request) (*http.Response, error) {
	if s.srv.BeginRemoveVersion == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginRemoveVersion not implemented")}
	}
	beginRemoveVersion := s.beginRemoveVersion.get(req)
	if beginRemoveVersion == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/removeVersion`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.VersionParameter](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginRemoveVersion(req.Context(), resourceGroupNameParam, solutionTemplateNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginRemoveVersion = &respr
		s.beginRemoveVersion.add(req, beginRemoveVersion)
	}

	resp, err := server.PollerResponderNext(beginRemoveVersion, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		s.beginRemoveVersion.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginRemoveVersion) {
		s.beginRemoveVersion.remove(req)
	}

	return resp, nil
}

func (s *SolutionTemplatesServerTransport) dispatchUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.Update == nil {
		return nil, &nonRetriableError{errors.New("fake for method Update not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 4 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SolutionTemplateUpdate](req)
	if err != nil {
		return nil, err
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Update(req.Context(), resourceGroupNameParam, solutionTemplateNameParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SolutionTemplate, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to SolutionTemplatesServerTransport
var solutionTemplatesServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/solutiontemplateversions_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// SolutionTemplateVersionsServer is a fake server for instances of the armworkloadorchestration.SolutionTemplateVersionsClient type.
type SolutionTemplateVersionsServer struct {
	// BeginBulkDeploySolution is the fake for method SolutionTemplateVersionsClient.BeginBulkDeploySolution
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginBulkDeploySolution func(ctx context.Context, resourceGroupName string, solutionTemplateName string, solutionTemplateVersionName string, body armworkloadorchestration.BulkDeploySolutionParameter, options *armworkloadorchestration.SolutionTemplateVersionsClientBeginBulkDeploySolutionOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionTemplateVersionsClientBulkDeploySolutionResponse], errResp azfake.ErrorResponder)

	// BeginBulkPublishSolution is the fake for method SolutionTemplateVersionsClient.BeginBulkPublishSolution
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginBulkPublishSolution func(ctx context.Context, resourceGroupName string, solutionTemplateName string, solutionTemplateVersionName string, body armworkloadorchestration.BulkPublishSolutionParameter, options *armworkloadorchestration.SolutionTemplateVersionsClientBeginBulkPublishSolutionOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionTemplateVersionsClientBulkPublishSolutionResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method SolutionTemplateVersionsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, solutionTemplateName string, solutionTemplateVersionName string, options *armworkloadorchestration.SolutionTemplateVersionsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.SolutionTemplateVersionsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListBySolutionTemplatePager is the fake for method SolutionTemplateVersionsClient.NewListBySolutionTemplatePager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySolutionTemplatePager func(resourceGroupName string, solutionTemplateName string, options *armworkloadorchestration.SolutionTemplateVersionsClientListBySolutionTemplateOptions) (resp azfake.PagerResponder[armworkloadorchestration.SolutionTemplateVersionsClientListBySolutionTemplateResponse])
}

// NewSolutionTemplateVersionsServerTransport creates a new instance of SolutionTemplateVersionsServerTransport with the provided implementation.
// The returned SolutionTemplateVersionsServerTransport instance is connected to an instance of armworkloadorchestration.SolutionTemplateVersionsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewSolutionTemplateVersionsServerTransport(srv *SolutionTemplateVersionsServer) *SolutionTemplateVersionsServerTransport {
	return &SolutionTemplateVersionsServerTransport{
		srv:                            srv,
		beginBulkDeploySolution:        newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplateVersionsClientBulkDeploySolutionResponse]](),
		beginBulkPublishSolution:       newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplateVersionsClientBulkPublishSolutionResponse]](),
		newListBySolutionTemplatePager: newTracker[azfake.PagerResponder[armworkloadorchestration.SolutionTemplateVersionsClientListBySolutionTemplateResponse]](),
	}
}

// SolutionTemplateVersionsServerTransport connects instances of armworkloadorchestration.SolutionTemplateVersionsClient to instances of SolutionTemplateVersionsServer.
// Don't use this type directly, use NewSolutionTemplateVersionsServerTransport instead.
type SolutionTemplateVersionsServerTransport struct {
	srv                            *SolutionTemplateVersionsServer
	beginBulkDeploySolution        *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplateVersionsClientBulkDeploySolutionResponse]]
	beginBulkPublishSolution       *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionTemplateVersionsClientBulkPublishSolutionResponse]]
	newListBySolutionTemplatePager *tracker[azfake.PagerResponder[armworkloadorchestration.SolutionTemplateVersionsClientListBySolutionTemplateResponse]]
}

// Do implements the policy.Transporter interface for SolutionTemplateVersionsServerTransport.
func (s *SolutionTemplateVersionsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToMethodFake(req, method)
}

func (s *SolutionTemplateVersionsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if solutionTemplateVersionsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = solutionTemplateVersionsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "SolutionTemplateVersionsClient.BeginBulkDeploySolution":
				res.resp, res.err = s.dispatchBeginBulkDeploySolution(req)
			case "SolutionTemplateVersionsClient.BeginBulkPublishSolution":
				res.resp, res.err = s.dispatchBeginBulkPublishSolution(req)
			case "SolutionTemplateVersionsClient.Get":
				res.resp, res.err = s.dispatchGet(req)
			case "SolutionTemplateVersionsClient.NewListBySolutionTemplatePager":
				res.resp, res.err = s.dispatchNewListBySolutionTemplatePager(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *SolutionTemplateVersionsServerTransport) dispatchBeginBulkDeploySolution(req *http.Request) (*http.Response, error) {
	if s.srv.BeginBulkDeploySolution == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginBulkDeploySolution not implemented")}
	}
	beginBulkDeploySolution := s.beginBulkDeploySolution.get(req)
	if beginBulkDeploySolution == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<solutionTemplateVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/bulkDeploySolution`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.BulkDeploySolutionParameter](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
		if err != nil {
			return nil, err
		}
		solutionTemplateVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateVersionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginBulkDeploySolution(req.Context(), resourceGroupNameParam, solutionTemplateNameParam, solutionTemplateVersionNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginBulkDeploySolution = &respr
		s.beginBulkDeploySolution.add(req, beginBulkDeploySolution)
	}

	resp, err := server.PollerResponderNext(beginBulkDeploySolution, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		s.beginBulkDeploySolution.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginBulkDeploySolution) {
		s.beginBulkDeploySolution.remove(req)
	}

	return resp, nil
}

func (s *SolutionTemplateVersionsServerTransport) dispatchBeginBulkPublishSolution(req *http.Request) (*http.Response, error) {
	if s.srv.BeginBulkPublishSolution == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginBulkPublishSolution not implemented")}
	}
	beginBulkPublishSolution := s.beginBulkPublishSolution.get(req)
	if beginBulkPublishSolution == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<solutionTemplateVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/bulkPublishSolution`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 5 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.BulkPublishSolutionParameter](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
		if err != nil {
			return nil, err
		}
		solutionTemplateVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateVersionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginBulkPublishSolution(req.Context(), resourceGroupNameParam, solutionTemplateNameParam, solutionTemplateVersionNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginBulkPublishSolution = &respr
		s.beginBulkPublishSolution.add(req, beginBulkPublishSolution)
	}

	resp, err := server.PollerResponderNext(beginBulkPublishSolution, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		s.beginBulkPublishSolution.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginBulkPublishSolution) {
		s.beginBulkPublishSolution.remove(req)
	}

	return resp, nil
}

func (s *SolutionTemplateVersionsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if s.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<solutionTemplateVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 5 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
	if err != nil {
		return nil, err
	}
	solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
	if err != nil {
		return nil, err
	}
	solutionTemplateVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateVersionName")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Get(req.Context(), resourceGroupNameParam, solutionTemplateNameParam, solutionTemplateVersionNameParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SolutionTemplateVersion, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SolutionTemplateVersionsServerTransport) dispatchNewListBySolutionTemplatePager(req *http.Request) (*http.Response, error) {
	if s.srv.NewListBySolutionTemplatePager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListBySolutionTemplatePager not implemented")}
	}
	newListBySolutionTemplatePager := s.newListBySolutionTemplatePager.get(req)
	if newListBySolutionTemplatePager == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/solutionTemplates/(?P<solutionTemplateName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 4 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		solutionTemplateNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionTemplateName")])
		if err != nil {
			return nil, err
		}
		resp := s.srv.NewListBySolutionTemplatePager(resourceGroupNameParam, solutionTemplateNameParam, nil)
		newListBySolutionTemplatePager = &resp
		s.newListBySolutionTemplatePager.add(req, newListBySolutionTemplatePager)
		server.PagerResponderInjectNextLinks(newListBySolutionTemplatePager, req, func(page *armworkloadorchestration.SolutionTemplateVersionsClientListBySolutionTemplateResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListBySolutionTemplatePager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		s.newListBySolutionTemplatePager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListBySolutionTemplatePager) {
		s.newListBySolutionTemplatePager.remove(req)
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to SolutionTemplateVersionsServerTransport
var solutionTemplateVersionsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}



================================================
FILE: sdk/resourcemanager/workloadorchestration/armworkloadorchestration/fake/solutionversions_server.go
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/workloadorchestration/armworkloadorchestration"
	"net/http"
	"net/url"
	"regexp"
)

// SolutionVersionsServer is a fake server for instances of the armworkloadorchestration.SolutionVersionsClient type.
type SolutionVersionsServer struct {
	// BeginCreateOrUpdate is the fake for method SolutionVersionsClient.BeginCreateOrUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginCreateOrUpdate func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, solutionVersionName string, resource armworkloadorchestration.SolutionVersion, options *armworkloadorchestration.SolutionVersionsClientBeginCreateOrUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionVersionsClientCreateOrUpdateResponse], errResp azfake.ErrorResponder)

	// BeginDelete is the fake for method SolutionVersionsClient.BeginDelete
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDelete func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, solutionVersionName string, options *armworkloadorchestration.SolutionVersionsClientBeginDeleteOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionVersionsClientDeleteResponse], errResp azfake.ErrorResponder)

	// Get is the fake for method SolutionVersionsClient.Get
	// HTTP status codes to indicate success: http.StatusOK
	Get func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, solutionVersionName string, options *armworkloadorchestration.SolutionVersionsClientGetOptions) (resp azfake.Responder[armworkloadorchestration.SolutionVersionsClientGetResponse], errResp azfake.ErrorResponder)

	// NewListBySolutionPager is the fake for method SolutionVersionsClient.NewListBySolutionPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBySolutionPager func(resourceGroupName string, targetName string, solutionName string, options *armworkloadorchestration.SolutionVersionsClientListBySolutionOptions) (resp azfake.PagerResponder[armworkloadorchestration.SolutionVersionsClientListBySolutionResponse])

	// BeginUpdate is the fake for method SolutionVersionsClient.BeginUpdate
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginUpdate func(ctx context.Context, resourceGroupName string, targetName string, solutionName string, solutionVersionName string, properties armworkloadorchestration.SolutionVersion, options *armworkloadorchestration.SolutionVersionsClientBeginUpdateOptions) (resp azfake.PollerResponder[armworkloadorchestration.SolutionVersionsClientUpdateResponse], errResp azfake.ErrorResponder)
}

// NewSolutionVersionsServerTransport creates a new instance of SolutionVersionsServerTransport with the provided implementation.
// The returned SolutionVersionsServerTransport instance is connected to an instance of armworkloadorchestration.SolutionVersionsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewSolutionVersionsServerTransport(srv *SolutionVersionsServer) *SolutionVersionsServerTransport {
	return &SolutionVersionsServerTransport{
		srv:                    srv,
		beginCreateOrUpdate:    newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionVersionsClientCreateOrUpdateResponse]](),
		beginDelete:            newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionVersionsClientDeleteResponse]](),
		newListBySolutionPager: newTracker[azfake.PagerResponder[armworkloadorchestration.SolutionVersionsClientListBySolutionResponse]](),
		beginUpdate:            newTracker[azfake.PollerResponder[armworkloadorchestration.SolutionVersionsClientUpdateResponse]](),
	}
}

// SolutionVersionsServerTransport connects instances of armworkloadorchestration.SolutionVersionsClient to instances of SolutionVersionsServer.
// Don't use this type directly, use NewSolutionVersionsServerTransport instead.
type SolutionVersionsServerTransport struct {
	srv                    *SolutionVersionsServer
	beginCreateOrUpdate    *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionVersionsClientCreateOrUpdateResponse]]
	beginDelete            *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionVersionsClientDeleteResponse]]
	newListBySolutionPager *tracker[azfake.PagerResponder[armworkloadorchestration.SolutionVersionsClientListBySolutionResponse]]
	beginUpdate            *tracker[azfake.PollerResponder[armworkloadorchestration.SolutionVersionsClientUpdateResponse]]
}

// Do implements the policy.Transporter interface for SolutionVersionsServerTransport.
func (s *SolutionVersionsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToMethodFake(req, method)
}

func (s *SolutionVersionsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if solutionVersionsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = solutionVersionsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "SolutionVersionsClient.BeginCreateOrUpdate":
				res.resp, res.err = s.dispatchBeginCreateOrUpdate(req)
			case "SolutionVersionsClient.BeginDelete":
				res.resp, res.err = s.dispatchBeginDelete(req)
			case "SolutionVersionsClient.Get":
				res.resp, res.err = s.dispatchGet(req)
			case "SolutionVersionsClient.NewListBySolutionPager":
				res.resp, res.err = s.dispatchNewListBySolutionPager(req)
			case "SolutionVersionsClient.BeginUpdate":
				res.resp, res.err = s.dispatchBeginUpdate(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *SolutionVersionsServerTransport) dispatchBeginCreateOrUpdate(req *http.Request) (*http.Response, error) {
	if s.srv.BeginCreateOrUpdate == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginCreateOrUpdate not implemented")}
	}
	beginCreateOrUpdate := s.beginCreateOrUpdate.get(req)
	if beginCreateOrUpdate == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<solutionVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 6 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[armworkloadorchestration.SolutionVersion](req)
		if err != nil {
			return nil, err
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		solutionVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionVersionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginCreateOrUpdate(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, solutionVersionNameParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginCreateOrUpdate = &respr
		s.beginCreateOrUpdate.add(req, beginCreateOrUpdate)
	}

	resp, err := server.PollerResponderNext(beginCreateOrUpdate, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		s.beginCreateOrUpdate.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginCreateOrUpdate) {
		s.beginCreateOrUpdate.remove(req)
	}

	return resp, nil
}

func (s *SolutionVersionsServerTransport) dispatchBeginDelete(req *http.Request) (*http.Response, error) {
	if s.srv.BeginDelete == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete not implemented")}
	}
	beginDelete := s.beginDelete.get(req)
	if beginDelete == nil {
		const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<solutionVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 6 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		resourceGroupNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("resourceGroupName")])
		if err != nil {
			return nil, err
		}
		targetNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("targetName")])
		if err != nil {
			return nil, err
		}
		solutionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionName")])
		if err != nil {
			return nil, err
		}
		solutionVersionNameParam, err := url.PathUnescape(matches[regex.SubexpIndex("solutionVersionName")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginDelete(req.Context(), resourceGroupNameParam, targetNameParam, solutionNameParam, solutionVersionNameParam, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete = &respr
		s.beginDelete.add(req, beginDelete)
	}

	resp, err := server.PollerResponderNext(beginDelete, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		s.beginDelete.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete) {
		s.beginDelete.remove(req)
	}

	return resp, nil
}

func (s *SolutionVersionsServerTransport) dispatchGet(req *http.Request) (*http.Response, error) {
	if s.srv.Get == nil {
		return nil, &nonRetriableError{errors.New("fake for method Get not implemented")}
	}
	const regexStr = `/subscriptions/(?P<subscriptionId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/resourceGroups/(?P<resourceGroupName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/providers/Microsoft\.Edge/targets/(?P<targetName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/solutions/(?P<solutionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/versions/(?P<solutionVersionName>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 6 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	resourceGr